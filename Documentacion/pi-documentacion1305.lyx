#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
\usepackage{babel}
\addto\captionsenglish{%
 \renewcommand{\figurename}{Figura }%
 \renewcommand{\contentsname}{Índice}%
 \renewcommand{\listfigurename}{Lista de figuras}%
 \renewcommand{\tablename}{Tabla }%
 \renewcommand{\listtablename}{Lista de tablas}%
 \renewcommand{\partname}{Capítulo }%
}
\end_preamble
\options listitoc, tablecaptionabove, bibtotoc
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\bullet 1 0 9 -1
\bullet 2 0 15 -1
\bullet 3 0 6 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\noindent

\family sans
\series bold
\size huge
Universidad Nacional de Córdoba
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename Imagenes/Escudo_UNC_modernoo.png
	width 10cm
	height 10cm
	keepAspectRatio
	rotateOrigin centerBottom

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\family sans
\series bold
\size largest
Facultad de Ciencias Exactas, Físicas y Naturales
\end_layout

\begin_layout Standard
\noindent
\align center

\family sans
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\family sans
\series bold
\size larger
Infraestructura tecnológica virtual con automatización y orquestación.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align right

\family sans
\series bold
Alumnos:
\series default
 Juan Arese, Werner Diers
\end_layout

\begin_layout Standard
\noindent
\align right

\family sans
\series bold
Director de PI: 
\series default
Eschoyez, Maximiliano Andrés 
\end_layout

\begin_layout Standard
\noindent
\align right

\family sans
\series bold
Co-director de PI:
\series default
 Migliazzo, Oscar Andrés
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Part
Introducción
\end_layout

\begin_layout Section
Resumen del Proyecto Integrador
\end_layout

\begin_layout Standard
El Sistema desarrollado en este Proyecto Integrador, pretende facilitar
 algunas de las tareas que los administradores de los laboratorios realizan
 en las salas de informática.
 Las funcionalidades desarrolladas permiten a los administradores (o incluso
 a cualquier persona sin conocimiento técnico) crear maquinas virtuales
 con un solo click, dichas maquinas virtuales cuentan con todos los servicios
 y programas necesarios para los alumnos de las diferentes carreras o inclusive
 se pueden crear maquinas virtuales con otros perfiles, como un perfil para
 docentes.
 Además, permite orquestar las políticas a seguir de las diferentes máquinas
 de la red.
\end_layout

\begin_layout Subsection
Descripción
\end_layout

\begin_layout Standard
El sistema de infraestructura virtual con automatización y orquestación,
 tiene como objetivo principal brindar una herramienta a los administradores
 de laboratorios que facilite la preparación y configuración de sus aulas
 de manera simple.
\end_layout

\begin_layout Standard
El sistema está dividido en dos partes.
 Una parte de la herramienta está destinada al despliegue en masa de máquinas
 virtuales.
 Permite al administrador, crear múltiples máquinas virtuales con escasa
 interacción humana, de forma automática.
 Pudiéndose especificar el sistema operativo deseado y componentes de hardware.
 Del mismo modo, en un laboratorio con máquinas físicas, es posible realizar
 el despliegue a través de la red.
\end_layout

\begin_layout Standard
La segunda parte está destinada a la administración de la configuración
 de las máquinas virtuales.
 El sistema permite aplicar cambios de configuración y políticas a un conjunto
 de máquinas como también a máquinas particulares.
 Esto evita que el administrador tenga que preparar cada estación de trabajo
 de a una por vez, disminuyendo la carga de trabajo y el tiempo requerido
 para llevar a cabo la tarea.
\end_layout

\begin_layout Standard
El sistema incluye desarrollo en el lenguaje de programación Python, bash
 y el lenguaje propio de Puppet, la herramienta utilizada para la orquestación.
 El servidor de aprovisionamiento, haciendo uso del protocolo PXE, será
 el encargado de atender las peticiones de los dispositivos para su instalación.
\end_layout

\begin_layout Standard
Este Proyecto Integrador servirá como base para futuros Proyectos.
\end_layout

\begin_layout Subsection
Objetivos 
\end_layout

\begin_layout Standard

\series bold
Principal:
\series default
 
\end_layout

\begin_layout Itemize
Desarrollar un sistema para manejar automatismos administrados de políticas
 de una institución o empresa, para que el administrador pueda configurar
 las máquinas virtuales o físicas que se utilizan en la misma.
 Como caso particular se tomará un laboratorio informático de aprendizaje.
\end_layout

\begin_layout Standard

\series bold
Secundarios: 
\end_layout

\begin_layout Itemize
Estudiar Sistemas Operativos para servidor.
\end_layout

\begin_layout Itemize
Estudiar herramientas de virtualización.
\end_layout

\begin_layout Itemize
Estudiar herramientas de aprovisionamiento.
 
\end_layout

\begin_layout Itemize
Estudiar herramientas de administración de configuración.
\end_layout

\begin_layout Itemize
Analizar protocolos para inicio a través de la red como PXE.
\end_layout

\begin_layout Standard

\series bold
Antecedentes de Proyectos similares 
\end_layout

\begin_layout Itemize
No hay antecedentes en este tema.
\end_layout

\begin_layout Subsection
Intereses personales 
\end_layout

\begin_layout Standard
La principal motivación en este Proyecto Integrador es darle un final a
 la carrera de grado de Ingeniería en Computación realizando un proyecto
 que nos de más herramientas para nuestro futuro laboral.
 Abordamos temas como sistemas operativos, sistemas de archivos, protocolos,
 metodologías de desarrollo, redes de datos, programación en Python, Shell
 scripting, virtualización, diagramas UML.
\end_layout

\begin_layout Subsection
Intereses Institucionales 
\end_layout

\begin_layout Standard
La Facultad de Ciencias Exactas, Físicas y Naturales actualmente cuenta
 con alrededor de cinco aulas de informática, en las cuales se dictan materias
 de todos los ciclos y especialidades de ingeniería.
 La idea del Proyecto Integrador es desarrollar un sistema de infraestructura
 con automatización y orquestación que permita disminuir la carga de trabajo
 de los administradores de estas aulas y facilitar las tareas de mantenimiento
 de las mismas, cumpliendo con las políticas del área que administra las
 aulas.
\end_layout

\begin_layout Subsection
Metodología 
\end_layout

\begin_layout Standard
Para afrontar el Proyecto Integrador de la carrera se utilizó una metodología
 de desarrollo ágil de software basado en el desarrollo iterativo e incremental.
 El trabajo desarrollado en una unidad de tiempo es llamado una iteración,
 las cuales constan de un corto lapso de tiempo de entre una y tres semanas.
 Cada iteración se compone de un ciclo de vida que integra diversas etapas
 como planificación, definición de los requerimientos, investigación, diseño,
 codificación, pruebas y documentación.
 En cada iteración se agrega una nueva “funcionalidad” al sistema y a medida
 que avanzan los ciclos el sistema aumenta de tamaño, por esto lo llamamos
 incremental.
 Otra característica de la metodología ágil que se utilizó, es una comunicación
 fluida con el “cliente” que en este caso son los Directores del Proyecto
 Integrador, de los que también se obtienen los requerimientos.
 Esto permite una buena retro-alimentación, con la cual se devuelven correccione
s .
 No ser estrictos con la documentación es una característica que se tomó
 del desarrollo ágil, tener todo anotado luego facilita la generación del
 informe.
 
\end_layout

\begin_layout Standard

\series bold
Lugar previsto para la realización: 
\end_layout

\begin_layout Itemize
Laboratorio de Arquitectura de Computadoras, Facultad de Ciencias Exactas,
 Físicas y Naturales.
 
\end_layout

\begin_layout Standard

\series bold
Requerimiento de Instrumental y Equipos: 
\end_layout

\begin_layout Itemize
Computadora personal.
\end_layout

\begin_layout Standard

\series bold
Inversión económica: 
\end_layout

\begin_layout Itemize
Inversión provista por el alumno: ninguna
\end_layout

\begin_layout Itemize
Apoyo económico externo a la Facultad: ninguno.
\end_layout

\begin_layout Subsection
Requerimientos 
\end_layout

\begin_layout Standard
Los requerimientos del sistema se obtuvieron directamente desde el Director
 y el Codirector del Proyecto Integrador.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar distintos sistemas operativos:
\end_layout

\begin_deeper
\begin_layout Standard
CentOS 
\end_layout

\begin_layout Standard
Ubuntu
\end_layout

\begin_layout Standard
Windows 
\end_layout

\end_deeper
\begin_layout Enumerate
La herramienta debe poder aprovisionar máquinas virtuales con o sin GUI
 .
 
\end_layout

\begin_layout Enumerate
La herramienta debe aprovisionar a través de la red.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar utilizando plantillas.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar utilizando repositorios locales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder actualizar los repositorios locales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder setear políticas a las máquinas virtuales,utilizando
 Puppet.
 
\end_layout

\begin_layout Enumerate
La herramienta debe ser escalable, integrar nuevas máquinas virtuales fácilmente.
 
\end_layout

\begin_layout Enumerate
La herramienta debe utilizar licencias de código abierto.
 
\end_layout

\begin_layout Enumerate
La herramienta debe estar implementada en la versión más actual al momento
 de realizar el Proyecto Integrador.
\end_layout

\begin_layout Subsection
Cronograma a seguir
\end_layout

\begin_layout Standard
El cronograma está dividido en seis etapas diferentes:
\end_layout

\begin_layout Itemize
Familiarización con el sistema operativo GNU/Linux elegido.
 
\end_layout

\begin_layout Itemize
Investigación de diferentes herramientas de virtualización.
 
\end_layout

\begin_layout Itemize
Investigación de diferentes herramientas de aprovisionamiento.
\end_layout

\begin_layout Itemize
Pruebas de las herramientas seleccionadas.
 
\end_layout

\begin_layout Itemize
Pruebas de la herramienta de administración de configuración.
 
\end_layout

\begin_layout Itemize
Preparación y desarrollo del informe del trabajo final y cierre del mismo.
\end_layout

\begin_layout Subsection
Objetivo a alcanzar en cada etapa:
\end_layout

\begin_layout Itemize

\series bold
Primera etapa:
\series default
 conocer el sistema operativo GNU/Linux.
 La principal motivación, es la de informarse sobre la base donde se implementar
á el sistema desarrollado en este Proyecto Integrador.
 
\end_layout

\begin_layout Itemize

\series bold
Segunda etapa:
\series default
 obtener los conocimientos suficientes para crear y administrar máquinas
 virtuales.
 
\end_layout

\begin_layout Itemize

\series bold
Tercera etapa:
\series default
 conocer cuáles son las herramientas disponibles y utilizadas en ambientes
 de producción para el aprovisionamiento de máquinas, teniendo en cuenta
 que deben ser de código abierto, analizarlas y elegir la más apropiada
 para realizar el Proyecto Integrador.
 
\end_layout

\begin_layout Itemize

\series bold
Cuarta etapa: 
\series default
implementar las herramientas seleccionadas en conjunto.
 
\end_layout

\begin_layout Itemize

\series bold
Quinta etapa:
\series default
 realizar la implementación conjunta de todas las herramientas automatizando
 la instalación y realizar configuraciones pertinentes en los sistemas ya
 instalados, por medio de Puppet.
 
\end_layout

\begin_layout Itemize

\series bold
Sexta etapa: 
\series default
desarrollo del informe del trabajo final
\end_layout

\begin_layout Part
Marco teórico
\end_layout

\begin_layout Standard
Previamente al abordaje del desarrollo, requerimos conocimientos teóricos
 que nos posibiliten comprender el entorno donde se ejecutarán las aplicaciones
 que componen el Sistema, las herramientas que darán soporte o permitirán
 cumplir con las funcionalidades previstas y las que se utilizarán para
 desarrollar.
 Algunas de las mismas fueron explícitamente solicitadas en los requerimientos.
 El resto de las herramientas, que están implícitas en los requerimientos,
 precisaron de investigación y pruebas para conocer si permiten cumplir
 estos requerimientos y además, si hay varias opciones, elegir la más convenient
e.
 Podemos dividir esta sección del informe en áreas diferentes:
\end_layout

\begin_layout Itemize
Sistema operativo 
\end_layout

\begin_layout Itemize
Virtualización 
\end_layout

\begin_layout Itemize
Aprovisionamiento 
\end_layout

\begin_layout Itemize
Orquestación
\end_layout

\begin_layout Itemize
Protocolo PXE
\end_layout

\begin_layout Itemize
SAMBA
\end_layout

\begin_layout Standard
La información contenida en esta sección se desprende de las investigaciones
 realizadas en cada una de las etapas del Proyecto Integrador.
\end_layout

\begin_layout Section
Sistema operativo
\end_layout

\begin_layout Subsection
CentOS 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_centos.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CentOS logo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
CentOS es un distribución Linux empresarial, basada en Red Hat Enterprise
 Linux.
 CentOS concuerda con la política de distribución de Red Hat y apunta a
 ser binariamente compatible en su totalidad.
 Cada versión de esta distro tiene soporte por siete años en cuestiones
 de actualizaciones de mantenimiento y seguridad, lo que se traduce en un
 ambiente confiable, predecible, reproducible, de bajo mantenimiento y seguro.
\end_layout

\begin_layout Standard
La principal ventaja de esta distro es que se obtiene un conjunto estable
 de la mayoría de paquetes que por lo general sólo incluyen correcciones
 de errores.
 En su última versión, CentOS 7 solo está disponible para la arquitectura
 x86_64, y representa un gran cambio frente a versiones anteriores del sistema
 operativo, como la inclusión de systemd, Gnome 3, GRUB 2, y el sistema
 de archivos XFS.
 El entorno de escritorio KDE también forma parte de la oferta de CentOS
 7.
 
\end_layout

\begin_layout Standard
Principales novedades de CentOS 7:
\end_layout

\begin_layout Itemize
Actualización del núcleo del sistema: Kernel 3.10.0.
 
\end_layout

\begin_layout Itemize
Soporte para Linux Containers.
 
\end_layout

\begin_layout Itemize
Inclusión de VMware Tools y controladores de gráficos 3D.
 
\end_layout

\begin_layout Itemize
OpenJDK-7 como JDK por defecto.
 
\end_layout

\begin_layout Itemize
Cambio a systemd.
 
\end_layout

\begin_layout Itemize
Cambio a firewalld y GRUB2 .
\end_layout

\begin_layout Itemize
XFS es el sistema de archivos por defecto y permite escalar la capacidad
 de almacenamiento del sistema hasta 500 terabytes.
 XFS es un sistema de archivos de 64 bits con journaling de alto rendimiento,
 y está especialmente indicado para discos grandes (superiores a 1 TB).
 No obstante y para necesidades menos exigentes se pueden emplear otros
 sistemas de archivos, como Ext4.
 
\end_layout

\begin_layout Itemize
iSCSI y FCoE (Fiber Channel over Ethernet) en el espacio del Kernel.
 
\end_layout

\begin_layout Itemize
Soporte para PPTv2 (Precisión Time Protocol).
\end_layout

\begin_layout Itemize
Soporte para tarjetas Ethernet 40G.
 
\end_layout

\begin_layout Itemize
Soporte UEFI.
 
\end_layout

\begin_layout Standard
En cuanto a systemd, es el reemplazo de init como demonio para iniciar servicios
, procesos y recursos del sistema.
 Systemd es la nueva forma predeterminada de iniciar los sistemas Linux,
 y ha sido adoptado por Red Hat, Debian y Ubuntu, entre otros.
 CentOS 7 es compatible con Microsoft Active Directory (y obviamente con
 Red Hat), por lo que puede trabajar con facilidad en entornos heterogéneos.
 CentOS 7 incluye PCP (Performance Co-Pilot), un conjunto de frameworks
 y servicios en tiempo real para supervisar y monitorizar el rendimiento
 del sistema.
\end_layout

\begin_layout Subsection
Debian
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_debian.gif
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Debian logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Debian es una distribución libre, por completo manejada por la comunidad,
 no está basada en ninguna otra distribución y por el contrario gran parte
 de las distribuciones actuales están basadas en ella.
 Debian es famoso por filosofía de estabilidad ante todo, por eso mismo,
 no tiene un cronograma de lanzamiento de nuevas versiones.
 Estas se liberan cuando estén realmente listas.
 Es una distribución ampliamente utilizada.
\end_layout

\begin_layout Standard
En su última versión, Debian 8 Jessie, las siguientes arquitecturas tienen
 soporte: x32 (i386), x86-64 (amd64), Motorola/IBM PowerPC, MIPS, IBM S/390
 y ARM.
 
\end_layout

\begin_layout Standard
Este release incluye el nuevo estándar sistema de inicio 
\emph on
systemd.
\end_layout

\begin_layout Standard
Principales características de Jessie:
\end_layout

\begin_layout Itemize
Actualización de administrador de paquetes: apt 1.0.9.8.1 
\end_layout

\begin_layout Itemize
Núcleo del sistema: Linux kernel 3.16 
\end_layout

\begin_layout Itemize
Cambio a systemd.
 
\end_layout

\begin_layout Itemize
Entornos gráficos : Gnome 3.14, KDE 4.14, 
\end_layout

\begin_layout Itemize
Los puertos para el kernel de FreeBSD (kfreebsd-amd64 y kfreebsd-i386),
 incluidos para versiones anteriores no son parte de esta versión.
\end_layout

\begin_layout Itemize
Soporte UEFI para amd64, i386 y arm64.
\end_layout

\begin_layout Standard
Esto permitiría aprovechar todas las ventajas de FreeBSD en el servidor,
 brindándole la opción de usar Debian a los usuarios del servidor y eliminando
 la necesidad de que se familiaricen con FreeBSD.
\end_layout

\begin_layout Subsection
FreeBSD
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_freebsd.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
FreeBSD logo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
FreeBSD es un sistema operativo basado en BSD para arquitecturas Intel (x86
 e Itanium), AMD64, AlphaTM y UltraSPARC.
 
\end_layout

\begin_layout Standard
FreeBSD viene con una excelente colección de herramientas de sistema como
 parte del sistema base.
 A pesar de esto, existen otras que no vienen incluidas y se necesitan instalar
 para utilizarlas.
 FreeBSD ofrece dos tecnologías complementarias para instalar software de
 terceros en el sistema: la Colección de puertos o ports de FreeBSD y los
 paquetes binarios.
 Los paquetes binarios son archivos simples que descargamos desde repositorios.
 Contienen una copia de los programas binarios precompilados de la aplicación
 y se pueden manipular con las herramientas de gestión de paquetes de FreeBSD:
 pkg_add , pkg_delete , pkg_info , etc.
 Por otro lado, existen ciertos pasos que se deben llevar a cabo para compilar
 un programa (descargar, desempaquetar, parchear, compilar e instalar).
 Los ficheros que conforman un port permiten que el sistema se encargue
 de todo esto, mediante un conjunto simple de órdenes.
 La colección de puertos para instalar se encuentra en /usr/ports.
\end_layout

\begin_layout Standard
FreeBSD proporciona compatibilidad binaria con muchos otros sistemas operativos
 tipo UNIX, como Linux.
 Esto es necesario, ya que muchos desarrolladores y compañías sólo desarrollan
 para Linux.
 La compatibilidad binaria permite a los usuarios utilizar en FreeBSD cerca
 del 90% de las aplicaciones desarrolladas para Linux sin que sea necesario
 realizar alguna modificación sobre la aplicación.
\end_layout

\begin_layout Standard
Otras características:
\end_layout

\begin_layout Itemize
Servicios multiusuario que permiten a mucha gente usar el sistema FreeBSD
 simultáneamente.
\end_layout

\begin_layout Itemize
Conexión de redes TCP/IP muy robusta, con soporte para estándares industriales.
 
\end_layout

\begin_layout Itemize
La protección de memoria que garantiza que las aplicaciones (o los usuarios)
 no se estorben los unos a los otros.
\end_layout

\begin_layout Itemize
Compatibilidad binaria con muchos programas nativos de Linux, SCO, SVR4,
 BSDI y NetBSD.
 
\end_layout

\begin_layout Itemize
Soporte para multiprocesamiento simétrico con múltiples CPUs.
\end_layout

\begin_layout Subsection
Solaris
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_solaris.gif
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solaris logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Solaris es un sistema operativo de tipo Unix desarrollado por Sun Microsystems
 desde 1992 como sucesor de SunOs.
 Es un sistema certificado oficialmente como versión de Unix.
 Aunque solaris fue desarrollado como software privado, la mayor parte de
 su código se ha liberado como proyecto de software libre denominado OpenSolaris.
 Solaris es famoso por su escalabilidad, especialmente en sistemas SPARC.
 Sun solaris se ejecuta sobre la arquitectura SPARC en 32 y 64 bits, o sobre
 procesadores x86 (incluidos Intel y AMD).
 Sin embargo, en agosto de 2010, Oracle decidió interrumpir la publicación
 y distribución de OpenSolaris.
\end_layout

\begin_layout Standard
Solaris tiene una reputación de ser muy adecuado para el multiprocesamiento
 simétrico (SMP), soportando un gran número de CPUs.
 Históricamente Solaris ha estado firmemente integrado con la plataforma
 hardware de Sun, SPARC, con la cual fue diseñado y promocionado como un
 paquete combinado.
 Esto proporcionaba frecuentemente unos sistemas más fiables pero con un
 coste más elevado que el del hardware de PC.
 
\end_layout

\begin_layout Standard
A partir de su versión 10, Sun Microsystems ha promocionado Solarios con
 sus propias estaciones de trabajo y servidores de 64 bits basados en procesador
es AMD Opteron e Intel Xeon, como también en sistemas de 32 bits.
 Esta versión añadió soporte para para-virtualización cuando es utilizada
 como “sistema operativo invitado” en ambientes basados en Xen.
 
\end_layout

\begin_layout Standard
En su última versión, 11.3, sus principales características son:
\end_layout

\begin_layout Itemize
Incluye una nueva versión de OpenStack (Juno) con soporte para topologías
 de red adicionales y nuevos servicios.
 
\end_layout

\begin_layout Itemize
SNAT, soporte Ipv6.
\end_layout

\begin_layout Itemize
Pools de almacenamiento.
 
\end_layout

\begin_layout Itemize
Aprovisionamiento de máquinas (bare metal provisioning) como servicio .
\end_layout

\begin_layout Itemize
Incluye soporte para desarrollo basado en la API REST utilizando el Demonio
 de Administración Remota (permite configuración remota de los sistemas
 Oracle usando Python, C y Java).
 
\end_layout

\begin_layout Itemize
Sistema de archivos ZFS.
\end_layout

\begin_layout Itemize
Solaris Containers
\end_layout

\begin_layout Section
Virtualización 
\end_layout

\begin_layout Standard
Virtualización es un término amplio para software ejecutándose, usualmente
 sistemas operativos, de manera concurrente y aislada de otros programas
 en el mismo sistema.
 Muchas de las implementaciones de virtualización utilizan un “hypervisor”,
 una capa de software que controla el hardware y provee sistemas operativos
 huéspedes con acceso a los dispositivos de hardware subyacentes.
 El hypervisor permite ejecutar múltiples sistemas operativos en el mismo
 sistema físico ofreciendo hardware virtualizado al sistema operativo huésped.
 Esta tecnología, provee un conjunto de herramientas para aumentar la flexibilid
ad y reducir los costos, los cuales son tópicos importantes en cualquier
 empresa o institución.
 En esencia, la virtualización incrementa la flexibilidad desacoplando un
 sistema operativo y los servicios y aplicaciones soportados por él, de
 una plataforma de hardware física específica, permitiendo el establecimiento
 de múltiples entornos virtuales sobre una plataforma de hardware compartida.
 Estos entornos pueden ser creados localmente o aprovisionados externamente.
 La virtualización se destaca también apoyando la innovación a través del
 uso de entornos virtuales para practicar y aprender.
 Un estudiante puede comenzar un curso o trabajo un entorno de sistema conocido,
 estándar y aislado del entorno de producción; si se produce algún tipo
 de daño solo afecta al sistema virtual.
 Además se puede establecer entornos únicos de software para el aprendizaje
 sin demandar el uso exclusivo de recursos de hardware.
 Aunque en comparación los costos de inversión para tener un número elevado
 de máquinas físicas son mucho mayores que el costo para invertir en un
 servidor con altos recursos para realizar la virtualización, se podría
 decir que la virtualización posee inconvenientes vinculados con sus exigentes
 requerimientos de hardware, en cuanto a capacidad de procesamiento y de
 memoria RAM y de almacenamiento.
 Otra desventaja es que del sistema de virtualización depende del sistema
 operativo anfitrión.
 Es decir, el anfitrión es el punto débil del sistema ya que se comparte
 por todos los sistemas virtualizados, si se rompe éste, se rompen todas
 las máquinas virtuales.
\end_layout

\begin_layout Subsection
Tipos de virtualización
\end_layout

\begin_layout Subsubsection
Virtualización completa 
\end_layout

\begin_layout Standard
Consiste en la virtualización de paquetes y herramientas para correr de
 forma totalmente virtualizada, sin modificaciones, sistemas operativos
 huéspedes.
 Este modo cuenta con la ventaja de consolidar sistemas viejos en hardware
 nuevo, más eficiente y reducir el espacio físico y costos de operación
 relativos al consumo energético y refrigeración de estos sistemas menos
 eficientes.
 La virtualización completa ofrece, sin embargo, menor rendimiento de entrada/sa
lida que instalaciones nativas (también llamadas “bare-metal” o “metal-pelado”)
 de sistemas operativos.
 Por ejemplo el software KVM, Xen, VMware Workstation o VirtualBox hacen
 uso de esta técnica.
 Cabe destacar que en el caso de KVM se requiere soporte de hardware para
 ejecutar la virtualización, ya sea con procesadores Intel o AMD.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_tipos_3.png
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de virtualización completa
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Para-virtualización 
\end_layout

\begin_layout Standard
Para-virtualización es un técnica de virtualización la cual implica ejecutar
 versiones modificadas de los sistemas operativos.
 El sistema operativo para-virtualizado es modificado para que se de cuenta
 que está siendo virtualizado, ofreciendo un habilidad aumentada para la
 optimización, ya que el huésped está al tanto de su entorno.
 El rendimiento está generalmente muy cerca de la ejecución nativa de sistemas
 operativos no virtualizados.
 Por ejemplo, utilizan esta técnica KVM, XEN y VMware Server ESX.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_tipos_1.png
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de para-virtualización
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Para-virtualización de drivers
\end_layout

\begin_layout Standard
La para-virtualización y la virtualización completa pueden ser combinadas
 para permitir a sistemas operativos no modificados recibir un rendimiento
 cercano de entrada/salida al de ejecución nativa, por medio de drivers
 para-virtualizados en sistemas operativos completamente virtualizados.
\end_layout

\begin_layout Subsubsection
Virtualización a nivel del sistema operativo 
\end_layout

\begin_layout Standard
También llamada virtualización basada en contenedores, esta técnica virtualiza
 un servidor físico a nivel del sistema operativo, permitiendo que múltiples
 servidores virtuales aislados y seguros se ejecuten sobre un solo servidor
 físico.
 Con la virtualización basada en contenedores, no existe la sobrecarga asociada
 con tener a cada huésped ejecutando un sistema operativo completamente
 instalado.
 Este enfoque también puede mejorar el rendimiento porque hay un solo sistema
 operativo encargándose de los avisos de hardware.
 Una desventaja de la virtualización basada en contenedores, sin embargo,
 es que cada invitado debe utilizar el mismo sistema operativo que utiliza
 el host.
 Por ejemplo, Jaulas con Warden en FreeBSD, OpenVZ o Linux-Vserver usan
 esta técnica.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_tipos_2.png
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de virtualización a nivel de SO
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Emulación 
\end_layout

\begin_layout Standard
Un emulador es hardware o software que permite a un sistema de computación
 comportarse como otro sistema.
 Generalmente, un emulador permite a un sistema correr software o utilizar
 dispositivos periféricos diseñados para el otro sistema.
 Por ejemplo Qemu es un emulador muy usual en ingeniería.
 
\end_layout

\begin_layout Subsection
Herramientas de virtualización 
\end_layout

\begin_layout Standard
Algunas de las herramientas más utilizadas para virtualizar son las siguientes,
 sin embargo como uno de los requisitos es utilizar herramientas de código
 abierto, no se indagó acerca de VMWare: 
\end_layout

\begin_layout Itemize
Docker
\end_layout

\begin_layout Itemize
KVM/Qemu 
\end_layout

\begin_layout Itemize
OpenVZ
\end_layout

\begin_layout Itemize
VirtualBox 
\end_layout

\begin_layout Itemize
VMWare Workstation 
\end_layout

\begin_layout Subsubsection
Docker
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_docker_2.jpg
	lyxscale 50
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Docker logo
\end_layout

\end_inset


\end_layout

\end_inset

Docker es otra herramienta de virtualización para Linux basada en contenedores.
 La idea detrás de Docker es crear contenedores ligeros y portables para
 las aplicaciones de software que puedan ejecutarse en cualquier máquina
 con Docker instalado, independientemente del sistema operativo que la máquina
 tenga por debajo, facilitando así también los despliegues.
\end_layout

\begin_layout Standard
El contenedor Docker se puede desplegar en cualquier otro sistema (que soporte
 esta tecnología), con lo que se ahorra el tener que instalar en este nuevo
 entorno todas aquellas aplicaciones que normalmente se utilicen.
\end_layout

\begin_layout Standard
Un contenedor Docker no contiene todo un sistema completo, sino únicamente
 aquellas librerías, archivos y configuraciones necesarias para desplegar
 las funcionalidades que contenga.
 Asimismo Docker se encarga de la gestión del contenedor y de las aplicaciones
 que contenga.
\end_layout

\begin_layout Standard
Para obtener esta fluidez Docker extiende LXC (LinuX Containers), un sistema
 de virtualización ligero que permite crear múltiples sistemas totalmente
 aislados entre si sobre la misma máquina o sistema anfitrión.
 Y todo dado que no se emula un sistema operativo completo, sólo las librerías
 y sistemas de archivos necesarios para la utilización de las aplicaciones
 que se tengan instaladas en cada contenedor.
\end_layout

\begin_layout Standard
En las últimas versiones de Docker se ha introducido drivers de Docker y
 una librería llamada libcontainer, que ayuda a que Docker sea totalmente
 multiplataforma, teniendo compatibilidad con Windows y Mac OS X, además
 de Linux.
\end_layout

\begin_layout Subsubsection
KVM/Qemu 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_kvm.png
	height 3cm

\end_inset


\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_qemu.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
KVM/Qemu logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
KVM (Kernel-based Virtual Machine), desarrollado por Red Hat Enterprise
 Linux, es una infraestructura de virtualización completa para el kernel
 de Linux que lo transforma en un hypervisor.
 Fue incorporado a la línea principal del kernel Linux en la versión 2.6.20.
 KVM requiere un procesador con hardware que permita extensión para virtualizaci
ón (Intel VT o AMD-V).
 También está disponible para instalarlo desde los “ports” de FreeBSD en
 la forma de módulos de kernel.
 
\end_layout

\begin_layout Standard
La para-virtualización tiene soporte para ciertos dispositivos en Linux,
 OpenBSD, FreeBSD y Windows (entre otros) utilizando la API VirtIO.
 Se tiene placa Ethernet, un controlador de entrada/salida de disco paravirtual,
 gráficos VGA.
 
\end_layout

\begin_layout Standard
Qemu puede utilizarse como emulador y como virtualizador.
 Cuando se utiliza como virtualizador, Qemu toma un rendimiento cercano
 al nativo.
 Para ello, debe ejecutarse bajo el hypervisor Xen o KVM.
 En conjunto KVM/Qemu, KVM es quien hace las veces de árbitro del acceso
 al CPU y memoria, y Qemu emula los recursos de hardware.
 
\end_layout

\begin_layout Subsubsection
OpenVZ 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_openvz.png
	lyxscale 50
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
OpenVZ logo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
OpenVZ es una herramienta de virtualización para Linux basada en contenedores.
 OpenVZ crea múltiples contenedores aislados en un servidor físico y asegurando
 que las aplicaciones no entren en conflicto.
 Utiliza un kernel de Linux modificado y por consiguiente sólo puede correr
 Linux.
 Todos los contenedores comparten la misma arquitectura y versión del kernel.
 Cada contenedor se comporta como un servidor autónomo.
 Ya que OpenVZ emplea un modelo de kernel único, es tan escalable como kernel
 Linux 2.6, lo que significa que soporta hasta 64 CPUs y hasta 64 GiB de
 RAM.
 Un entorno virtual único se puede escalar hasta el equipo físico entero.
 También cuenta con migración en vivo que posibilita mover un contenedor
 de in servidor físico a otro sin apagar el contenedor.
 Un propietario (root) de un servidor físico OpenVZ (conocido como Nodo
 de Hardware) puede ver todos los procesos y archivos de los contenedores.
 Esto hace la administración masiva de escenarios posible: se puede ejecutar
 un simple script de intérprete de comandos que actualice todos (o sólo
 algunos seleccionados) los contenedores a la vez.
\end_layout

\begin_layout Subsubsection
VirtualBox
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_virtualbox.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
VirtualBox logo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
VirtualBox, desarrollado por Oracle, es un virtualizador completo de propósito
 general para hardware x86, orientado al uso para servidor, escritorio y
 embebido.
 Como software de código abierto, se puede utilizar bajo la licencia GNU
 General Public License 2 (GPL2) .
 
\end_layout

\begin_layout Standard
AL día de la fecha, VirtualBox corre en Windows, Linux, Macintosh y Solaris
 y soporta una amplia variedad de sistemas operativos, entre ellos RHEL(7,6,5,4)
, Windows (NT 4.0, 2000, XP, Server 2003, Vista, Windows 7, Windows 8, Windows
 10), DOS/Windows 3.x, Linux (2.4, 2.6, 3.x and 4.x), Solaris y OpenSolaris,
 OS/2, y OpenBSD.
 
\end_layout

\begin_layout Section
Aprovisionamiento 
\end_layout

\begin_layout Standard
En general, aprovisionamiento, significa proveer o hacer que algo esté disponibl
e.
 El término es utilizado en un gran variedad de contextos en el área de
 Tecnologías de Información.
 En este Proyecto Integrador, el término hace referencia a lo siguiente:
 Aprovisionamiento es el conjunto de acciones para preparar una máquina
 virtual, con el sistema apropiado, datos y software, y dejarla lista para
 su operación.
 
\end_layout

\begin_layout Itemize
Tareas típicas que se tienen que llevar a cabo para que esto suceda son:
 
\end_layout

\begin_layout Itemize
Seleccionar el conjunto de hardware virtualizado (memoria RAM, disco, cantidad
 de procesadores asignados, placa de red, etc) para crear una máquina virtual
 bare-metal.
\end_layout

\begin_layout Itemize
Cargar el sistema operativo adecuado.
\end_layout

\begin_layout Itemize
Configurar el sistema (dirección IP, gateway, DNS, hostname, MAC, etc).
\end_layout

\begin_layout Itemize
Actualizar el sistema y aplicar parches.
\end_layout

\begin_layout Itemize
Cargar el conjunto de aplicaciones necesarias.
\end_layout

\begin_layout Itemize
Configurar el sistema para adaptarlo a las políticas definidas de la institución.
\end_layout

\begin_layout Standard
En resumen, el aprovisionamiento de máquinas virtuales se realiza basado
 en los recursos disponibles y en los requisitos específicos de cada máquina
 virtual, según sea la funcionalidad que se le vaya a dar.
\end_layout

\begin_layout Subsection
Herramientas de aprovisionamiento 
\end_layout

\begin_layout Standard
Algunas de las herramientas de código abierto más utilizadas para aprovisionar
 son las siguientes: 
\end_layout

\begin_layout Itemize
Cobbler
\end_layout

\begin_layout Itemize
FAI
\end_layout

\begin_layout Itemize
Foreman
\end_layout

\begin_layout Itemize
Vagrant 
\end_layout

\begin_layout Subsubsection
Cobbler 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_cobbler.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cobbler logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cobbler es un servidor Linux de aprovisionamiento que centraliza y simplifica
 el control de los servicios incluyendo DHCP, TFTP y DNS con el propósito
 de realizar instalaciones de sistemas operativos basadas en la red.
 Puede ser configurado para PXE, reinstalaciónes y huéspedes virtualizados
 utilizando Xen, KVM o VMWare como también dispositivos físicos.
 Está dirigido especialmente a Red Hat Linux y sus derivados, pero es posible
 configurarlo para que inicie con PXE otras distribuciones de Linux como
 Debian, Ubuntu o Knoppix.
 Es una herramienta que se encuentra en creciente desarrollo y cada vez
 añade más soporte a distintas distros e incluso a FreeBSD y a futuro Windows.
 Actualmente cuenta con poco soporte para el sistema operativo de Microsoft.
 
\end_layout

\begin_layout Standard
Cuenta con un sistema integrado para administración de configuración pero
 también cuenta con soporte para la integrar la herramienta de administración
 de configuración Puppet.
 Cobbler se basa en el mecanismo de Kickstart y ofrece perfiles de instalación
 que pueden ser aplicados a una o muchas máquinas.
 La información de contenida en un plantilla kickstart puede ser modificada
 dinámicamente pasando variables (llamadas ksmeta) o utilizando snippets,
 donde se puede mantener el código común simplificando la lectura y minimizando
 el tamaño del archivo kickstart.
\end_layout

\begin_layout Subsubsection
Fully Automatic Installation (FAI)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_fai.png
	lyxscale 75
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
FAI logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
FAI es un sistema no interactivo para instalar, personalizar y administrar
 sistemas Linux y configuraciones de software en computadoras como también
 en máquinas virtuales y entornos chroot, desde pequeñas redes hasta una
 infraestructura grande escalable y clusters.
 Es una herramienta para la instalación totalmente automática de Debian
 y otras distros de Linux como Suse, Red Hat, Solaris, vía red, DVDs personaliza
dos de instalación o en entornos chroot.
 
\end_layout

\begin_layout Standard
Algunas de las características más importantes:
\end_layout

\begin_layout Itemize
Instalar y actualizar Debian, Ubuntu, SUSE, Red Hat, etc.
\end_layout

\begin_layout Itemize
Despliegue centralizado y administración de configuración.
\end_layout

\begin_layout Itemize
Recuperación de desastre integrado.
\end_layout

\begin_layout Itemize
Fácil configuración de software RAID y LVM.
\end_layout

\begin_layout Itemize
Instalar máquinas virtuales usando KVM, Xen y VirtualBox.
\end_layout

\begin_layout Itemize
Control remoto vía SSH durante la instalación.
\end_layout

\begin_layout Subsubsection
Foreman 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_foreman.png
	lyxscale 60
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Foreman logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Foreman es una herramienta para el aprovisionamiento, configuración y monitoriza
ción de servidores físicos y virtuales.
 Puede aprovisionar máquinas bare-metal, virtualizadas y en la nube a través
 de instalaciones desatendidas por medio de DHCP, DNS, TFTP y PXE .
 Tiene una gran integración con software de administración de configuración
 como Puppet, Chef, Salt y otros por medio de plugins.
\end_layout

\begin_layout Standard
Algunas de sus características son:
\end_layout

\begin_layout Itemize
Descubrir, aprovisionar y actualizar toda la infraestructura bare-metal.
\end_layout

\begin_layout Itemize
Crear y gestionar instancias entre nubes privadas y públicas.
 
\end_layout

\begin_layout Itemize
Agrupar hosts y dirigirlos en conjunto, sin importar la ubicación.
 
\end_layout

\begin_layout Itemize
Rever cambios históricos para auditoría y resolución de problemas.
\end_layout

\begin_layout Subsubsection
Vagrant
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_vagrant.png
	lyxscale 15
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Vagrant logo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vagrant provee entornos fáciles de reproducir, configurar construidos sobre
 tecnología industrial estándar.
 Vagrant es un software que crea y configura entornos de desarrollo virtuales
 aprovisionando sobre VirtualBox, VMware, KVM y contenedores Linux.
 Es una software que se encuentra una capa encima de estas herramientas.
 Luego herramientas de administración de configuración como Ansible, Chef,
 Salt, y Puppet pueden ser utilizadas para instalar y configurar automáticamente
 el software en la máquina.
\end_layout

\begin_layout Section
Orquestación
\end_layout

\begin_layout Standard
La orquestación describe el alineamiento automatizado, la coordinación y
 la administración de complejos sistemas de computadoras, middleware y servicios.
 En este sentido, la orquestación se trata de alinear los requisitos de
 negocio con las aplicaciones, datos e infraestructura.
 Define las políticas y niveles de servicio a través de flujos de trabajo
 automatizados, aprovisionamiento y gestión de cambio.
 Esto crea una infraestructura alineada con la aplicación que puede ser
 escalada hacia arriba o abajo basándose en las necesidades de cada aplicación.
\end_layout

\begin_layout Standard
La orquestación también provee la gestión centralizada de los recursos.
 Por ejemplo, reduce el tiempo y esfuerzo para desplegar múltiples instancias
 de una sola aplicación.
 Cuando es necesario que se creen más instancias de diferentes aplicaciones,
 herramientas automatizadas pueden realizar tareas que, previamente, podían
 ser llevadas a cabo sólo por múltiples administradores.
\end_layout

\begin_layout Standard
Un escenario que se puede encontrar, por ejemplo, un administrador necesita
 desplegar una aplicación web, pero para hacerlo, primero debe crear el
 servidor de base de datos.
 Luego debe incluir en la base de datos todas las direcciones IP que pueden
 conectarse al servidor, y también agregar este nuevo servidor a la herramienta
 que lo monitorea, o abrir un puerto particular antes de proceder.
 Cada tarea expuesta puede ser automatizada, pero el conjunto de estas automatiz
aciones, junto con la coordinación secuencial de las mismas, realizada sin
 tener en cuenta el tipo de sistema operativo en el que corren, describen
 un proceso, en el cual actúa la orquestación.
\end_layout

\begin_layout Standard
No hay que confundir los términos automatización y orquestación.
 Éstos se podrían comparar con tarea y proceso.
 
\end_layout

\begin_layout Standard
La optimización de un proceso, por ejemplo, no se puede conseguir simplemente
 por la automatización.
 A la automatización le concierne una tarea: ejecutar un servidor web, configura
r un servidor web, detener un servicio.
 A la orquestación, sin embargo, le concierne la ejecución de un flujo de
 trabajo (si se quiere automatizado) de un proceso.
 Un proceso de aprovisionamiento lleva a cabo múltiples tareas e involucrar
 múltiples sistemas.
 El objetivo de la orquestación no es sólo ejecutar automáticamente un servidor,
 lo cual aumenta la velocidad en el proceso de despliegue y lleva las aplicacion
es a producción más rápido.
 También permite una oportunidad para optimizar aquellos procesos para mejorar
 aún más la velocidad de despliegue.
\end_layout

\begin_layout Standard
Una de las maneras más simples de optimizar un proceso es eliminar los pasos
 repetitivos.
\end_layout

\begin_layout Standard
Entonces, automatización trata acerca de codificar tareas y orquestación
 acerca de codificar procesos.
 Esta última toma ventaja de la automatización para reutilizar bloques básicos.
\end_layout

\begin_layout Subsection
Herramientas de orquestación
\end_layout

\begin_layout Standard
Algunas de las herramientas de código abierto más utilizadas para orquestar
 son las siguientes: 
\end_layout

\begin_layout Itemize
Ansible
\end_layout

\begin_layout Itemize
Chef 
\end_layout

\begin_layout Itemize
Puppet 
\end_layout

\begin_layout Subsubsection
Ansible 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/orquestacion/orquestacion_ansible.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ansible logo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es una plataforma para configurar y administrar computadoras.
 Combina instalación multi-nodo, ejecuciones de tareas ad hoc y administración
 de configuraciones.
 
\end_layout

\begin_layout Standard
Ansible distingue dos tipos: controladores y nodos.
 Primero, existe una única máquina de control donde la orquestación comienza.
 Los nodos son manejados desde esa máquina por el servicio OpenSSH.
 La máquina de control conoce a los nodos a través de un inventario.
 Esta herramienta usa una arquitectura sin agentes, es decir, los nodos
 no necesitan instalar ni ejecutar en segundo plano ningún proceso que se
 comunique con la máquina de control.
 Sin embargo, los nodos deben contar con Python >= 2.4 y las máquinas de
 control con Python 2.6.
\end_layout

\begin_layout Standard
Dispone de módulos que trabajan sobre JSON y la salida estándar puede ser
 escrita en cualquier lenguaje.
 Nativamente utiliza YAML para describir configuraciones de los sistemas.
\end_layout

\begin_layout Standard
Los sistemas operativos soportados en las máquinas de control son la mayoría
 de las distribuciones Linux y Unix (Red Hat, Debian, CentOS, OSX, y BSD)
 entre otros excepto Windows.
\end_layout

\begin_layout Standard
Ansible puede instalarse en ambientes virtualizados, nubes públicas y privadas,
 incluyendo VMWare, OpenStack, AWS, Eucalyptus, KVM y CloudStack.
\end_layout

\begin_layout Subsubsection
Chef 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/orquestacion/orquestacion_chef.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Chef logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es una herramienta de automatización de infraestructura de sistemas o administra
ción de configuraciones.
 Se enfoca en seguir un conjunto de pasos (llamados recetas) con el propósito
 de presentar un producto final ya listo para trabajar y/o probar.
\end_layout

\begin_layout Standard
Existen 2 tipos de versiones: 
\end_layout

\begin_layout Standard

\series bold
Chef Server
\series default
 está enfocado a ser el servidor central que permite suministrar a los diferente
s nodos clientes con las diversas configuraciones necesarias, las cuales
 se mantienen alojadas en el servidor.
 El cliente sondea periódicamente al Chef Server para corroborar las últimas
 políticas y estado de la red, en caso que haya algún parámetro desactualizado,
 el cliente lo actualiza.
 Además ofrece balanceo de carga, escalabilidad, búsquedas rápidas ente
 otros.
\end_layout

\begin_layout Standard

\series bold
Chef Solo
\series default
 es la versión de código abierto y reside localmente en el nodo, esto quiere
 decir que toda la información y recetas necesarias para configurar el nodo
 deben estar presentes en su disco duro.
 Esta herramienta utiliza Ruby-DLS para escribir las “recetas” (configuraciones
 de sistemas que describen como son manejadas las aplicaciones).
 Estas recetas, que pueden ser agrupadas para facilitar la administración,
 describen de forma secuencial una serie de recursos que deben estar en
 un estado particular.
\end_layout

\begin_layout Standard
Chef Server es soportado sobre RHEL/CentOS/Oracle Linux, y Ubuntu.
 Mientras que el soporte para los clients es AIX, RHEL/CentOS, FreeBSD,
 Mac OS X, Solaris (OS), Microsoft Windows, Ubuntu, ArchLinux, Debian, Fedora,
 y otros.
 
\end_layout

\begin_layout Subsubsection
Puppet 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/orquestacion/orquestacion_puppet.png
	lyxscale 75
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Puppet logo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es un sistema de orquestación que permite definir el estado de la infraestructur
a, forzando automáticamente que se llegue al estado correcto definido.
\end_layout

\begin_layout Standard
Puppet es una herramienta diseñada para administrar la configuración de
 sistemas similares a Unix y a Microsoft Windows de forma declarativa, es
 decir, se establece el estado requerido en vez como llegar al mismo..
 El usuario describe los recursos del sistema y sus estados utilizando el
 lenguaje declarativo que proporciona Puppet.
 Esta información es almacenada en archivos denominados “manifiestos”.
 Puppet descubre la información del sistema a través de una utilidad llamada
 Facter, y compila los manifiestos en un catálogo específico del sistema
 que contiene los recursos y la dependencia de dichos recursos, estos catálogos
 son ejecutados en los sistemas de destino.
 La capa de abstracción de recursos permite a los administradores describir
 la configuración en términos de alto nivel, tales como usuarios, servicios
 y paquetes sin necesidad de especificar los comandos específicos del sistema
 operativo (como rpm, yum, apt).
\end_layout

\begin_layout Standard
Puppet funciona bajo la arquitectura cliente servidor donde un puppet master
 indica a sus agentes las configuraciones que deben aplicar.
 Además, los masters pueden aplicar manifiestos a sí mismos.
 Notar que hay dos etapas: 
\end_layout

\begin_layout Enumerate
Compilar los catálogos 
\end_layout

\begin_layout Enumerate
Aplicar los catálogos
\end_layout

\begin_layout Standard
Un catálogo es un archivo que describe los deseos de un estado de sistema
 para un nodo en particular.
 Enumera todos los recursos que necesitan ser administrados, así como las
 dependencias entre esos recursos.
\end_layout

\begin_layout Standard
En esta arquitectura, los nodos administrados corren la aplicación puppet-agent,
 usualmente en segundo plano y uno o más servidores corren la aplicación
 puppetmaster administrada por un servidor web (como Apache.) Periódicamente,
 los agentes piden al master el catálogo.
 El master, compila y corre el catálogo del nodo usando varias fuentes de
 información a las que tiene acceso.
 Una vez que recibe el catálogo, el agente chequea cada recurso descrito
 en él.
 Si encuentra algún recurso que no está en el estado deseado, se realizan
 los cambios necesarios para corregirlos.
 Luego de aplicar el catálogo, el agente enviá un reporte al master.
\end_layout

\begin_layout Standard
Los sistemas soportados son Linux (Red Hat Enterprise y derivados, Debian,
 Ubuntu, Fedora), Unix (BSD, Mac OS X, Oracle Solaris, AIX) y Windows.
\end_layout

\begin_layout Section
Protocolo PXE
\end_layout

\begin_layout Standard
El protocolo PXE (Preboot Execution Enviroment) es un estándar que les permite
 a computadoras, dentro de una red, que todavía no fueron cargadas con un
 sistema operativo, ser configuradas e iniciadas remotamente por un administrado
r.
 Utiliza una extensión de opciones del protocolo DHCP.
\end_layout

\begin_layout Standard
Las ventajas de utilizar PXE incluyen:
\end_layout

\begin_layout Itemize
La máquina cliente no necesariamente necesita un sistema operativo o un
 disco rígido.
 
\end_layout

\begin_layout Itemize
Como este protocolo es independiente del vendedor nuevos tipos de computadoras
 pueden ser añadidos a la red.
\end_layout

\begin_layout Subsubsection
PXE APIs
\end_layout

\begin_layout Standard

\series bold
Preboot Services API:
\series default
 Contiene muchas funciones de control e información.
\end_layout

\begin_layout Standard

\series bold
Trivial File Transport Protocol (TFTP) API:
\series default
 Habilita la apertura y cierre de conexiones TFPT, la lectura desde una
 conexión TFTP y la escritura en otra.
\end_layout

\begin_layout Standard

\series bold
User Datagram Protocol (UDP) API:
\series default
 Habilita la apertura y cierre de conexiones TFPT, la lectura desde una
 conexión UDP y la escritura en otra.
\end_layout

\begin_layout Standard

\series bold
Universal Network Driver Interface (UNDI) API:
\series default
 Habilita el control básico de entrada/salida a través de la interfaz de
 red del cliente.
 Esto permite la utilización de protocolos universales de controladores
 para que el mismo controlador pueda ser usado en cualquier interfaz que
 soporte esta API.
\end_layout

\begin_layout Standard
El siguiente diagrama ilustra la relación entre los NBP y las APIs de PXE:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/pxe/pxe_api_1.png
	lyxscale 50
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
APIs de PXE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Funcionamiento de PXE
\end_layout

\begin_layout Enumerate
El cliente realiza un broadcast de un mensaje DHCPDISCOVER al puerto estándar
 DHCP (UDP 67).
 Un campo de opciones en este mensaje contiene:
\end_layout

\begin_deeper
\begin_layout Enumerate
Etiqueta para el identificador del cliente UUID.
\end_layout

\begin_layout Enumerate
Etiqueta para la versión de UNDI (Universal Network Device Interface) del
 cliente.
\end_layout

\begin_layout Enumerate
Etiqueta para la arquitectura del cliente.
\end_layout

\begin_layout Enumerate
La opción 60, Class ID, puesta a to “PXEClient:Arch:xxxxx:UNDI:yyyzzz”.
\end_layout

\end_deeper
\begin_layout Enumerate
El servidor DHCP responde enviando un mensaje DHCPOFFER al cliente en el
 puerto estándar DHCP (UDP 68).
 El mensaje contiene parámetros estándar DHCP:
\end_layout

\begin_deeper
\begin_layout Enumerate
Una dirección IP para el cliente.
\end_layout

\begin_layout Enumerate
Parámetros configurados por el administrador.
\end_layout

\end_deeper
\begin_layout Enumerate
Del DHCPOFFER que es recibido, el cliente guarda:
\end_layout

\begin_deeper
\begin_layout Enumerate
La dirección IP.
\end_layout

\begin_layout Enumerate
Parámetros configurados por el administrador.
\end_layout

\begin_layout Enumerate
Una lista de Boot Servers del campo “Boot Server” en las etiquetas PXE del
 DHCPOFFER.
\end_layout

\end_deeper
\begin_layout Enumerate
El cliente debe enviar una solicitud por la dirección del Boot Server al
 servidor y esperar por el acuse de recibo (acknowledgment – ACK).
\end_layout

\begin_layout Enumerate
El cliente selecciona y descubre un Boot Server.
 Este paquete puede ser enviado por broadcast al puerto 67.
 Este paquete es el mismo que el DHCPDISCOVER inicial en el paso uno,excepto
 que es codificado como DHCPREQUEST y ahora contiene lo siguiente:
\end_layout

\begin_deeper
\begin_layout Enumerate
La IP asignada al cliente por el servidor DHCP.
\end_layout

\begin_layout Enumerate
Una etiqueta con el identificador del cliente (UUID).
\end_layout

\begin_layout Enumerate
Una etiqueta con la versión de UNDI del cliente.
\end_layout

\begin_layout Enumerate
Una etiqueta con la arquitectura del cliente.
\end_layout

\begin_layout Enumerate
La opción 60, Class ID, puesta a to “PXEClient:Arch:xxxxx:UNDI:yyyzzz”.
\end_layout

\begin_layout Enumerate
El tipo de Boot Server en el campo de opciones de PXE.
\end_layout

\end_deeper
\begin_layout Enumerate
El Boot Server envía un paquete DHCPACK unicast al cliente.
 Este ACK contiene:
\end_layout

\begin_deeper
\begin_layout Enumerate
El nombre del archivo ejecutable.
\end_layout

\begin_layout Enumerate
Parámetros de configuración MTFTP.
\end_layout

\begin_layout Enumerate
Otras opciones necesarias para que el NBP pueda ser ejecutado.
\end_layout

\end_deeper
\begin_layout Enumerate
El cliente descarga el archivo ejecutable utilizando TFTP (puerto 69).
 El archivo descargado y la ubicación del código descargado en memoria depende
 de la arquitectura de la CPU del cliente.
\end_layout

\begin_layout Enumerate
El cliente PXE determina si es necesaria la verificación de autenticidad
 del archivo descargado.
 Si se requiere se envía otro DHCPREQUEST preguntando por credenciales.
\end_layout

\begin_layout Enumerate
El cliente inicia la ejecución del código descargado.
\end_layout

\begin_layout Standard
El cliente PXE esperará por la información necesaria unos 60 segundos.
 La etapa DHCPDISCOVER puede repetirse hasta cuatro veces, con tiempos de
 espera de 4,8,16 y 32 segundos respectivamente.
 Si el cliente recibe la DHCPOFFER dentro de ese tiempo, se procederá con
 DHCPREQUEST.
 Si no, se detendrá con un error de PXE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/pxe/pxe_proceso.png
	lyxscale 50
	width 15.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proceso de PXE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
SAMBA
\end_layout

\begin_layout Standard
SAMBA es un servidor SMB (Server Message Block) libre, desarrollado por
 Andrew Tridgell y que en la actualidad es mantenido por un grupo de personas
 de todo el mundo, como casi todos los proyectos distribuidos bajo la Licencia
 Publica General de GNU.
 SAMBA es capaz de ejecutarse en una gran cantidad de variantes Unix, como
 Linux, Solaris, SunOS, HP-UX, ULTRIX, Unix de Digital, SCO Open Server
 y AIX por nombrar tan sólo algunas.
 Con SAMBA podremos hacer que nuestro sistema Linux actúe como servidor
 SMB dentro de la red.
\end_layout

\begin_layout Standard
SAMBA es en sí un paquete muy complejo, que brinda a los usuarios Linux
 de un sin fin de posibilidades a la hora de interactuar con equipos Windows
 y Linux que estén coexistiendo en redes heterogéneas.
\end_layout

\begin_layout Standard
Los beneficios al instalar un servidor SAMBA en Linux son los siguientes:
\end_layout

\begin_layout Itemize
Compartir uno o más sistemas de archivos.
 
\end_layout

\begin_layout Itemize
Compartir impresoras, instaladas tanto en el servidor como en los clientes.
 
\end_layout

\begin_layout Itemize
SAMBA permite compartir entre máquinas Windows y Linux recursos.
 
\end_layout

\begin_layout Itemize
Siendo un recurso una carpeta o la impresora.
\end_layout

\begin_layout Subsection
Arquitectura SAMBA
\end_layout

\begin_layout Standard
SAMBA está compuesta de un servidor y un cliente, así como de algunas herramient
as que permiten realizar servicios prácticos o hacer un test de la configuración.
\end_layout

\begin_layout Standard
El servidor está compuesto de dos aplicaciones (llamadas demonios): smbd,
 núcleo del servidor, provee los servicios de autenticación y acceso a los
 recursos.
 nmbd, permite mostrar los servicios disponibles en SAMBA (visualización
 de los servidores SAMBA en la red, etc).
\end_layout

\begin_layout Standard
El cliente: smbclient es un cliente para Linux que provee una interfaz que
 permite la transferencia de archivos, el acceso a impresoras, etc.
\end_layout

\begin_layout Standard
smbtar: permite transferir de o hacia un archivo TAR bajo Linux.
\end_layout

\begin_layout Standard
testparm: comprueba la sintaxis del archivo smb.conf, el archivo de configuración
 de SAMBA.
\end_layout

\begin_layout Standard
El protocolo de comunicación que permite esta comunicación entre Windows
 y Linux se llama SMB (Server Message Block).
 Puesto a punto por Microsoft en 1987, retomando un concepto desarrollado
 por IBM en 1985 (NetBIOS), este protocolo se apoya sobre NetBEUI (así como
 sobre TCP/IP).
 El interés de TCP/IP proviene del hecho que es ampliamente adoptado.
 Por ello TCP/IP ya ha sido implementado en la mayoría de sistemas operativos
 (Unix, Linux, AmigaOS, MacOS, OS/2, etc) según el esquema siguiente:
\end_layout

\begin_layout Itemize
Aplicación 
\end_layout

\begin_layout Itemize
SMB 
\end_layout

\begin_layout Itemize
NetBios 
\end_layout

\begin_layout Itemize
TCP/IP 
\end_layout

\begin_layout Itemize
NetBeui 
\end_layout

\begin_layout Itemize
IPX/SPX 
\end_layout

\begin_layout Itemize
Controladores de red
\end_layout

\begin_layout Part
Desarrollo
\end_layout

\begin_layout Section
Elección de la plataforma
\end_layout

\begin_layout Standard
Una vez realizada la interiorización de las diferentes herramientas utilizadas
 en el mercado, se decidió unificar la plataforma para el desarrollo del
 Proyecto Integrador.
 
\end_layout

\begin_layout Standard

\color red
El sistema operativo base elegido fue CentOS 7, su última versión al día
 de la fecha.
 Esto es debido a que junto con su versión empresarial, es un sistema operativo
 muy robusto y confiable, orientado a servidores y uno de los más utilizado
 en el mercado.
 Además, la mayoría de las herramientas de virtualización, aprovisionamiento
 y orquestación son nativas de RedHat y por ende de CentOS.
 Finalmente se tuvo en cuenta la nueva estandarización del iniciador de
 sistemas, systemd, para esta versión del sistema operativo y para gran
 parte de las futuras entregas en diferentes distribuciones Linux, orientadas
 a servidor y también de escritorio.
\end_layout

\begin_layout Standard

\color red
Como herramienta de virtualización se optó por KVM, la cual fue, como se
 menciono antes, desarrollada nativamente para esta distribución de Linux
 y que cuenta con una extensa documentación.
 A su vez, en el Laboratorio de Computación, existe un servidor que utiliza
 esta herramienta para servir a las terminales de ciertas aulas de informática.
 Consultando con los Directores del Proyecto, a profesionales en el tema
 se llegó a la conclusión que KVM es una herramienta estable y apta para
 un entorno de producción.
\end_layout

\begin_layout Standard
Para el aprovisionamiento de máquinas virtuales también por motivos de desarroll
o nativo y recomendación de profesionales que la han utilizado se eligió
 a Cobbler, ya que es la más estable y fiable para entornos de producción.
 También cuenta con soporte integrado para orquestación con Puppet, herramienta
 que fue elegida por ser parte de los requerimientos del Proyecto.
\end_layout

\begin_layout Subsection
Arquitectura de desarrollo
\end_layout

\begin_layout Standard
El siguiente esque representa la arquitectura de desarrollo utilizada para
 todas las pruebas.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/arquitectura_trabajo/arquitectura-pruebas-fin.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Arquitectura de desarrollo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sin embargo, como también se puede aplicar para máquinas de escritorio o
 un entorno mixto, con equipos virtualizados y reales, se realizaron pruebas
 como se muestra en el siguiente esquema.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/arquitectura_trabajo/arquitectura-trabajo-fin.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Arquitectura de desarrollo en un entorno mixto.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
KVM/Qemu
\end_layout

\begin_layout Subsection
Arquitectura
\end_layout

\begin_layout Standard
En este Proyecto se utiliza la técnica de virtualización completa.
 En particular, la arquitectura que utiliza KVM es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/kvm/kvm_arquitectura_1.png
	lyxscale 50
	width 15.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de arquitectura de KVM/Qemu
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\color red
Requerimientos de hardware
\end_layout

\begin_layout Standard
El hipervisor KVM requiere que el microprocesador cuente con VT-x para procesado
res de Intel o con AMD -V para los propios de AMD.
 Para poder confirmar que un un procesador cuenta con esto, en los sistemas
 basados en Linux, se debe ejecutar el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
grep -E 'svm|vmx' /proc/cpuinfo 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La salida de este comando es una porción del archivo /proc/cpuinfo en el
 cual se detallan las diferentes flags que contiene el procesador, entre
 ellas, la svm (AMD) o vmx (Intel).
 En caso de no poseer esas flags, el procesador no soporta hiper-virtualización
 y la salida será vacía.
\end_layout

\begin_layout Standard
La siguiente, es la salida obtenida con un AMD Athlon(tm) II P360 Dual-Core
 Processor de 1,7GHz:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat
 pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp
 lm 3dnowext 3dnow constant_tsc rep_good nopl nonstop_tsc extd_apicid pni
 monitor cx16 popcnt lahf_lm cmp_legacy 
\color red
svm
\color inherit
 extapic cr8_legacy abm sse4a 3dnowprefetch osvw ibs skinit wdt nodeid_msr
 hw_pstate npt lbrv svm_lock nrip_save 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Se debe asegurar que el módulo de KVM este cargado, para esto ejecutamos
 :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
lsmod | grep kvm 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La salida obtenida, nuevamente en la misma máquina que en el caso anterior
 es:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
kvm_amd 60554 0 kvm 448375 1 kvm_amd 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En caso de no estar cargados los módulos, se deben cargar manualmente, de
 la siguiente manera.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
modprobe kvm_amd
\end_layout

\begin_layout Subsection

\color red
Limitaciones de KVM
\end_layout

\begin_layout Itemize
El número máximo de CPUs por huésped es elevado (240 para RHE 7.1) por lo
 que no aplica en este trabajo.
 
\end_layout

\begin_layout Itemize
La virtualización anidada no está soportada.
 
\end_layout

\begin_layout Itemize
Sobre utilización de memoria es soportada por KVM utilizando el disco de
 swap.
 
\end_layout

\begin_layout Itemize
Sobre utilización de CPUs es soportada por KVM, se recomienda no utilizar
 más de diez CPUs virtuales por cada CPU físico.
\end_layout

\begin_layout Itemize
Virtualización de dispositivos SCSI no está soportada.
 Virtualización de dispositivos IDE en KVM es limitada a cuatro por huésped.
 
\end_layout

\begin_layout Itemize
Soporta 32 slots para dispositivos PCI (para-virtualizados) y 8 de estos
 por cada slot (datos RHE7) 
\end_layout

\begin_layout Itemize
La asignación de dispositivos referenciados a dispositivos físicos son de
 uso exclusivo a la VM .
\end_layout

\begin_layout Itemize
La migración y salvado, o restauración de la VM no está soportada mientras
 el dispositivo esté en uso.
 
\end_layout

\begin_layout Itemize
KVM no soporta kernels de real time.
 
\end_layout

\begin_layout Subsection
Configuración de la red
\end_layout

\begin_layout Standard
KVM soporta las siguientes configuraciones de red para la virtualización:
\end_layout

\begin_layout Itemize
Redes virtuales usando NAT (Network Address Translation) 
\end_layout

\begin_layout Itemize
Dispositivos físicos distribuidos usando la asignación de dispositivos PCI
\end_layout

\begin_layout Itemize
Redes puenteadas (bridge)
\end_layout

\begin_layout Subsection

\color red
Creación del sistema de virtualización qemu-KVM
\end_layout

\begin_layout Subsubsection

\color red
Instalación de paquetes
\end_layout

\begin_layout Standard

\color red
Se ejecutan los siguientes comandos, el primero actualiza los paquetes actuales
 del sistema a la ultima versión, mientras que el segundo instala los paquetes
 seleccionados, estos paquetes entre otras cosas proveen la herramienta
 qemu-KVM, una interfaz gráfica como es el virt-manager para administrar
 y crear las maquinas virtuales, y un conjunto de comandos donde se destaca
 el comando virt-install que es el utilizado para crear las maquina virtuales.
\end_layout

\begin_layout Standard

\family typewriter
\color red
yum update 
\end_layout

\begin_layout Standard

\family typewriter
\color red
yum install -y kvm libvirt qemu-kvm virt-manager libvirt qemu-system-x86
 qemu-img libvirt-python libvirt-client virt-install virt-viewer
\end_layout

\begin_layout Standard

\color red
Se añade el usuario que va a utilizar KVM al grupo KVM, en este caso el
 usuario es admin.
\end_layout

\begin_layout Standard

\family typewriter
\color red
usrermod -G kvm -a admin
\end_layout

\begin_layout Subsubsection

\color red
Creación de una red NAT
\end_layout

\begin_layout Standard

\color red
KVM soporta tres tipos de configuraciones de redes
\end_layout

\begin_layout Itemize

\color red
Redes virtuales usando NAT (Network Address Traslation)
\end_layout

\begin_layout Itemize

\color red
Dispositivos físicos distribuidos usando la asignación de dispositivos PCI
\end_layout

\begin_layout Itemize

\color red
Redes puenteadas (bridge)
\end_layout

\begin_layout Standard

\color red
Se utiliza una red virtual NAT dado que (porque carajo usamos esta red????)
\end_layout

\begin_layout Standard

\color red
Aprovechamos la interfaz gráfica del virt-manager para crear la red.
 Primero nos dirigimos a Editar>Detalles de la conexión.
 Se abre el siguiente menú.
\end_layout

\begin_layout Standard

\color red
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center

\color red
\begin_inset Graphics
	filename Imagenes/kvm/Desarrollo del sistema/QEMU-KVM Detalles de conexión_003.png
	width 15cm
	rotateOrigin center

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Detalles de conexión
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\color red
Se añade una nueva red, clickeando en el signo mas.
\end_layout

\begin_layout Standard

\color red
La ventana que se abre, cuenta con 4 etapas.
 En la primera se selecciona el nombre de la red, puppet.
 Luego indicamos la red deseada (En este proyecto se uso 192.168.122.0/24)
 y se deshabilita el DHCP dado que utilizaremos un servidor para esto.
 En la tercer etapa esta la opción de habilitar IPV6 y finalmente en la
 ultima etapa se indica que la red debe ser NAT y se elige el dispositivo
 al cual se reenvía.
\end_layout

\begin_layout Standard

\color red
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center

\color red
\begin_inset Graphics
	filename Imagenes/kvm/Desarrollo del sistema/Crear una red virtual nueva_001.png
	width 15cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Crear red virtual
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\color red
Creación de VMs
\end_layout

\begin_layout Standard

\color red
Las maquinas virtuales se pueden crear tanto siguiendo al GUI como por linea
 de comandos, este ultimo tiene la ventaja de poder ser utilizada para scripting.
 
\end_layout

\begin_layout Standard

\color red
Entre la gran cantidad opciones del comando virt-install se destacan:
\end_layout

\begin_layout Itemize

\series bold
\color red
--connct: 
\series default
Con esta opción se indica que se trabajara con el emulador qemu
\end_layout

\begin_layout Itemize

\series bold
\color red
--virt-type: 
\series default
Con esta opción se indica que la virtualización la realizara KVM
\end_layout

\begin_layout Itemize

\series bold
\color red
--name:
\series default
 Seleccionamos un nombre único para la VM.
 Este nombre no es del host sino es el nombre para identificarlo dentro
 del campo de qemu-KVM
\end_layout

\begin_layout Itemize

\series bold
\color red
--ram
\series default
 Indicamos la cantidad de memoria ram en MB que dispondrá la VM 
\end_layout

\begin_layout Itemize

\series bold
\color red
--disk: 
\series default
Ubicamos el path absoluto donde se encontrara la imagen creada e indicamos
 el tamaño en GB de la misma.
\end_layout

\begin_layout Itemize

\series bold
\color red
--network: 
\series default
Si se trabaja con una red virtual, se le indica a la VM a cual debe conectarse
\end_layout

\begin_layout Itemize

\series bold
\color red
--pxe
\series default
:
\series bold
 
\series default
Esta opción es muy importante dado que indica que el SO a instalar se obtiene
 vía red.
\end_layout

\begin_layout Itemize

\series bold
\color red
--os-type y --os-variant: 
\series default
Para aumentar el rendimiento se le indica a la VM que tipo de SO contendrá
 (Linux, Windows, etc) y la variante del mismo (Entre los Linux puede ser:
 Centos, Debian, Ubuntu, etc.)
\end_layout

\begin_layout Standard

\color red
Un ejemplo utilizado en el desarrollo del proyecto es:
\end_layout

\begin_layout Standard

\color red
virt-install --connect qemu:///system --virt-type kvm --name centos1025
 --ram 1024 --disk path=/var/lib/libvirt/images/centos1025.qcow2,size=15
 --network network=puppet --pxe --os-type linux --os-variant rhel7
\end_layout

\begin_layout Section
Cobbler
\end_layout

\begin_layout Standard

\color red
El servidor cobbler debe contener los paquetes necesarios para poder instalar
 cada SO (CentOS, Ubuntu y Windows) Por lo cual debe contar con un espacio
 en disco mínimo para soportar esto.
 Ademas, dado que el mismo servidor contiene el sistema de automatización
 y orquestación, se estima que debe contar con un mínimo de 30GB de disco.
\end_layout

\begin_layout Standard

\color red
El proyecto se desarrollo sin tener en cuenta SELinux ni Firewall, por lo
 cual ambos son deshabilitados de la siguiente forma.
\end_layout

\begin_layout Standard
Editar el archivo /
\family typewriter
etc/sysconfig/selinux
\family default
 y setear:
\end_layout

\begin_layout Standard

\family typewriter
SELINUX=disabled
\end_layout

\begin_layout Standard
En el caso del firewall ejecutar: 
\end_layout

\begin_layout Standard

\family typewriter
systemctl stop firewalld.service
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl disabled firewalld.service
\end_layout

\begin_layout Standard

\family typewriter
systemctl mask firewalld.service 
\end_layout

\begin_layout Standard

\family typewriter
systemctl status firewalld.service
\end_layout

\begin_layout Subsection
Tópicos generales de Cobbler
\end_layout

\begin_layout Subsubsection
Modelado
\end_layout

\begin_layout Standard
Cobbler utiliza objetos para definir la configuración de aprovisionamiento.
 A medida que se desciende por el árbol de objetos, las variables se sobre
 escriben y se añaden a la información definida en los objetos superiores.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/cobbler/cobbler_modelado.png
	lyxscale 50
	width 15.5cm
	height 10cm
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modelado de Cobbler
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Distros
\end_layout

\begin_layout Standard
Distribución que se desea instalar.
 Importar el contenido de la distro ayuda a disminuir el tiempo de instalación
 ya que no se utilizan fuentes de instalación externas.
 Generalmente es más fácil utilizar el comando 
\family typewriter
\emph on
import 
\family default
\emph default
en vez de añadir la distribución manualmente.
\end_layout

\begin_layout Subsubsection
Profiles
\end_layout

\begin_layout Standard
Un perfil o profile asocia una distribución a opciones especializadas adicionale
s, como puede ser un kickstart.
 Los perfiles son el núcleo del aprovisionamiento y debe existir al menos
 uno por cada distribución.
 Un perfil puede representar, por ejemplo, una configuración de web server
 o de escritorio.
\end_layout

\begin_layout Subsubsection
Systems 
\end_layout

\begin_layout Standard
Los grabaciones de sistemas mapean una pieza de hardware (o una máquina
 virtual) con el profile asignado a correr en ella.
 Esto puede verse como una forma de asignarle un rol a un sistema específico.
 Cuando se aprovisiona vía koan y PXE, no es necesario crearlos ya que son
 útiles cuando una personalización de un sistema específico es necesaria.
 Por ejemplo, personalizar la MAC, si hay un rol específico para una máquina
 dada, se debería crear una grabación del sistema para ésta.
\end_layout

\begin_layout Subsubsection
Images 
\end_layout

\begin_layout Standard
Cobbler puede bootear imágenes físicamente o virtualmente.
 Los despliegues de máquinas no basadas en imágenes son generalmente más
 fáciles para trabajar y llevan a una infraestructura más sustentable.
 La mayoría de las instalaciones de cobbler están directamente basadas en
 la distribución (kernel + initrd).
 La siguiente página documenta algunas cosas que no están basadas en kernel
 + initrd y muestra como instalarlas con cobbler y koan.
 Por ejemplo, trata la instalación de sistemas operativos Windows usando
 qemu/KVM: 
\end_layout

\begin_layout Standard

\family typewriter
https://fedorahosted.org/cobbler/wiki/AllAboutImages
\end_layout

\begin_layout Standard

\family typewriter
https://fedorahosted.org/cobbler/wiki/KoanWithIsos
\end_layout

\begin_layout Subsubsection
Repositorios 
\end_layout

\begin_layout Standard
Espejar repositorios le permite a Cobbler espejar el árbol de instalación
 (
\family typewriter
cobbler import
\family default
) y también paquetes opcionales.
 Si se espeja todo esto localmente en la red, las instalaciones y actualizacione
s serán más rápidas (usualmente es válido realizar esto para largos setups
 en datacenters, laboratorios, etc).
 Si un profile tiene un repositorio dado, este repositorio puede ser automáticam
ente configurado durante el aprovisionamiento y los sistemas instalados
 podrán usarlo como espejo (
\family typewriter
yum_post_install_mirror
\family default
 debe estar habilitado).
 Si se especifica una lista de paquetes para –rpm-list, se puede espejar
 solo esa parte del repositorio, más sus dependencias.
 Por ejemplo, si se espeja FC6 Extras, para descargar Cobbler y Koan, ponemos
 
\family typewriter
–rpm-list=”cobbler koan”
\family default
 y se saltea la parte de los paquetes de juegos.
 Esta función sólo funciona para repositorios http o ftp.
\end_layout

\begin_layout Standard
Los repositorios pueden ser creados del siguiente modo:
\end_layout

\begin_layout Standard

\family typewriter
cobbler repo add --mirror=url --name=string [--rpmlist=list] 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset

 [--creatrepo-flags=string] [--keep-updated=Y/N] [--priority=number] [--arch=str
ing] [--mirror-locally=Y/N] [--breed=yum|rsync|rhn]
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Donde
\end_layout

\begin_layout Standard

\series bold
mirror:
\series default
 Es la dirección del espejo yum.
 Puede ser una URL rsync:// , una ubicación ssh o una ubicación http://
 o ftp:// de un espejo.
 Direcciones del filesystem también funcionan.
 Esta dirección debe especificar un repositorio exacto a espejar, solo una
 arquitectura y una distribución.
\end_layout

\begin_layout Standard

\series bold
name: 
\series default
Este nombre es el usado para guardar la ubicación del espejo.
\end_layout

\begin_layout Standard

\series bold
rpm-list:
\series default
 Con esta opción se puede decidir espejar solo una parte de un repositorio
 (la lista de paquetes dados más dependencias).
 Por ejemplo : 
\family typewriter
--rpm-list="paquete_1 paquete_2"
\family default
.
 Esta opción sólo funciona con repositorios http:// y ftp:// para espejos
 de otros tipos esta opción será ignorada.
\end_layout

\begin_layout Standard

\series bold
createrepo-flags:
\series default
 Especifica banderas opcionales para añadir a la herramienta 
\family typewriter
createrepo
\family default
 la cual es llamada cuando se ejecuta 
\family typewriter
cobbler reposync
\family default
 para el repositorio dado.
 Por defecto se tiene 
\family typewriter
’-c cache’
\family default
.
\end_layout

\begin_layout Standard

\series bold
keep-updated: 
\series default
Especifica si el repositorio debería ser o no actualizado durante una ejecución
 normal de 
\family typewriter
cobbler reposync
\family default
.
 El repositorio puede seguir siendo actualizado por el nombre.
\end_layout

\begin_layout Standard

\series bold
mirror-locally: 
\series default
Cuando se configura a N, especifica que este repositorio yum se utiliza
 para ser referenciado directamente por kickstarts y no para ser espejado
 localmente en el servidor cobbler.
 Solo espejos con URLs http:// y ftp:// son soportados cuando se utiliza
 
\family typewriter
--mirror-locally=N
\family default
, no se puede usar URLs del filesystem.
\end_layout

\begin_layout Standard

\series bold
priority: 
\series default
Especifica la prioridad del repositorio (menor número, mayor prioridad)
 que se aplica a máquinas instaladas usando los repositorios que tienen
 el plugin yum priorities instalado.
 Por defecto se tiene 99.
\end_layout

\begin_layout Standard

\series bold
arch: 
\series default
Especifica la arquitectura que el repositorio debería utilizar.
 Por defecto se utiliza la arquitectura del servidor cobbler.
\end_layout

\begin_layout Standard

\series bold
breed: 
\series default
Usualmente cobbler comprenderá este parámetro si no se entrega.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para crear un repositorio local, por ejemplo para instalar Puppet en una
 instalación desde cero, y sin una conexión a Internet, primero es necesario
 tener los paquetes necesarios y sus dependencias, para ello se ejecuta:
\end_layout

\begin_layout Standard

\family typewriter
sudo yum install --downloadonly --downloaddir=<directory> <package>
\end_layout

\begin_layout Standard
Donde se debe reemplazar 
\family typewriter
<directory> 
\family default
por el directorio donde se descargará el paquete con sus dependencias y
 
\family typewriter
<package>
\family default
 por el 
\family typewriter
puppet.
\end_layout

\begin_layout Standard
Una vez obtenidos, crear una carpeta con el nombre del repositorio en 
\family typewriter
/var/www/cobbler/repo_mirror 
\family default
por ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
sudo mkdir /var/www/cobbler/repo_mirror/puppet
\end_layout

\begin_layout Standard
Luego es necesario añadirlo al servidor:
\end_layout

\begin_layout Standard

\family typewriter
cobbler repo add --name=puppet --keep-updated=N --arch=x86_64 --mirror-locally=Y
 --breed=yum
\end_layout

\begin_layout Standard
Donde 
\family typewriter
--name 
\family default
debe ser el mismo que el de la carpeta creada anteriormente.
 Acto seguido ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
createrepo /var/www/cobbler/repo_mirror/puppet
\end_layout

\begin_layout Standard

\family typewriter
cobbler reposync
\end_layout

\begin_layout Standard
Para añadir este nuevo repositorio a un profile de instalación existente:
\end_layout

\begin_layout Standard

\family typewriter
cobbler profile edit --name=centos7 --repos=puppet 
\end_layout

\begin_layout Standard
Se muestra la información acerca del mismo con:
\end_layout

\begin_layout Standard

\family typewriter
cobbler repo report --name=puppet
\end_layout

\begin_layout Subsubsection
Import
\end_layout

\begin_layout Standard
El propósito de “
\family typewriter
cobbler import
\family default
” es configurar un servidor de instalación por red para una o más distribuciones.
 Éste espeja contenido basado en una imagen DVD, un archivo ISO, un árbol
 en un filesystem, un espejo externo rsync o una ubicación SSH.
\end_layout

\begin_layout Standard

\family typewriter
$ cobbler import --path=/path/to/distro –name=F12
\end_layout

\begin_layout Standard
Este ejemplo muestra los dos argumentos requeridos para import: --path y
 –name.
\end_layout

\begin_layout Standard
Luego de que import es ejecutado, cobbler tratará de detectar el tipo de
 distribución y automáticamente asignar kickstarts.
 Por defecto, proveerá el sistema borrando el disco duro, configurando eth0
 para DHCP y utilizando la contraseña por defecto “cobbler”.
 Si esto no es deseado, editar los archivos kickstart en 
\family typewriter
/var/lib/cobbler/kickstarts
\family default
 para hacer algo distinto o cambiar la configuración del kickstart después
 que cobbler cree el profile.
 El contenido espejado es guardado automáticamente en 
\family typewriter
/var/www/cobbler/ks_mirror
\family default
.
 
\end_layout

\begin_layout Standard
Ejemplos:
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=rsync://mirrorserver.example.com/path/ --name=fedora
 --arch=x86
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=root@192.168.1.10:/stuff --name=bar
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/mnt/dvd --name=baz --arch=x86_64
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/path/to/stuff –name=glorp
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/path/where/filer/is/mounted --name=anyname 
\backslash
 --available-as=nfs://nfs.example.org:/where/mounted/
\end_layout

\begin_layout Standard
Una vez importado, ejecutar “
\family typewriter
cobbler list
\family default
” o “
\family typewriter
cobbler report
\family default
” para ver que se ha añadido.
 Si se quiere forzar la utilización de una plantilla kickstart de cobbler
 para todos los profiles creados por un import, se puede pasar la opción
 
\family typewriter
–kickstart
\family default
 a import para saltar la auto detección del kickstart.
\end_layout

\begin_layout Subsubsection
Kickstarts
\end_layout

\begin_layout Standard
Los kickstarts son archivos que indican cómo debe ser configurado el sistema
 operativo, el archivo contiene palabras claves, valores y en otros casos
 solo contienen la palabra clave que en sí misma es una configuración especifica.
 
\end_layout

\begin_layout Standard
Algunas palabras clave (keywords) son opcionales, mientras que otras son
 necesarias para la instalación.
\end_layout

\begin_layout Paragraph
Keywords
\end_layout

\begin_layout Itemize

\series bold
autopart (optional)
\series default
 : Creación automática de particiones, 1 GB o más para el directorio raíz
 ( / ), una partición de intercambio y una partición de arranque apropiada
 para la arquitectura .
 Uno o más de los tamaños de las particiones por defecto puede ser re-definido
 con la zona de directivas.
\end_layout

\begin_layout Itemize

\series bold
ignoredisk (optional)
\series default
 : Hace que el instalador ignore los discos especificados.
\end_layout

\begin_deeper
\begin_layout Standard
La sintaxis es:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

dignoredisk --drives=drive1,drive2,...
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
auth or authconfig (required) :
\series default
Establece las opciones de autenticación para el sistema.
 Es similar al comando authconfig , que se puede ejecutar después de la
 instalación .
 Por defecto, las contraseñas son encriptadas y no utilizan shadow .
\end_layout

\begin_layout Itemize

\series bold
bootloader (required): 
\series default
Especifica cómo se debe instalar el gestor de arranque.
\end_layout

\begin_layout Itemize

\series bold
clearpart (optional) :
\series default
 Elimina las particiones del sistema, antes de la creación de nuevas particiones
 .
 Por defecto no se eliminan las particiones .
\end_layout

\begin_layout Itemize

\series bold
cmdline (optional) : 
\series default
Realiza la instalación en un modo de línea de comandos completamente no
 interactivo.
 Cualquier solicitud por interacciones detendrá la instalación.
\end_layout

\begin_layout Itemize

\series bold
device (optional) : 
\series default
El comando de dispositivo , indica al programa de instalación para instalar
 módulos adicionales , es en este formato :
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

device <type><moduleName> --opts=<options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
driverdisk (optional) : 
\series default
Disquetes de controladores se pueden usar durante instalaciones kickstart.
\end_layout

\begin_layout Itemize

\series bold
firewall (optional) : 
\series default
Esta opción corresponde a la pantalla de configuración de firewall en el
 programa de instalación.
\end_layout

\begin_layout Itemize

\series bold
firstboot (optional) :
\series default
 Determinar si el agente de configuración se inicia la primera vez que se
 arranca el sistema .
 Si se activa, el paquete firstboot debe estar instalado.
 Si no se especifica, esta opción está desactivada por defecto.
\end_layout

\begin_layout Itemize

\series bold
halt (optional) : 
\series default
Detiene el sistema después de que la instalación se ha completado con éxito
 .
 Esto es similar a una instalación manual, en donde Aanaconda muestra un
 mensaje y espera a que el usuario presione una tecla antes de reiniciar.
 Durante una instalación Kickstart, si no se especifica el método de terminación
, la opción reboot se utiliza como predeterminado.
\end_layout

\begin_layout Itemize

\series bold
graphical (optional) : 
\series default
Realice la instalación kickstart en modo gráfico .
 Este es el valor predeterminado .
\end_layout

\begin_layout Itemize

\series bold
install (optional) : 
\series default
Le dice al sistema para instalar un sistema nuevo en lugar de actualizar
 un sistema existente.
 Este es el modo por defecto.
 
\end_layout

\begin_layout Itemize

\series bold
ignore disk (optional) : 
\series default
Se utiliza para especificar los discos que Aanaconda no debe tocar durante
 la partición , el formato, y la limpieza .
 Este comando tiene un único argumento necesario , que toma una lista separada
 por comas de nombres de unidad de ignorar.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

ignoredisk --drives=[disk1,disk2,...]
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
interactive (optional) : 
\series default
Utiliza la información proporcionada en el archivo kickstart durante la
 instalación, pero permite la inspección y modificación de los valores dados
 .
 Se le presentará con cada pantalla del programa de instalación con los
 valores del archivo kickstart .
 Puede aceptar los valores haciendo clic en Siguiente o cambiar los valores
 y haga clic en Siguiente para continuar.
\end_layout

\begin_layout Itemize

\series bold
key (optional): 
\series default
Especifique una clave de instalación, que es necesaria para ayudar en la
 selección de paquetes e identificar su sistema con fines de apoyo.
 Este comando es Red Hat Enterprise Linux específico.
\end_layout

\begin_layout Itemize

\series bold
keyboard (required) : 
\series default
Establece el tipo de teclado.
\end_layout

\begin_layout Itemize

\series bold
lang (required) : 
\series default
Establece el idioma que desea utilizar durante la instalación y el idioma
 predeterminado para utilizar en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
logvol (optional) : 
\series default
Crea un Logical Voume con la sintaxis:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

logvol <mntpoint> --vgname=<name> --size=<size> --name=<name><options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
logging (optional) : 
\series default
Este comando controla el registro de errores de Anaconda durante la instalación.
 No tiene ningún efecto en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
monitor (optional) : 
\series default
Si no se da el comando monitor, Anaconda utilizará X para detectar automáticamen
te la configuración del monitor.
\end_layout

\begin_layout Itemize

\series bold
network (optional) : 
\series default
Configura la información de red para el sistema.Si la instalación no requiere
 redes y la información de la red no se proporciona en el archivo kickstart,
 el programa de instalación asume que la instalación debe hacerse sobre
 eth0 a través de una dirección IP dinámica ( BOOTP / DHCP), y configura
 el sistema final, instalado para determinar su dirección IP de forma dinámica.
 
\end_layout

\begin_layout Itemize

\series bold
part or partition (required for installs, ignored for upgrades) : 
\series default
Crea una partición en el sistema.
\end_layout

\begin_layout Itemize

\series bold
poweroff (optional) : 
\series default
Apaga el sistema luego de que la instalación se complete exitosamente.
\end_layout

\begin_layout Itemize

\series bold
raid (optional) : 
\series default
Monta un sistema RAID.
\end_layout

\begin_layout Itemize

\series bold
reboot (optional) : 
\series default
Reinicia el sistema después de una instalación exitosa.
\end_layout

\begin_layout Itemize

\series bold
repo (optional) : 
\series default
Configura un repositorio adicional YUM que puede ser utilizado como fuente
 para la instalación de paquetes.
\end_layout

\begin_layout Itemize

\series bold
rootpw (required) : 
\series default
Establece la contraseña de root.
\end_layout

\begin_layout Itemize

\series bold
selinux (optional) : 
\series default
Establece el estado del SElinux en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
services (optional) :
\series default
Modifica el conjunto predeterminado de servicios que se ejecutarán bajo
 el nivel de ejecución predeterminado.
\end_layout

\begin_layout Itemize

\series bold
shutdown (optional) : 
\series default
Apaga el sistema después de una instalación exitosa.
\end_layout

\begin_layout Itemize

\series bold
text (optional) : 
\series default
Realiza la instalación kickstart en modo texto.
 Las instalaciones Kickstart se ejecutan en modo gráfico por defecto.
\end_layout

\begin_layout Itemize

\series bold
timezone (required) : 
\series default
Selecciona la zona horaria del sistema.
\end_layout

\begin_layout Itemize

\series bold
upgrade (optional) : 
\series default
Indica que se realiza una actualización del sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
user (optional) :
\series default
 Crea usuario en el sistema.
\end_layout

\begin_layout Itemize

\series bold
vnc (optional) : 
\series default
Permite que la instalación gráfica pueda ser vista de forma remota a través
 de VNC.
\end_layout

\begin_layout Itemize

\series bold
volgroup (optional) : 
\series default
Crea logical volume group con la sintaxis:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

volgroup <name><partition><options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
zerombr (optional) : 
\series default
Si se especifica zerombr, y si es su único argumento, cualquier tabla de
 partición no válidas que se encuentran en los discos son inicializadas.
 Esto destruye todos los contenidos de discos con tablas de partición inválidas.
 
\end_layout

\begin_layout Subsubsection
Snippets
\end_layout

\begin_layout Standard
Los snippets son una forma de reutilizar bloques de código entre kickstarts
 (también funcionan en otros tipos de archivos).
 Esto quiere decir que cada vez que el texto SNIPPET aparezca en un archivo
 kickstart será reemplazado por los contenidos en el archivo correspondiente
 dentro de 
\emph on
/var/lib/cobbler/snippets/.
 
\emph default
Esto permite la re-utilización de código en cada plantilla, aliviando también
 la lectura de las mismas.
\end_layout

\begin_layout Standard
Para utilizar un snippet, es necesario crear un archivo en el directorio
 
\emph on
/var/lib/cobbler/snippets/nuevo_snippet 
\emph default
y, en un archivo kickstart, al momento de llamar a esta porción de código
 se utiliza:
\end_layout

\begin_layout Standard

\family typewriter
\emph on
$SNIPPET('nuevo_snippet')
\end_layout

\begin_layout Standard
Los snippets pueden ser guardados en subdirectorios para una mejor organización.
 El orden de precedencia será como sigue:
\end_layout

\begin_layout Standard

\family typewriter
\emph on
/var/lib/cobbler/snippets/$subdirectorio/$nombre_del_snippet 
\end_layout

\begin_layout Standard
Para referenciarlo desde el archivo kickstart, ahora se tiene:
\end_layout

\begin_layout Standard

\family typewriter
\emph on
$SNIPPET('direcorio/nuevo_snippet ')
\end_layout

\begin_layout Standard
Cobbler no reconoce caracteres que no estén en el alfabeto inglés, por este
 motivo se recomienda no utilizar caracteres especiales como 
\emph on
ñ
\emph default
 u otros que lleven tilde.
\end_layout

\begin_layout Subsubsection
Integración con Puppet
\end_layout

\begin_layout Standard
Este ejemplo es relativamente avanzado, involucrando “
\family typewriter
mgmt-classes
\family default
” de Cobbler para controlar diferentes tipos de configuración inicial.
 Pero si en cambio se opta por poner la mayor parte de la configuración
 inicial en Puppet en vez de aquí, entonces podría ser más simple.
\end_layout

\begin_layout Paragraph
Manter class mappings en cobbler
\end_layout

\begin_layout Standard
Primero se debe asignar “
\family typewriter
management classes
\family default
” a la distro, profile o system.
\end_layout

\begin_layout Standard

\family typewriter
cobbler distro edit --name=distro1 --mgmt-classes="distro1" 
\end_layout

\begin_layout Standard

\family typewriter
cobbler profile add --name=webserver --distro=distro1 --mgmt-classes="webserver
 likes_llamas" --kickstart=/etc/cobbler/my.ks 
\end_layout

\begin_layout Standard

\family typewriter
cobbler system edit --name=system --profile=webserver --mgmt-classes="orange"
 –dns-name=system.example.org
\end_layout

\begin_layout Standard
Para Puppet el –dns-name (mostrado arriba) debe estar configurado porque
 esto es lo que Puppet estará enviando a Cobbler y es como encontrará el
 sistema.
 Puppet no tiene conocimiento sobre el nombre del sistema objeto en Cobbler.
 Para hacerlo de forma segura, probablemente se utilice FQDN aquí (lo cual
 es lo que se quiere si se utiliza cobbler para administrar DNS).
 
\end_layout

\begin_layout Paragraph
External Nodes 
\end_layout

\begin_layout Standard
Cobbler provee uno, así configura Puppet para usar 
\family typewriter
/usr/bin/cobbler-ext-nodes
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
[main] 
\end_layout

\begin_layout Standard

\family typewriter
external_nodes = /usr/bin/cobbler-ext-nodes 
\end_layout

\begin_layout Standard
y también añadir lo siguiente al archivo de configuración: 
\end_layout

\begin_layout Standard

\family typewriter
node_terminus = exec
\end_layout

\begin_layout Standard
Ésto es un script simple que toma el información en la siguiente URL, la
 cual es una URL que siempre retorna un documento YAML en la forma que Puppet
 espera que sea retornado.
 Este archivo contiene todos los parámetros y clases que están para ser
 asignadas en el nodo en cuestión.
 Esta URL de Cobbler es: 
\family typewriter
http://cobbler/cblr/svc/op/puppet/hostname/foo
\end_layout

\begin_layout Standard
y esto retornará datos como: 
\end_layout

\begin_layout Standard

\family typewriter
--- classes: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- distro1 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- webserver 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- likes_llamas 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- orange 
\end_layout

\begin_layout Standard

\family typewriter
parameters: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

tree: 'http://.../x86_64/tree'
\end_layout

\begin_layout Standard
Estos parámetros vienen de todo lo que Cobbler monitorea en “
\family typewriter
--ks-meta
\family default
” (también es un parámetro).
 De este modo se puede fácilmente añadir parámetros como añadir clases y
 mantener todo organizado en un lugar.
 En caso de tener parámetros o clases globales para añadir, esto se puede
 hacer editando los siguientes campos en
\family typewriter
 /etc/cobbler/settings
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
mgmt_classes: [ ] 
\end_layout

\begin_layout Standard

\family typewriter
mgmt_parameters: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

from_cobbler: 1
\end_layout

\begin_layout Subsubsection
Replicate
\end_layout

\begin_layout Standard
Este comando descarga la configuración de un servidor Cobbler a otro.
 Sirve para tener implementaciones de High Availability, recuperación de
 desastres o para balanceo de carga.
\end_layout

\begin_layout Standard

\family typewriter
cobbler replicate --master=master.example.org
\end_layout

\begin_layout Standard
Con los argumentos por defecto, solo la metadata de la distribución y del
 perfil es sincronizada.
 A continuación se muestra los argumentos que se le pueden pasar a Cobbler
 para que replique: 
\end_layout

\begin_layout Standard

\family typewriter
# cobbler replicate --help 
\end_layout

\begin_layout Standard

\family typewriter
Usage: cobbler [options]
\end_layout

\begin_layout Standard

\family typewriter
Options: -h, --help show this help message and exit 
\end_layout

\begin_layout Standard

\family typewriter
--master=MASTER Cobbler server to replicate from.
 
\end_layout

\begin_layout Standard

\family typewriter
--distros=PATTERN pattern of distros to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--profiles=PATTERN pattern of profiles to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--systems=PATTERN pattern of systems to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--repos=PATTERN pattern of repos to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--image=PATTERN pattern of images to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--omit-data do not rsync data 
\end_layout

\begin_layout Standard

\family typewriter
--prune remove objects (of all types) not found on the master
\end_layout

\begin_layout Paragraph
Setup
\end_layout

\begin_layout Standard
En cada servidor que será la réplica del master, instalar Cobbler normalmente
 y asegurarse que 
\family typewriter
/etc/cobbler/settings
\family default
 y 
\family typewriter
/etc/cobbler/modules.conf 
\family default
están configurados apropiadamente.
 Utilizar cobbler check para ver si existe algún error.
 El comando no modificará estos archivos.
 
\end_layout

\begin_layout Standard
Los archivos son transferidos por rsync (sobre ssh) o por scp, por lo que
 es necesario tener un agente ssh antes de utilizar el comando de réplica
 o si no, utilizar authorized_keys en el host remoto.
\end_layout

\begin_layout Subsection

\color red
Creación del sistema de aprovisionamiento y automatización Cobbler
\end_layout

\begin_layout Subsubsection

\family roman
\color red
Instalación
\end_layout

\begin_layout Standard

\color red
Primero y principal, Cobbler necesita Python, alguna versión superior a
 la 2.6.
 Además, requiere de un servidor DHCP, FTP, HTTP y Rsync y una serie de
 paquetes.
\end_layout

\begin_layout Itemize

\color red
createrepo
\end_layout

\begin_layout Itemize

\color red
httpd 
\end_layout

\begin_layout Itemize

\color red
mkisofs mod_wsgi
\end_layout

\begin_layout Itemize

\color red
mod_ssl 
\end_layout

\begin_layout Itemize

\color red
python-cheetah 
\end_layout

\begin_layout Itemize

\color red
python-netaddr
\end_layout

\begin_layout Itemize

\color red
python-simplejson 
\end_layout

\begin_layout Itemize

\color red
python-urlgrabber 
\end_layout

\begin_layout Itemize

\color red
PyYAML 
\end_layout

\begin_layout Itemize

\color red
rsync 
\end_layout

\begin_layout Itemize

\color red
syslinux 
\end_layout

\begin_layout Itemize

\color red
tftp-server 
\end_layout

\begin_layout Itemize

\color red
yum-utils 
\end_layout

\begin_layout Standard

\color red
La interfaz web de cobbler requiere Django.
\end_layout

\begin_layout Standard

\color red
Se añade el repositorio Epel de CentOS 7
\end_layout

\begin_layout Standard

\family typewriter
\color red
wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
\end_layout

\begin_layout Standard

\family typewriter
\color red
rpm -Uvh epel-release-*
\end_layout

\begin_layout Standard

\color red
Se instalan los paquetes necesarios para cobbler, el servidor DHCP, FTP,
 HTTP, etc.
\end_layout

\begin_layout Standard

\family typewriter
\color red
yum install cobbler cobbler-web dhcp pykickstart system-config-kickstarttftp
 httpd xinetd fence-agents-all -y
\end_layout

\begin_layout Subsubsection

\color red
Configuración de servicios
\end_layout

\begin_layout Standard

\color red
Se deben configurar los servios que requiere cobbler (DHCP, FTP.
 HTTP, etc)
\end_layout

\begin_layout Standard

\series bold
\color red
Configurar FTP y activación de RSYNCD
\end_layout

\begin_layout Standard

\color red
Editar /etc/xinetd.d/tftp modificando disable = yes por no.
 Luego ejecutar:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl start rsyncd 
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl enable rsyncd
\end_layout

\begin_layout Standard

\series bold
\color red
Configurar DHCP
\end_layout

\begin_layout Standard

\color red
Copiar el archivo de configuración de ejemplo:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf
\end_layout

\begin_layout Standard

\color red
Verificar en cada caso la versión de dhcp.
\end_layout

\begin_layout Standard

\color red
Luego editar /etc/dhcp/dhcpd.conf, la configuracion utilizada en este trabajo
 se adecua la red 
\begin_inset Quotes eld
\end_inset

puppet
\begin_inset Quotes erd
\end_inset

 creada.
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
# A slightly different configuration for an internal subnet.
\end_layout

\begin_layout Standard

\family typewriter
\color red
subnet 192.168.122.0 netmask 255.255.255.0 { 
\end_layout

\begin_layout Standard

\family typewriter
\color red
range 192.168.122.1 192.168.100.254; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
option domain-name-servers puppet; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
option domain-name "localdomain"; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
option routers 192.168.122.1; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
option broadcast-address 192.168.122.255; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
default-lease-time 600; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
max-lease-time 7200; } 
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
De la misma forma se configura el archivo 
\family typewriter
/etc/cobbler/dhcp.template.
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
subnet 192.168.122.0 netmask 255.255.255.0 { 
\end_layout

\begin_layout Standard

\family typewriter
\color red
option routers 192.168.122.1; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
option domain-name-servers 192.168.122.1; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
option subnet-mask 255.255.255.0; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
range dynamic-bootp 192.168.122.1 192.168.122.254; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
default-lease-time 21600; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
max-lease-time 43200; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
next-server $next-server; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
class "pxeclients" { match if substring (option vendor-class-identifier,
 0, 9) = "PXEClient"; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
if option pxe-system-type = 00:02 {
\end_layout

\begin_layout Standard

\family typewriter
\color red
filename "ia64/elilo.efi"; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
} else if option pxe-system-type = 00:06 {
\end_layout

\begin_layout Standard

\family typewriter
\color red
filename "grub/grub-x86.efi"; } 
\end_layout

\begin_layout Standard

\family typewriter
\color red
else if option pxe-system-type = 00:07 {
\end_layout

\begin_layout Standard

\family typewriter
\color red
filename "grub/grub-x86_64.efi"; } 
\end_layout

\begin_layout Standard

\family typewriter
\color red
else { filename "pxelinux.0"; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
}
\end_layout

\begin_layout Standard

\family typewriter
\color red
}
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Añadir a /etc/hosts la dirección del servidor y su hostname (puppet).
 Luego configurar el parámetro ServerName en /etc/httpd/conf/httpd.conf con
 el nombre del host, en este caso será puppet.
\end_layout

\begin_layout Standard

\color red
ServerName puppet 
\end_layout

\begin_layout Standard

\color red
Los servicios ya están listos para funcionar, se los inicia e indica que
 se inicien automáticamente al prender la maquina
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl start httpd.service
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl start dhcpd.service
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl start xinetd.service 
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl start cobblerd.service 
\end_layout

\begin_layout Standard

\family typewriter
\color red
\begin_inset space ~
\end_inset

 
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl enable httpd.service 
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl enable dhcpd.service 
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl enable xinetd.service 
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl enable cobblerd.service
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Configuramos el servidor de cobbler, para ello se edito el archivo /etc/cobbler/
settings.
\end_layout

\begin_layout Standard

\color red
La clave de los usuarios root de las VMs por defecto se decidió que sea
 
\begin_inset Quotes eld
\end_inset

qwerty
\begin_inset Quotes erd
\end_inset

.
 Se encripta esta clave con el comando 
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
openssl passwd -1
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Lo que dará algo similar a:
\end_layout

\begin_layout Standard

\family typewriter
\color red
Password: Verifying - Password: $1$U.Svb2gw$MNHrAmG.axVHYQaQRySR5/
\end_layout

\begin_layout Standard

\color red
y se coloca en la seccion correspondiente del archivo de configuración de
 cobbler
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
default_password_crypted: "$1$U.Svb2gw$MNHrAmG.axVHYQaQRySR5/" 
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Dado que se desea utilizar un servidor DHCP en la misma maquina que contiene
 el servidor Cobbler, se modificar la seccion “manage_dhcp: 0” para habilitar
 el administrador del DHCP.
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
manage_dhcp: 1 
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Configurar ahora la dirección IP del servidor Cobbler en las variables “server”
 y “next_server” colocando la interfaz virtual que conecta a la maquina
 física con las maquinas virtuales,virbr0:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
next_server: 192.168.122.1
\end_layout

\begin_layout Standard

\family typewriter
\color red
server: 192.168.122.1
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Para habilitar la interfaz web de Cobbler y configurar usuario y contraseña,
 se modificaron las siguientes líneas del archivo /etc/cobbler/modules.conf
 para que queden de este modo:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
[authentication] module = authn_configfile
\end_layout

\begin_layout Standard

\family typewriter
\color red
[authorization] module = authz_allowall 
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
El usuario y la contraseña para la interfaz web que por defecto tiene tanto
 a usuario como contraseña a “cobbler”,se utiliza correr el siguiente comando
 e ingresar la contraseña preferida dos veces:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
htdigest /etc/cobbler/users.digest "Cobbler" admin
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename Imagenes/cobbler/Cobbler Web Interface - Mozilla Firefox_001.png
	width 15cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Cobbler Web
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
En el proyecto se utilizo admin como el usuario para ingresar a la interfaz
 web y la clave es 
\begin_inset Quotes eld
\end_inset

qwerty
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard

\color red
Se edita el archivo /etc/debmirror.conf comentando las siguientes lineas:
\end_layout

\begin_layout Standard

\family typewriter
\color red
#@dists="sid"; 
\end_layout

\begin_layout Standard

\family typewriter
\color red
#@arches="i386"; 
\end_layout

\begin_layout Standard

\color red
Se reinician todos los servicios para asegurarse de que todos tomen su nueva
 configuración 
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl restart httpd.service
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl restart dhcpd.service
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl restart xinetd.service 
\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl restart cobblerd.service 
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
El próximo paso es descargar los “network boot loaders” con el comando 
\family typewriter
cobbler get-loaders y 
\family default
se sincroniza el servidor de cobbler.
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl restart cobblerd.service 
\end_layout

\begin_layout Standard

\family typewriter
\color red
Sincronizar cobbler cobbler sync
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection

\color red
Repositorio local separado de Cobbler
\end_layout

\begin_layout Standard

\color red
En el caso que se desee crear un repositorio local que no dependa del servidor
 Cobbler, se debe primero instalar los servicios necesarios para el funcionamien
to del servicio de repositorios, estos servicios son 
\family typewriter
vsftpd
\family default
 que asegura una conexión segura y createrepo que es el encargado de generar
 las bases de datos necesarias para el correcto funcionamiento del repositorio.
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo yum install -y createrepo vsftpd lftp
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Una vez hecho ésto, se tiene que crear el árbol de directorios adecuado
 de acuerdo a la aplicación.
 Éste puede estar divido como se desee, por ejemplo, por sistema operativo,
 por distribución, por arquitectura, etc.
\end_layout

\begin_layout Standard

\color red
Se recomienda utilizar como base el directorio
\family typewriter
 /var/ftp/pub
\family default
 dado que se utilizará este sistema de transmisión de archivos.
\end_layout

\begin_layout Standard

\color red
Una vez creado el sistema de archivos, se guardan los correspondientes paquetes
 rpm en los lugares adecuados, acordes a cómo se haya creado el árbol de
 archivos, y se ejecuta el siguiente comando:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
creterepo -v /var/ftp/pub/nombre_repo
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Es necesario entonces configurar el demonio vsftpd editando el archivo /etc/vsft
pd/vsftpd.conf.
 Hay diversas configuraciones posibles, pero hay dos puntos importantes
 que deben existir:
\end_layout

\begin_layout Enumerate

\family typewriter
\color red
anonymous_enable=YES #Indica que se puede acceder vía ftp de manera anónima.
\end_layout

\begin_layout Enumerate

\family typewriter
\color red
anon_root=/var/ftp/pub #Indica la raíz del directorio al cual se puede acceder
 de manera anónima.
\end_layout

\begin_layout Standard

\color red
Por último, iniciar el servicio:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
systemctl start vsftpd
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset

 
\end_layout

\begin_layout Standard

\color red
En el lado del cliente es necesario informar del nuevo repositorio.
 Para ésto, crear un archivo en /etc/yum.repos.d/nombredelrepo.repo con el
 siguiente contenido:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
[nombredelrepo] 
\end_layout

\begin_layout Standard

\family typewriter
\color red
name=nombredelrepo
\end_layout

\begin_layout Standard

\family typewriter
\color red
comment ="Repositorio local para proyecto integrador" 
\end_layout

\begin_layout Standard

\family typewriter
\color red
baseurl=ftp://IP_servidor/nombre_del_sistema_de_archivos #Notar que el path
 es absoluto, partiendo desde el path permitido para los usuarios anonimos.
\end_layout

\begin_layout Standard

\family typewriter
\color red
gpgcheck=0 
\end_layout

\begin_layout Standard

\family typewriter
\color red
enabled=1
\end_layout

\begin_layout Standard

\family typewriter
\color red
priority=1
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset

 
\end_layout

\begin_layout Standard

\color red
Los paquetes yum-priorities e yum-utils deben estar instalados en el cliente,
 para poder utilizar sus funcionalidades (dar prioridad a los repositorios
 y habilitarlos fácilmente.)
\end_layout

\begin_layout Standard

\color red
Para utilizar este repositorio primero hay que habilitarlo:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
yum-config-manager --enable proyectointegrador
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Luego es necesario actualizar base de datos de repositorios:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
yum makecache
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\color red
Es posible utilizar sólo el repositorio recién creado y excluir los demás,
 para ello:
\end_layout

\begin_layout Standard

\color red
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\color red
yum-config-manager --disable * --enable proyectointegrador
\end_layout

\begin_layout Subsubsection

\color red
Importar imágenes ISO al servidor Cobbler
\end_layout

\begin_layout Standard

\color red
De esta forma, se puede generar una distribución que se utilizara para instalar
 los SO sin necesidad de acceder a internet de una forma fácil y rápida.
\end_layout

\begin_layout Standard

\color red
Se utiliza el comando mount.
 Primero crear un directorio y luego montar el archivo ISO:
\end_layout

\begin_layout Standard

\family typewriter
\color red
mkdir /mnt/centos
\end_layout

\begin_layout Standard

\family typewriter
\color red
mount -t iso9660 -o loop,ro /path/to/isos/CentOS-7-x86_64-DVD-1503-01.iso
 /mnt/centos
\end_layout

\begin_layout Standard

\color red
Luego ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
\color red
cobbler import --name=centos7 --arch=x86_64 --path=/mnt/centos
\end_layout

\begin_layout Standard

\color red
Ésto creará una copia local en el servidor, dando lugar a un nuevo objeto
 “distro” y “profile”.
 Los cuales se pueden verificar con:
\end_layout

\begin_layout Standard

\family typewriter
\color red
cobbler distro list
\end_layout

\begin_layout Standard

\family typewriter
\color red
cobbler profile list
\end_layout

\begin_layout Section
Puppet
\end_layout

\begin_layout Standard
El agente y el servidor se comunican vía HTTPS con verificación de cliente.
 El nodo maestro (servidor) provee una interfaz HTTPS con varios extremos
 disponibles.
 Cuando se pide o enviá cualquier cosa al servidor, el agente hace un pedido
 HTTPS o a uno de esos extremos.
\end_layout

\begin_layout Standard
Client-vefied HTTPS quiere decir que cada maestro o agente tiene un identificado
r por certificado SSL y examinan los certificados de sus contrapartes para
 decidir si permite un intercambio de información.
 Puppet incluye un constructor de certificado de autorización para administrar
 los certificados.
 Los agentes puede pedir automáticamente los certificados vía la API HTTP
 del maestro.
 El administrador del nodo maestro puede usar el comando 
\family typewriter
puppet cert
\family default
 para inspeccionar los pedidos y firmar nuevos certificados; los agentes
 pueden entonces descargar los certificados firmados.
 
\end_layout

\begin_layout Subsection
Tópicos generales de Puppet
\end_layout

\begin_layout Subsubsection
Module
\end_layout

\begin_layout Standard
Un módulo o module, es un conjunto de código de Puppet empaquetado junto
 con los otros archivos y datos, que se necesita administrar sobre algún
 aspecto del sistema.
 Consiste en una estructura predefinida de directorios que ayudan a Puppet
 a encontrar los contenidos del módulo.
 
\end_layout

\begin_layout Standard

\color red
Existe un repositorio público (The Puppet Forge) donde se pueden encontrar
 módulos hechos por la comunidad y también mantenidos por Puppet Labs.Estos
 módulos se pueden instalar en un servidor-pupper para utilizarlos.
\end_layout

\begin_layout Standard

\color red
Para ver los módulos instalados se puede ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
puppet module list
\end_layout

\begin_layout Standard
Los módulos son auto-contenidos y separados.
 Su estructura de archivo le da a Puppet una forma consistente de localizar
 cualquier clase, plantillas, plugins y binarios requeridos para satisfacer
 la funcionalidad del módulo.
\end_layout

\begin_layout Standard
Todos los módulos accesibles por el puppet master están localizados en los
 directorios especificados por la variable 
\family typewriter
'modulepath'
\family default
 en el archivo de configuración de Puppet.
 Para encontrar esta variable en cualquier sistema con Puppet, se puede
 ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
puppet agent --configprint modulepath 
\end_layout

\begin_layout Subsubsection
Resources
\end_layout

\begin_layout Standard
Cada recurso o resource, describe algún aspecto de un sistema y su estado,
 como por ejemplo, un servicio que debería estar ejecutándose o un paquete
 que se quiere instalado.
 El bloque de código que describe un recurso se llama declaración de recurso
 (resource declaration).
 Estas declaraciones de recurso están escritas en código Puppet, un DLS
 (Domain Specific Language) construido en Ruby.
 El DLS de Puppet es un lenguaje declarativo en vez de imperativo.
 Esto quiere decir que en vez de definir un proceso o un conjunto de comandos,
 el código de Puppet describe (o declara) solo el estado final deseado,
 y depende de proveedores integrados para lidiar con la implementación.
\end_layout

\begin_layout Standard

\family typewriter
puppet resource tool -> puppet resource <type> <name> 
\end_layout

\begin_layout Standard
Puppet incluye una variedad de tipos de recursos integrados, que permiten
 administrar varios aspectos de un sistema.
 Algunos de los tipos de recursos claves que generalmente se encuentran
 en un sistema son los siguientes:
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
user:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un usuario 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
group:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un grupo de usuario 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
file:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un archivo específico 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
package:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un paquete de software 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
service:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un servicio corriendo
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
cron:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un trabajo programado de cron 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
exec:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un comando externo 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
host:
\series default
 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un host
\end_layout

\begin_layout Standard
Una declaración de recurso seguirá un patrón como el de abajo:
\end_layout

\begin_layout Standard

\family typewriter
tipo {'título': 
\end_layout

\begin_layout Standard

\family typewriter
atributo => 'valor', 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Itemize

\series bold
Título: 
\series default
Es un string que identifica un recurso para el compilador de Puppet.
\end_layout

\begin_deeper
\begin_layout Standard
El título no tiene que coincidir con lo que va a administrar en el sistema,
 pero a menudo se desea eso.
 
\end_layout

\begin_layout Standard
Los títulos deben ser únicos por tipos de recursos, se puede tener un paquete
 y un servicios ambos con el mismo título, pero no dos servicios con ese
 título.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Atributos: 
\series default
Los atributos describen el estado deseado para un recurso; cada atributo
 maneja algún aspecto del recurso.
 
\end_layout

\begin_deeper
\begin_layout Standard
Cada tipo de recurso tiene su propio juego de atributos.
 Muchos tipos de recursos tienen atributos claves y una gran cantidad de
 opcionales.
\end_layout

\begin_layout Standard
Todos los atributos declarados deben tener un valor; el tipo de dato del
 valor depende de los que acepte el atributo.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Comportamiento: 
\series default
Una declaración de recurso agrega un recurso al catálogo y le dice a Puppet
 que administre el estado del recurso.
 Cuando Puppet aplica el catálogo compilado, lo que hará es:
\end_layout

\begin_deeper
\begin_layout Itemize
Leer el estado actual del recurso en el sistema objetivo.
\end_layout

\begin_layout Itemize
Comprar el estado actual con el deseado
\end_layout

\begin_layout Itemize
Si es necesario, realizar cambios para llevar el estado actual al deseado.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Recursos no administrados: 
\series default
Si el catálogo no contiene un recurso, implica que Puppet ya no lo administra,
 pero no que lo 
\begin_inset Quotes eld
\end_inset

elimina
\begin_inset Quotes erd
\end_inset

, si se desea eliminarlo, se debe aclararlo en su estado deseado.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
ensure => absent
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Singularidad: 
\series default
Puppet no permite que se declare un mismo recurso dos veces.
 Esto prevee conflictos de valores.
 Si múltiples clases requieren el mismo recurso se puede usar una clase
 o un recurso virtual para añadirlo al catálogo en múltiples lugares sin
 duplicar.
\end_layout

\begin_layout Itemize

\series bold
Relaciones y orden: 
\series default
Por defecto, Puppet aplica los recursos sin seguir el orden en que fueron
 escritos.
 Esto, se puede desactivar con la opción de ordenado.
 Sin embargo, si un recurso debe ser aplicado antes o después de otro, se
 puede indicar una relación entre ellos.
 Incluso se puede indicar que cambios en un recurso causen que otro se refresque.
\end_layout

\begin_layout Itemize

\series bold
Cambios, eventos y reportes: 
\series default
Si Puppet realiza cambios, en un recurso, registra esos cambios como eventos.
 Esos eventos aparecerán en el 
\emph on
log
\emph default
 y en el reporte de ejecución de puppet.
\end_layout

\begin_layout Itemize

\series bold
Independencia de alcance: 
\series default
Los recursos no están sujetos a los alcances.
 Un recurso, en cualquier ámbito, se puede referenciar desde cualquier otro
 ámbito.
\end_layout

\begin_layout Itemize

\series bold
Atributos especiales de los recursos.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Name/Namevar: 
\series default
Define un recurso en el sistema objetivo.

\emph on
 
\emph default
Por ejemplo, el 
\emph on
name
\emph default
 de un servicio o paquete es el nombre por el cual las herramientas de paquetes
 o servicios lo reconocen o en el caso de un archivo, su namevar es el path.
 Esto es diferente al título, el cual identifica un recurso para el compilador
 de Puppet.
 Sin embargo, ellos a veces tienen el mismo valor.

\series bold
 
\series default
La separación de nombre y título permite administrar un recurso que mantiene
 su título, pero que tiene diferente nombre en diferentes plataformas.
 Por ejemplo, un servicio 
\emph on
ntp 
\emph default
en sistemas Red Hat tiene por nombre 
\emph on
ntpd 
\emph default
y en sistemas debian
\emph on
 ntp .
\end_layout

\begin_layout Itemize

\series bold
Ensure: 
\series default
Esto generalmente maneja el aspecto más importante de un recurso en el sistema
 objetivo.
 Indica si el archivo existe, si el servicio está corriendo o parado, si
 el paquete está instalado, etc.
\end_layout

\end_deeper
\begin_layout Paragraph*
Tipos de recursos
\end_layout

\begin_layout Standard
Todos los tipos tienen un atributo especial llamado namevar.
 Este es el atributo usado para identificar univocamente un recurso en el
 sistema de destino.
 Si no se especifica un valor para el namevar, este valor es tomado por
 defecto según el título del recurso.
\end_layout

\begin_layout Standard
Ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
file { '/etc/passwd': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

owner => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

group => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

mode => 644 
\end_layout

\begin_layout Standard

\family typewriter
} 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En este código, 
\family typewriter
/etc/passwd
\family default
 es el título del recurso 
\emph on
file
\emph default
, otros códigos de Puppet pueden hacer referencia al recurso como File['/etc/pas
swd'] para declarar relación.
 Porque el path es el 
\emph on
namevar
\emph default
 para el tipo file y si no se le provee un valor, toma uno por defecto que
 es 
\emph on
/etc/passwd.
\end_layout

\begin_layout Standard

\series bold
Atributos
\series default
: A veces llamados parámetros, determinan el estado deseado para un recurso.
 Cualquiera de ellos modifica directamente el sistema (internamente, las
 llamadas “propiedades”) o afectan cómo el recurso se comporta.
 
\end_layout

\begin_layout Standard

\series bold
Proveedores (providers
\series default
): Implementan el mismo tipo de recursos en diferentes tipos de sistemas,
 ellos suelen hacer esto llamando a comandos externos.
 Aunque Puppet seleccionará automáticamente un proveedor apropiado por defecto,
 se lo puede sobrescribir con el atributo 
\emph on
provider
\emph default
.
 Por ejemplo, el recurso 
\emph on
package
\emph default
 de sistemas Red Hat tiene por defecto YUM como 
\emph on
provider
\emph default
, pero se puede especificar 
\family typewriter
provider => gem 
\family default
para instalar librerías de Ruby con gem.
 
\end_layout

\begin_layout Standard

\series bold
Características (features):
\series default
 Son habilidades que algunos proveedores pueden no soportar.
 Generalmente una característica corresponderá con algunos valores permitidos
 por un recurso de un atributo, por ejemplo, si un paquete soporta la caracterís
tica 
\emph on
purgeable
\emph default
, se puede especificar 
\family typewriter
ensure => purged 
\family default
para borrar los archivos de configuración instalados por el paquete.
\end_layout

\begin_layout Standard
Algunas de las referencias de tipo más importantes son las explicadas a
 continuación:
\end_layout

\begin_layout Itemize

\series bold
Cron:
\series default
 Instalar y manejar trabajos Cron.
 Todo Cron creado por Puppet requiere un comando y al menos un atributo
 de un periodo (horas, minutos,meses, etc).
 Mientras el nombre del Cron no es parte del trabajo actual, el nombre es
 almacenado en un comentario comenzando con 
\family typewriter
\emph on
#Puppet Name:
\family default
\emph default
.
 Ese comentario es usado para coincidir entadas crontab creadas por Puppet
 con un recurso Cron.
 
\end_layout

\begin_layout Itemize

\series bold
Exec:
\series default
 Ejecuta comandos externos.
 Cualquier comando en un recurso Exec debe poder correr múltiples veces
 sin causar daños.
 
\end_layout

\begin_layout Itemize

\series bold
File:
\series default
 El manejo de archivos incluye contenido, dueño, y permisos.
 El tipo archivo puede manejar archivos, directorios y enlaces simbólicos.
 
\end_layout

\begin_layout Itemize

\series bold
Group:
\series default
 Manejo de grupos.
 En muchas plataformas esto sólo puede crear grupos.
 La membresía de los grupos debe ser administrada por cada usuario individual
 .
 
\end_layout

\begin_layout Itemize

\series bold
Host:
\series default
 Instalar y manejar entradas de hosts.
 Para muchos sistemas, esas entradas deben estar solo en /etc/hosts, pero
 algunos SO tienen diferentes soluciones.
 
\end_layout

\begin_layout Itemize

\series bold
Mount:
\series default
 Maneja de filesystems montados, incluyendo agregar la información de montaje
 a la tabla de montaje.
 El comportamiento actual depende de el valor de el parámetro 
\emph on
ensure.
\end_layout

\begin_layout Itemize

\series bold
Notify:
\series default
 Envió de un mensaje arbitrario a el log del agente en tiempo de ejecución.
 
\end_layout

\begin_layout Itemize

\series bold
Package:
\series default
 Manejo de paquetes.
 Hay una bifurcación básica en los paquetes soportados correctamente: Algunos
 tipos de paquetes como yum y apt pueden recuperar sus propios archivos
 de paquetes, mientras que otros no pueden.
 Para esos paquetes, se puede usar el parámetro 
\emph on
source
\emph default
 para poner el archivo adecuado.
 
\end_layout

\begin_layout Itemize

\series bold
Resources:
\series default
 Este es un metatipo que puede controlar otro tipo de recursos.
 Cualquier metaparámetro especificado aquí sera pasado a los recursos generados,
 por lo que puede purgar recursos no administrados.
 
\end_layout

\begin_layout Itemize

\series bold
Service: 
\series default
Controla servicios en ejecución.
 El soporte de este recurso varía ampliamente según el concepto de servicio
 de la plataforma.
 
\end_layout

\begin_layout Itemize

\series bold
User: 
\series default
Administración de usuarios.
 
\end_layout

\begin_layout Subsubsection
Manifiests 
\end_layout

\begin_layout Standard
Un manifiesto o manifest, es un archivo de texto que contiene código Puppet
 y posee la extensión .pp.
 Para comprobar la sintaxis de un manifiesto se puede utilizar:
\end_layout

\begin_layout Standard

\family typewriter
puppet parser validate <manifiesto.pp> 
\end_layout

\begin_layout Standard
El parseador no retornará nada si no hay errores, en caso de que se detecte
 un error debe ser corregido antes de continuar.
 Si se trata de aplicar un manifiesto que no ha sido declarado, no cambiará
 nada en el sistema.
 Para ésto se debe crear un 
\family typewriter
.pp
\family default
 que contenga un sentencia:
\end_layout

\begin_layout Standard

\family typewriter
include módulo::clase
\end_layout

\begin_layout Standard
Antes de aplicar cambios en el sistema, se puede utilizar la bandera 
\family typewriter
–noop
\family default
 para compilar el catálogo (catálogo) y notificar los cambios que Puppet
 habría realizado si hubiera sido ejecutado sin 
\family typewriter
–noop
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
puppet apply --noop 
\end_layout

\begin_layout Subsubsection
Catálogos
\end_layout

\begin_layout Standard
Los manifiestos de Puppet pueden usar lógica condicional para describir
 muchas configuraciones de nodos como una.
 Antes de configurar un nodo, Puppet compila los manifiestos en un catálogo,
 el cual solo es válido para un único nodo y no contiene lógica ambigua.
\end_layout

\begin_layout Standard
Los catálogos son documentos estáticos los cuales contienen recursos y relacione
s.
 
\end_layout

\begin_layout Standard
En la arquitectura estándar maestro/agente, los nodos solicitan los catálogos
 al Puppet Server, el cual los compila cuando son solicitados.
 Los agentes mantienen en caché sus más recientes catálogos, si al pedir
 el catálogo, el master falla al compilarlo, ellos re-usaran su catálogo
 cacheado.
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
Una clase es un bloque de código Puppet con nombre.
 Una clase administrará generalmente un conjunto de recursos relacionados
 a una función simple o un componente del sistema.
 Las clases usualmente contienen otras clases; este anidamiento provee una
 forma estructurada de juntar funciones de clases diferentes como componentes
 de soluciones más grandes.
 Para utilizar una clase, se necesita definirla escribiendo una definición
 de clase y guardándola en un archivo manifiesto.
 Cuando Puppet se ejecuta, parseará este manifiesto y guardará la definición
 de clase; luego ésta puede ser declarada para aplicarla en los nodos de
 la infraestructura.
 En Puppet las clases son singleton, lo que quiere decir que una clase puede
 ser declarada sólo una vez en un nodo dado.
 Cuando se declara una clase:
\end_layout

\begin_layout Standard

\family typewriter
include módulo::clase
\end_layout

\begin_layout Standard

\family typewriter
módulo
\family default
 le indica a Puppet donde encontrar esa 
\family typewriter
clase
\family default
.
 Sin embargo, para la clase principal de un módulo, además de llevar el
 mismo nombre que el módulo mismo, Puppet reconoce el nombre especial del
 archivo '
\family typewriter
init.pp
\family default
' como el manifiesto que contendrá la clase principal de un módulo.
 
\end_layout

\begin_layout Subsubsection
Funciones
\end_layout

\begin_layout Standard
Hay dos tipos de funciones en Puppet, statements (declaraciones) y rvalues.
 Las statements no retornan argumentos, son utilizadas para hacer trabajos
 independientes como importar.
 Rvalues retornan valores y pueden ser usadas solo en un statement requiriendo
 un valor, como una asignación o una declaración case.
\end_layout

\begin_layout Standard
Las funciones se ejecutan en el Puppet master, no se ejecutan en el agente.
 Por lo tanto sólo tienen acceso a los comandos y datos disponibles en el
 nodo maestro.
\end_layout

\begin_layout Subsubsection
Metaparámetros
\end_layout

\begin_layout Standard
Los metaparámetros son atributos que trabajan con cualquier tipo de recurso,
 incluido los tipos personalizados y los tipos definidos.
\end_layout

\begin_layout Standard
En general, ellos afectan el comportamiento de Puppet en preferencia a el
 deseo del estado del recurso.
 
\end_layout

\begin_layout Standard
Los metaparámetros hacen cosas como agregar metadata a un recurso (alias,
 tag), poner límites cuando el recurso debe ser sincronizado (require, schedule,
 etc.), evita que Puppet realice cambios (noop), y cambia la verborrea del
 log (loglevel).
\end_layout

\begin_layout Subsubsection
Definición de nodos
\end_layout

\begin_layout Standard
Una definición o declaración de nodo es un bloque de código Puppet que sólo
 será incluido en catálogos de nodos que coincidan.
 Esta característica permite asignar configuraciones específicas a nodos
 específicos.
\end_layout

\begin_layout Standard
Las declaraciones de nodos sólo coinciden con los nombres de los nodos.
 Por defecto, el nombre de un nodo es su 
\emph on
certname.
\end_layout

\begin_layout Standard
# node 'www1.example.com' { include common include apache include squid }
 node 'db1.example.com' { include common include mysql }
\end_layout

\begin_layout Paragraph
Ubicación
\end_layout

\begin_layout Standard
Las definiciones de los nodos deben estar en el manifiesto principal.
 Éste puede ser un archivo o un directorio conteniendo muchos archivos.
\end_layout

\begin_layout Standard

\family typewriter
# /etc/puppetlabs/code/enviroment/production/manifests/site.pp 
\end_layout

\begin_layout Standard

\family typewriter
node 'www1.example.com' {
\end_layout

\begin_layout Standard

\family typewriter
include common
\end_layout

\begin_layout Standard

\family typewriter
include apache
\end_layout

\begin_layout Standard

\family typewriter
include squid 
\end_layout

\begin_layout Standard

\family typewriter
} 
\end_layout

\begin_layout Standard

\family typewriter
node 'db1.example.com' {
\end_layout

\begin_layout Standard

\family typewriter
include common 
\end_layout

\begin_layout Standard

\family typewriter
include mysql 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
En este ejemplo, solo el primero nodo obtendrá las clases 
\emph on
apache
\emph default
 y 
\emph on
squid
\emph default
 mientas que el segundo tendrá 
\emph on
mysql
\emph default
.
 Ambos recibirán la clase 
\emph on
common
\emph default
.
\end_layout

\begin_layout Paragraph
Nombramiento
\end_layout

\begin_layout Standard
Una declaración de nodo debe realizarse según:
\end_layout

\begin_layout Itemize
Un string entre comillas conteniendo sólo letras, números, guiones bajos,
 guiones medios y puntos.
\end_layout

\begin_layout Itemize
Expresiones regulares.
\end_layout

\begin_layout Itemize
La palabra 
\emph on
default, 
\emph default
sin comillas.
\end_layout

\begin_layout Standard
Se pueden utilizar listas de nombres separados por comas para crear grupos
 de nodos son una sola declaración de nodo:
\end_layout

\begin_layout Standard

\family typewriter
node 'www1.example.com', 'www2.example.com', 'www3.example.com' { 
\end_layout

\begin_layout Standard

\family typewriter
include common 
\end_layout

\begin_layout Standard

\family typewriter
include apache, squid 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Paragraph
El nodo default
\end_layout

\begin_layout Standard

\color red
Si ninguna declaración de nodo es macheada o no puede ser encontrada, el
 nodo 
\emph on
default 
\emph default
será utilizado.
\end_layout

\begin_layout Paragraph
Expresiones regulares
\end_layout

\begin_layout Standard
Pueden ser utilizadas como nombres de nodo.
 Este es otro método para escribir una sola definición de nodo que coincida
 con múltiples nodos.
\end_layout

\begin_layout Subparagraph
Coincidencias
\end_layout

\begin_layout Standard
Un nodo dado sólo obtendrá los contenidos de una definición de nodo, incluso
 si dos declaraciones de nodo pueden coincidir con el nombre del mismo.
 Puppet realizará las verificaciones para decidir cual definición utilizar:
\end_layout

\begin_layout Enumerate
Si hay una definición de nodo que contenga el nombre exacto del nodo, entonces
 utilizará esta.
\end_layout

\begin_layout Enumerate
Si hay una expresión regular que coincida cone el nombre del nodo, entonces
 utilizará esta.
\end_layout

\begin_layout Enumerate
Si el nombre de nodo es del tipo FQDN (Fully Qualified Domain Name), Puppet
 cortará el grupo final y comenzará nuevamente desde el punto uno.
\end_layout

\begin_layout Enumerate
Puppet utilizará el nodo default.
\end_layout

\begin_layout Subsubsection
Node group 
\end_layout

\begin_layout Standard
Los grupos de nodos o node groups permiten segmentar todos los nodos de
 la infraestructura en grupos separados configurables basados en la información
 colectada por 'facter tool'.
\end_layout

\begin_layout Subsection

\color red
Creación del sistema de orquestación Puppet.
\end_layout

\begin_layout Standard

\color red
Puppet usualmente corre bajo la arquitectura cliente-servidor, pero además,
 puede correr en una arquitectura autocontenida.
 La decisión determina que paquetes serán instalados y que configuraciones
 extra necesarias se harán.
 
\end_layout

\begin_layout Standard

\color red
Se toma la opción de utilizar la arquitectura cliente-servidor.
 Se debe completar la instalación y configuración de todos los puppet servers
 antes de instalar cualquier agente.
 El servidor necesariamente debe correr en un sistema basado en Unix.
\end_layout

\begin_layout Subsubsection

\color red
Requerimientos de sistema y chequeo de versión de sistema operativo
\end_layout

\begin_layout Itemize

\color red
Hardware: El agente Puppet no tiene requerimientos particulares de hardware
 y corre prácticamente en cualquier computadora, sin embargo, el servidor
 es un recurso intensivo y debe ser instalado en un servidor robusto y dedicado.
 Como mínimo, el servidor debe tener dos procesadores y al menos 2GB de
 RAM, para administrar eficientemente mil nodos, debe poseer entre 2 y 4
 procesadores y 4GB de RAM.
 
\end_layout

\begin_layout Itemize

\color red
Sistemas operativos soportados: Hay una gran variedad de distribuciones
 Linux que soportan puppet, entre ellas destaca la utilizada para la realización
 del Proyecto, CentOS 7.
 
\end_layout

\begin_layout Itemize

\color red
Ruby: Se soportan varias versiones de Ruby, pero se recomienda el uso de
 las versiones 2.1.x.
\end_layout

\begin_layout Itemize

\color red
Librerías obligatorias: Facter 2.4.3 o posterior, Hiera 2.0.0 o posterior, json
 gem cualquier versión moderna, rgen gem 0.6.6 o posterior.
\end_layout

\begin_layout Itemize

\color red
Librerías opcionales: msgpack gem es requerido si se utiliza msgpack racionaliza
ción.
\end_layout

\begin_layout Subsubsection

\color red
Chequeo de la configuración de red
\end_layout

\begin_layout Standard

\color red
En un agent/master deployment se debe preparar la red para el tráfico de
 puppet.
 
\end_layout

\begin_layout Itemize

\color red
Firewall: En el desarrollo de este pryecto se trabajo sin firewall, por
 lo tanto este debe estar desactivado.
\end_layout

\begin_layout Itemize

\color red
Resolución de nombres: Cada nodo debe tener un nombre único.
\end_layout

\begin_layout Standard

\color red
Para cumplir con este ultimo apartado, se decidió editar el archivo 
\family typewriter
/etc/hosts
\family default
 de cada maquina virtual creada utilizando cobbler para añadir el host del
 puppetserver que corresponde a la primer dirección IP de la red virtual
 creada por KVM.
 Así mismo, como el servidor puppet también tiene la necesidad de conocer
 a que dirección IP corresponde a cada maquina, se realizo un pequeño codigo
 de python que es capaz de obtener la dirección IP de una maquina en particular
 revisando el archivo 
\family typewriter
/var/lib/dhcpd/dhcpd.leases
\family default
.
 Este archivo, es utilizado por el servidor DHCP para saber a que maquina
 corresponde cada dirección IP.
\end_layout

\begin_layout Subsubsection

\color red
Instalación de puppetserver
\end_layout

\begin_layout Standard

\color red
Primero se debe instalar puppetserver.
 Para ello habilitar los paquetes de los repositorios de Puppet Labs:
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo rpm -ivh https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
\family default
 
\end_layout

\begin_layout Standard

\family typewriter
\color red
yum install puppetserver
\end_layout

\begin_layout Standard

\color red
No se debe iniciar el servicio aún, dado que los no se ha configurado correctame
nte.
\end_layout

\begin_layout Standard

\color red
Como se menciono, puppetserver tiene ciertos requerimientos de HW donde
 se destaca los 2GB de memoria RAM pero esto no es exactamente así, lo que
 realmente sucede es que esa es la cantidad de memoria 
\begin_inset Quotes eld
\end_inset

recomendada
\begin_inset Quotes erd
\end_inset

 para que funcione correctamente un sistema en producción y puppet mientras
 exista ese HW se 
\begin_inset Quotes eld
\end_inset

apropiara
\begin_inset Quotes erd
\end_inset

 de el.
 
\end_layout

\begin_layout Standard

\color red
Si lo que se desea es experimentar con un pequeño servidor puppet y unos
 pocos clientes se puede configurar para que utilice menor cantidad de memoria,
 esto se hace editando el archivo 
\family typewriter
/etc/sysconfig/puppetserver y modificando la siguiente linea:
\end_layout

\begin_layout Standard

\family typewriter
\color red
# Modify this if you'd like to change the memory allocation, enable JMX,
 etc 
\end_layout

\begin_layout Standard

\family typewriter
\color red
JAVA_ARGS="-Xms2g -Xmx2g"
\end_layout

\begin_layout Standard

\color red
Si se desea por ejemplo, utilizar 1536MB se debe reemplazar 2g por 1536m:
\end_layout

\begin_layout Standard

\family typewriter
\color red
JAVA_ARGS="-Xms1536m -Xmx1536m"
\end_layout

\begin_layout Subsubsection

\color red
Configuraciones para los servidores:
\end_layout

\begin_layout Standard

\color red
Básicas:
\end_layout

\begin_layout Itemize

\color red
dns_alt_names: Una lista de los hostnames de los servidores permitidos para
 usar cuando actúan como “masters environment”.
\end_layout

\begin_layout Itemize

\color red
path: Indica la ubicación del entorno.
 
\end_layout

\begin_layout Itemize

\color red
basemodulepath: Una lista de las ubicaciones que contienen módulos que pueden
 ser usados en todos los entornos.
\end_layout

\begin_layout Itemize

\color red
manifest: El principal punto de entrada para compilar los catálogos.
 Por defecto es “site.pp”.
\end_layout

\begin_layout Itemize

\color red
reports: Controlador de reportes que se usa.
\end_layout

\begin_layout Standard

\color red
Configuraciones de CA:
\end_layout

\begin_layout Itemize

\color red
ca: Si actúa como un autoridad de certificación.
\end_layout

\begin_layout Itemize

\color red
ca_ttl: Indica por cuánto tiempo son válidos los certificados.
\end_layout

\begin_layout Itemize

\color red
autosign: Indica si los certificados deben ser firmados de forma automática
 o manual.
\end_layout

\begin_layout Standard

\color red
El archivo de configuración utilizado en la realización del proyecto es
 el siguiente:
\end_layout

\begin_layout Standard

\family typewriter
\color red
[master] 
\end_layout

\begin_layout Standard

\family typewriter
\color red
vardir = /opt/puppetlabs/server/data/puppetserver 
\end_layout

\begin_layout Standard

\family typewriter
\color red
logdir = /var/log/puppetlabs/puppetserver 
\end_layout

\begin_layout Standard

\family typewriter
\color red
rundir = /var/run/puppetlabs/puppetserver 
\end_layout

\begin_layout Standard

\family typewriter
\color red
pidfile = /var/run/puppetlabs/puppetserver/puppetserver.pid 
\end_layout

\begin_layout Standard

\family typewriter
\color red
codedir = /etc/puppetlabs/code 
\end_layout

\begin_layout Standard

\family typewriter
\color red
autosign = true 
\end_layout

\begin_layout Standard

\family typewriter
\color red
runinterval = 2m
\end_layout

\begin_layout Subsubsection

\color red
Instalar el paquete puppet-agent
\end_layout

\begin_layout Standard

\color red
Según sea el sistema operativo sobre el que se instalará, se tiene:
\end_layout

\begin_layout Standard

\color red
Centos y derivados: Del mismo modo que para el servidor, es necesario añadir
 el repositorio y luego instalar:
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo rpm -Uvh https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
 
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo yum install puppet-agent
\end_layout

\begin_layout Standard

\color red
Ubuntu y derivados: Habilitar el repositorio según sea el caso como el siguiente
 ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
\color red
wget https://apt.puppetlabs.com/puppetlabs-release-pc1-wheezy.deb
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo dpkg -i puppetlabs-release-pc1-wheezy.deb
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo apt-get update
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo apt-get install puppet-agent
\end_layout

\begin_layout Standard

\color red
Windows: Descargar el paquete instalador desde 
\family typewriter
https://downloads.puppetlabs.com/windows/?_ga=1.232745247.1868267244.1457442550
\end_layout

\begin_layout Itemize

\color red
Arquitectura x64: Se recomienda el uso de puppet-agent-<VERSION>-x64.msi
 o puppet-agent-<VERSION>-x86.msi.
 
\end_layout

\begin_layout Itemize

\color red
Arquitectura x86: Debe utilizar puppet-agent-<VERSION>-x86.msi.
 
\end_layout

\begin_layout Standard

\color red
La instalación puede ser gráfica o automática.
 Para la última, desde el cuadro “Ejecutar”:
\end_layout

\begin_layout Standard

\color red
msiexec /qn /norestart /i puppet-agent-<VERSION>-x64.msi PUPPET_MASTER_SERVER=pup
pet
\end_layout

\begin_layout Standard

\color red
Este tipo de instalación por comando tiene la ventaja de proveer una mayor
 cantidad de opciones a editar que en la instalación gráfica.
 La opción que se destaca es PUPPET_AGENT_ACCOUNT_USER el cual permite indicar
 que usuario es que ejecutara los manifiestos de puppet agent en windows.
 Esta es una opción importante, porque el usuario debe poseer permisos de
 administrador para poder llevar a los recursos al estado deseado.
\end_layout

\begin_layout Standard

\color red
No se debe iniciar el servicio aún.
 
\end_layout

\begin_layout Standard

\color red
Por defecto, el valor del hostname de servidor es puppet, si se nombró de
 otra forma a la máquina servidora del puppet server, se debe editar esto.
\end_layout

\begin_layout Subsubsection

\color red
Configuraciones para los agentes
\end_layout

\begin_layout Standard

\color red
Básicas:
\end_layout

\begin_layout Itemize

\color red
server: El nombre del nodo maestro al cual se le pedirán los manifiestos.
 Por defecto es puppet 
\end_layout

\begin_layout Itemize

\color red
certname: Nombre con el cual el nodo agente pide el certificado y se presenta
 al servidor.
 
\end_layout

\begin_layout Itemize

\color red
environment: Indica el entorno solicitado cuando se contacta al maestro.
 De cualquier forma, el maestro puede configurarse para ignorar esta configuraci
ón.
 
\end_layout

\begin_layout Standard

\color red
Comportamiento de la ejecución: 
\end_layout

\begin_layout Itemize

\color red
noop: Si está habilitado, el agente no realizará ningún trabajo, en cambio
 mirará qué cambios tendría que realizar y lo reporta al servidor.
 
\end_layout

\begin_layout Itemize

\color red
priority: Permite asignar el valor “nice” para evitar que otras aplicaciones
 de la CPU no mueran por inanición mientras se aplican los catálogos.
\end_layout

\begin_layout Itemize

\color red
report: Indica si se deben enviar reportes, por defecto es “true” .
\end_layout

\begin_layout Itemize

\color red
tags: Limita a los agentes a correr recursos con ciertas etiquetas.
 
\end_layout

\begin_layout Itemize

\color red
usecacheonfailure: Se utiliza para tomar el último buen catálogo si el master
 no posee uno bueno.
 
\end_layout

\begin_layout Itemize

\color red
prerun_command y postrun_command: Comandos que se desean correr de cada
 lado de puppet
\end_layout

\begin_layout Standard

\color red
Comportamiento del servicio: 
\end_layout

\begin_layout Itemize

\color red
runinterval: Indica cada cuanto tiempo el agente se contacta con el servidor
 para pedirle los manifiestos.
 Por defecto es 30 minutos.
 
\end_layout

\begin_layout Itemize

\color red
waitforcert: Indica al agente que persista si no puede obtener su certificado.
 Por defecto está habilitado.
 
\end_layout

\begin_layout Standard

\color red
El archivo de configuración utilizado en la realización del proyecto es
 el siguiente:
\end_layout

\begin_layout Standard

\family typewriter
\color red
[main]
\end_layout

\begin_layout Standard

\family typewriter
\color red
logdir = /var/log/puppet
\end_layout

\begin_layout Standard

\family typewriter
\color red
rundir = /var/run/puppet
\end_layout

\begin_layout Standard

\family typewriter
\color red
ssldir = $vardir/ssl
\end_layout

\begin_layout Standard

\family typewriter
\color red
certname = $HOSTNAME #Aquí nos valemos de una variable que el mismo Snippet
 es capaz de resolver para insertar el hostname de la maquina.
\end_layout

\begin_layout Standard

\family typewriter
\color red
server = puppet
\end_layout

\begin_layout Standard

\family typewriter
\color red
runinterval = 2m
\end_layout

\begin_layout Standard

\family typewriter
\color red
[agent]
\end_layout

\begin_layout Standard

\family typewriter
\color red
classfile = $vardir/classes.txt
\end_layout

\begin_layout Standard

\family typewriter
\color red
localconfig = $vardir/localconfig
\end_layout

\begin_layout Subsubsection

\color red
Ejecutar puppet
\end_layout

\begin_layout Standard

\color red
Para iniciar el servicio de puppet una vez configurado correctamente basta
 con iniciarlo a través de systemctl
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo systemctl start puppetserver
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo systemctl enable puppetserver
\end_layout

\begin_layout Standard

\color red
En el caso de los clientes, tenemos variedad de comandos para iniciar los
 agentes de puppet puesto que son diferentes los SO donde funcionan.
\end_layout

\begin_layout Standard

\color red
En el caso de Centos es similar:
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo systemctl start puppet
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo systemctl enable puppet
\end_layout

\begin_layout Standard

\color red
En el caso de Ubuntu se debe ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo /opt/puppetlabs/bin/puppet resource service puppet ensure=running enable=tr
ue
\end_layout

\begin_layout Standard

\color red
Finalmente en windows, puede hacer por consola o por interfaz gráfica.
\end_layout

\begin_layout Standard

\color red
Cualquier sea el SO que ejecute el agente de puppet, lo primero que hará
 es comunicarse con su servidor, esto podrá hacerlo buscando al dirección
 IP del servidor 
\begin_inset Quotes eld
\end_inset

puppet
\begin_inset Quotes erd
\end_inset

 como se lo llamo en el archivo de configuración en el archivo hosts que
 su ubicación difiere en los sistemas Linux y los Windows.
\end_layout

\begin_layout Standard

\color red
Se genera un certificado sll y el servidor puede firmarlo automáticamente,
 como en la configuración de este proyecto o de forma manual.
\end_layout

\begin_layout Standard

\color red
Para corroborar la creación y firmado del servicio:
\end_layout

\begin_layout Standard

\family typewriter
\color red
sudo puppet cert list --all 
\end_layout

\begin_layout Section
Automatización de Windows 7
\end_layout

\begin_layout Standard
La instalación automatizada de Windows 7 requiere su preparación sobre un
 sistema Windows 7 pero su despliegue se realiza desde el servidor Cobbler,
 bajo Linux.
\end_layout

\begin_layout Subsection
El lado de Windows
\end_layout

\begin_layout Standard
Para automatizar la instalación de Windows 7, utilizando el método de imágen
 estándar personalizada, se realiza en siete pasos principales.
 Para ello es necesario contar con:
\end_layout

\begin_layout Itemize

\series bold
Máquina técnica:
\series default
 Con este término, Microsoft se refiere a un sistema Windows utilizado para
 correr las herramientas y otras operaciones que forman parte de la automatizaci
ón automatizada.
 En esta máquina es necesario contar con cualquier versión de Windows 7
 que cuente con las herramientas de WAIK (Windows Automated Installation
 Kit).
\end_layout

\begin_layout Itemize

\series bold
Máquina de referencia:
\series default
 Con este término, Microsoft se refiere al equipo sobre el cual se instalará
 el sistema operativo a partir del cual se extraerá la imágen personalizada
 con las configuraciones y programas deseados.
\end_layout

\begin_layout Itemize

\series bold
Windows Automated Installation Kit:
\series default
 El kit de instalación automatizada de Windows es un conjunto de herramientas
 y documentación compatible con la configuración y la implementación de
 los sistemas operativos Windows.
 Mediante el WAIK, puede automatizar las instalaciones de Windows, capturar
 imágenes de Windows con ImageX, configurar y modificar imágenes usando
 Administración y mantenimiento de imágenes de implementación (DISM), crear
 imágenes de Windows PE, entre otras características.
\end_layout

\begin_layout Itemize

\series bold
Imágen de instalación de Windows 7:
\series default
 Ya sea un DVD o un archivo ISO que provea la fuente de instalación del
 sistema operativo.
\end_layout

\begin_layout Standard
La siguiente tabla contiene una columna para cada equipo.
 Los pasos de la columna en la máquina técnica se realizan en su ese equipo.
 Los pasos de la columna del equipo de referencia se realizan en el equipo
 en el que se cree la imágen personalizada.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="1.2cm">
<column alignment="center" valignment="top" width="6cm">
<column alignment="center" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Paso
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Máquina técnica
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Máquina referencia
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instalar WAIK 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Crear un disco de inicio del Entorno de Preinstalación de Windows (WinPE)
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instalar y personalizar Windows 7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Generalizar el equipo de referencia para preparar la imágen para la duplicación
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Capturar el equipo de referencia a un archivo de imágen mediante ImageX
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Crear archivo Autounattend.xml 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Crear nuevos medios de instalación de Windows 7 para la imágen personalizada
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Pasos automatización Windows 7
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Instalar WAIK
\end_layout

\begin_layout Standard
Desde la página oficial de Microsoft descargar el archivo KB3AIK_EN.iso,
 grabarlo en un DVD o montarlo en una unidad virtual e instalarlo.
\end_layout

\begin_layout Subsubsection
WinPE
\end_layout

\begin_layout Standard
WinPE o Windows Preinstallation Environment es un Sistema operativo mínimo
 designado para preparar una computadora para la instalación de Windows.
 Puede ser utilizado para iniciar una computadora sin sistema operativo,
 para particionar y formatear discos rígidos, para copiar imágenes de discos
 y para iniciar la instalación de Windows desde una ubicación compartida
 en la red.
 WinPE se carga directamente en memoria y permite utilizar herramientas
 como ImageX para capturar, modificar y crear imágenes de instalación basadas
 en archivos.
\end_layout

\begin_layout Standard
Para crear una imágen ISO de WinPE es necesario ejecutar Deployment Tools
 Command Prompt como administrador.
\end_layout

\begin_layout Standard
Se debe copiar a una ubicación elegida los archivos necesarios.
 Como se ha utilizado una versión de 64 bits se especifica amd64, si no
 i386.
\end_layout

\begin_layout Standard

\family typewriter
copype amd64 d:
\backslash
path-del-directorio
\backslash
winpe 
\end_layout

\begin_layout Standard
Montar el archivo .WIM con:
\end_layout

\begin_layout Standard

\family typewriter
imagex /mountrw d:
\backslash
path-del-directorio
\backslash
winpe
\backslash
winpe.wim 1 d:
\backslash
path-del-directorio
\backslash
winpe
\backslash
mount 
\end_layout

\begin_layout Standard
Cuando se carga en memoria el entorno de preinstalación, es ejecutado un
 script llamado Startnet.cmd el cual de forma predeterminada inicia Wpeinit.exe,
 que precisamente sirve para instalar dispositivos Plug and Play, procesar
 configuraciones de Autounattend.xml y cargar recursos de red.
 Se debe asegurar que se incluye una llamada a wpeinit en el script Startnet.cmd
 personalizado:
\end_layout

\begin_layout Standard

\emph on
d:
\backslash
 path-del-directorio 
\backslash
winpe
\backslash
mount
\backslash
Windows
\backslash
System32 
\backslash
startnet.cmd
\end_layout

\begin_layout Standard
Utilizar un editor de texto y dejarlo como se muestra a continuación, reemplazan
do los valores correspondientes:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
wpeinit 
\end_layout

\begin_layout Standard

\family typewriter
echo Conectando con servidor...
 
\end_layout

\begin_layout Standard

\family typewriter
net use y: 
\backslash

\backslash
IP_del_servidor_Cobbler
\backslash
entrada_SAMBA 
\end_layout

\begin_layout Standard

\family typewriter
y: 
\end_layout

\begin_layout Standard

\family typewriter
echo Preparando instalacion...
 
\end_layout

\begin_layout Standard

\family typewriter
setup.exe /unattend:Autounattend.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Una vez modificado los valores del script, desmontar winpe.wim.
 Para ello es necesario cerrar el explorador de Windows y cualquier programa
 que esté haciendo uso de directorio anterior, caso contrario dará error.
 Luego:
\end_layout

\begin_layout Standard

\family typewriter
imagex /unmount d:
\backslash
path-del-directorio
\backslash
winpe
\backslash
mount /commit 
\end_layout

\begin_layout Standard
Se copia entonces winpe.wim al directorio renombrándolo como boot.wim:
\end_layout

\begin_layout Standard

\family typewriter
copy d:
\backslash
path-del-directorio
\backslash
winpe
\backslash
winpe.wim d:
\backslash
path-del-directorio
\backslash
winpe
\backslash
ISO
\backslash
sources
\backslash
boot.wim 
\end_layout

\begin_layout Standard
Por último es necesario crear una imágen ISO de WinPE.
\end_layout

\begin_layout Standard

\family typewriter
oscdimg -nt -m -h -bd:
\backslash
path-del-directorio
\backslash
winpe
\backslash
etfsboot.com d:
\backslash
path-del-directorio
\backslash
winpe
\backslash
ISO d:
\backslash
path-del-directorio
\backslash
winpe
\backslash
winpe_cobbler_amd64.iso 
\end_layout

\begin_layout Standard
Las opciones especificadas son las siguientes: 
\end_layout

\begin_layout Standard

\series bold
-nt:
\series default
 Permite nombres largos de archivo que sean compatibles con Windows NT 3.51.
\end_layout

\begin_layout Standard

\series bold
-m:
\series default
 Pasa por alto el límite de tamaño máximo de una imágen.
\end_layout

\begin_layout Standard

\series bold
-h: 
\series default
Incluye todos los directorios y archivos ocultos bajo el d:
\backslash
path-del-directorio
\backslash
 para esta imágen.
 
\end_layout

\begin_layout Standard

\series bold
-b:
\series default
 Esta opción se utiliza para especificar el archivo que se escribirá en
 el sector de arranque del disco.
 No debe existir espacio alguno entre esta opción y el valor pasado.
\end_layout

\begin_layout Standard

\series bold
-u2
\series default
: Genera una imágen que sólo incluye el sistema de archivos UDF.
 Los sistemas que no sean capaces de leer UDF, sólo verán un archivo de
 texto predeterminado donde se alerta al usuario de que esa imágen sólo
 está disponible en equipos compatibles con UDF.
 Esta opción no puede combinarse con las opciones -nt.
\end_layout

\begin_layout Subsubsection
Instalar y personalizar Windows 7
\end_layout

\begin_layout Standard
Una máquina de referencia tiene una instalación personalizada de Windows
 que se planea replicar en uno o más computadoras.
 Se puede crear utilizando un DVD o archivo ISO de Windows.
\end_layout

\begin_layout Standard
Este punto conviene realizarlo manualmente y de la forma usual.
 Sin embargo, cuando en el proceso de instalación, se llega a la pantalla
 de bienvenida de Windows (diálogo de creación de usuario y hostname) se
 debe presionar 
\emph on
Ctrl + Shift + F3
\emph default
 para ingresar en modo auditoría.
 Ahora la máquina debería reiniciarse e ingresar automáticamente en una
 cuenta temporal en modo administrador.
 Esto permanecerá así por más que se reinicie el equipo hasta que el comando
 Sysprep sea ejecutado luego de realizar todas las actualizaciones, los
 controladores de dispositivo e instalación de las aplicaciones.
\end_layout

\begin_layout Standard
Cada vez que sea reiniciado el equipo estando en este modo, aparecerá un
 cuadro de diálogo del modo auditoría.
 Simplemente ignorarlo hasta terminar de preparar la imágen.
\end_layout

\begin_layout Standard
Para pasarle los programas a instalar, alojados en el servidor en 
\emph on
/windows/PROGRAMAS/
\emph default
, desde la máquina de referencia ir a 
\emph on
Equipo → Conectar a unidad de red
\emph default
 e ingresar la dirección IP del servidor con el formato:
\end_layout

\begin_layout Standard

\family typewriter

\backslash

\backslash
IP_del_servidor_Cobbler
\backslash
entrada_SAMBA
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows samba share 1.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Paso de archivos a Windows
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows samba share 2.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Paso de archivos a Windows
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows samba share 3.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Paso de archivos a Windows
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Generalizar el equipo de referencia para preparar la imágen 
\end_layout

\begin_layout Standard
En este paso, se generaliza la imágen y se prepara para su inicio en Bienvenida
 de Windows después de haberla instalado en cada equipo.
 Al generalizar la imágen, se elimina de ella la información que depende
 de hardware, se restablece el temporizador de activación y se limpia Windows
 7 para que se pueda duplicar la imágen en otros equipos.
\end_layout

\begin_layout Standard
Para esto se hace uso de la herramienta Sysprep, la cual limpia las configuracio
nes específicas de usuario y del hardware.
\end_layout

\begin_layout Standard
De forma gráfica, cuando inicia el sistema operativo en modo auditoría,
 Windows 7 ejecuta Sysprep de forma automática.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows modo auditoria pantalla sysprep.png
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Modo auditoría
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
En la lista Acción de limpieza del sistema, seleccionar Iniciar la configuración
 rápida (OOBE) del sistema.
\end_layout

\begin_layout Itemize
Activar la casilla Generalizar.
\end_layout

\begin_layout Itemize
En la lista Opciones de apagado, seleccionar Apagar.
\end_layout

\begin_layout Itemize
Aceptar para ejecutar Sysprep y apagar el equipo.
\end_layout

\begin_layout Standard
En este caso particular se decidió realizar la generalización del sistema
 por consola.
 Para ello es necesario cargar un WinPE.iso sin modificaciones.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image capture 1.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Carga WinPE.iso para extraer imágen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image capture 2.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Prioridad de inicio en máquina virtual
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Desde la consola, ejecutar por línea de comando desde C
\emph on
:
\backslash
Windows
\backslash
System32
\backslash
Sysprep
\backslash
:
\end_layout

\begin_layout Standard

\family typewriter
sysprep /generalize /oobe /shutdown
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image capture 4.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Ejecución sysprep
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Donde las opciones más importantes son:
\end_layout

\begin_layout Standard

\series bold
/generalize:
\series default
 Prepara a la instalación de Windows para crear una imágen.
 Si esta opción es especificada, toda la información única del sistema es
 removida.
 El SID (ID de Seguridad) se resetea, cualquier punto de restauración que
 exista es quitado y todos los logs son eliminados.
 La próxima vez que la computadora inicia,la fase de configuración especial
 es ejecutada y se asigna un nuevo SID y el reloj de activación de Windows
 se resetea si no ha sido reseteado ya tres veces, esto es, este proceso
 no puede repetirse más de tres veces por instalación de Windows.
 En ese caso, se debe comenzar con una nueva instalación desde cero.
\end_layout

\begin_layout Standard

\series bold
/oobe: 
\series default
El término OOBE significa Out Of Box Experience y es la experiencia que
 un usuario tiene cuando se prepara para usar por primera vez un producto.
 Cuando esta opción es seleccionada, reicinia el quipo en modo Bienvenida
 de Windows.
 Este modo permite a los usuarios personalizar el sistema operativo, crear
 cuentas de usuario, cambiar el hostname y demás.
 Cualquier configuración pasada al oobeSystem por medio de un archivo de
 respuestas de instalación es procesada inmediatamente antes que la Bienvenida
 de Windows inicie.
\end_layout

\begin_layout Standard

\series bold
/shutdown: 
\series default
Apaga la máquina luego que el comando sysprep finaliza.
\end_layout

\begin_layout Standard

\series bold
/unattend:answerfile: 
\series default
Aplica las configuraciones dentro de un archivo de respuestas de instalación
 sobre el sistema operativo durante una instalación desatendida; answerfile
 especifíca el path y el nombre del archivo que contiene las respuestas.
 Esta opción se puede ignorar, ya que como se verá más adelante basta con
 agregar este archivo en el directorio principal de instalación para que
 sea tomado por el instalador de Windows.
\end_layout

\begin_layout Standard
A esta altura del proceso, ha instalado Windows 7 en el equipo de referencia
 y está listo para capturar una imágen del mismo.
\end_layout

\begin_layout Subsubsection
Capturar el equipo de referencia 
\end_layout

\begin_layout Standard
En este paso se captura una imágen de la máquina de referencia utilizando
 la herramienta ImageX, que está en el WinPE anteriormente creado.
 La imágen será guardada en el directorio compartido SAMBA.
 Se carga nuevamente el disco WinPE y se obtiene una consola.
 
\end_layout

\begin_layout Standard
Verificar que la máquina ve al servidor que tiene SAMBA configurado y corroborar
 que se tiene acceso a la ubicación compartida:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
net use y: 
\backslash

\backslash
IP_del_servidor_Cobbler
\backslash
entrada_SAMBA 
\end_layout

\begin_layout Standard

\family typewriter
y:
\end_layout

\begin_layout Standard

\family typewriter
dir
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Verificar la letra asignada al disco WinPE, usualmente es 
\emph on
e:
\emph default
 y verificar la letra de la partición donde está instalado Windows ya personaliz
ado, usualmente 
\emph on
c:
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image capture 5.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Verificación de letras de unidad
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Desde la unidad que contiene a WinPE:
\end_layout

\begin_layout Standard

\family typewriter
e:
\backslash
imagex.exe /capture d y:
\backslash
windows
\backslash
imagenPersonalizada.wim "Win7-Personalizado" /verify
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image capture 6.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
ImageX capturando imágen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Donde se tiene:
\end_layout

\begin_layout Standard

\series bold
/capture c:
\series default
 Indica al programa que se quiere capturar la imagen ubicada en esa unidad
 de partición.
\end_layout

\begin_layout Standard

\series bold
y:
\backslash
windows
\backslash
imagenPersonalizada.wim 
\series default
Es el path completo donde se guardará la imagen en SAMBA.
\end_layout

\begin_layout Standard

\series bold
"Win7-Personalizado"
\series default
 Es una etiqueta para el archivo imagen creado.
\end_layout

\begin_layout Standard

\series bold
/verify 
\series default
Indica al programa que se desea verificar la consistencia de la imagen creada.
\end_layout

\begin_layout Subsubsection
Autounattend.xml
\end_layout

\begin_layout Standard
El archivo 
\emph on
Autounattend.xml 
\emph default
es donde se guardan los valores correspondientes a los diálogos de instalación
 del sistema operativo elegido.
 Ítems como creación de cuentas de usuario, idioma, configuraciones regionales,
 configuraciones de red, particionado de discos, etc.
 son los que se automatizarán.
 Para generarlo, una vez instalado el WAIK, se debe abrir el modo Administrador
 el programa Windows System Image Manager desde el menú Inicio.
\end_layout

\begin_layout Standard
Bajo la sección 
\emph on
Windows Image
\emph default
 seleccionar 
\emph on
Select a Windows image or catalog file
\emph default
.
 En este punto se debe buscar en el directorio de la imagen del sistema
 operativo ya descomprimida, un archivo 
\emph on
.clg
\emph default
 que en este caso particular es 
\emph on
install_Windows 7 ULTIMATE.clg
\emph default
.
 Acto seguido crear el archivo de respuestas de instalación 
\emph on
Create a New Answer File
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image manager en blanco.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Windows System Image Manager 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se muestra a continuación una configuración personalizada completa utilizando
 Windows AIK.
\end_layout

\begin_layout Standard
Se ha configurado la entrada de texto, interfaz gráfica y ayuda del sistema
 en idioma español.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 1.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Idioma y teclado.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 2.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Idioma .
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se ha configurado el firewall para que esté habilitado, valor por defecto.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 3.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Firewall activado por defecto.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se han configurado los discos para que existan dos particiones.
 Una donde se instalará el MBR y otra donde se copiarán los archivos del
 sistema operativo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 4.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Discos.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 5.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Configuración discos.
 Disco 0.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Partición de 300 MB, donde será instlado el MBR.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 6.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Discos.
 Particionamiento.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Partición que utilizará el espacio restante del disco, donde se copiarán
 los archivos de Windows.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 7.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Discos.
 Particionamiento.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Formato de la partición.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 8.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Discos.
 Particionamiento.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 9.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Discos.
 Particionamiento.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 10.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Instalación del SO.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

En el caso de contar con una imágen de instalción multiversión, Windows
 Home, Basic, Professional y Ultimate y/o con ambas arquitecturas, i386
 y amd64, es necesario seleccionar cuál de ellas se desea instalar.
 La opción más fácil y efectiva es contar la posición de la versión que
 se quiere instalar y seleccionarla como se muestra a continuación, donde
 se ve que en este caso es la primera opción.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 11.JPG
	width 15cm

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Instalación del SO.
 Elección de la versión.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Selección de la partición de instalación de Windows.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 12.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Elección de partición de instalación.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aceptación de las condiciones de privacidad y uso del sistema operativo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 13.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Aceptación de las condiciones de privacidad y uso.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
La clave de producto, para poder realizar instalaciones desatendidas debe
 ser del tipo de Volúmen, esto es, una clave para realizar instalación en
 masa.
 A modo de ejemplo y para pruebas, Microsoft entrega una serie de claves
 para ésto: https://technet.microsoft.com/en-us/library/jj612867.aspx
\end_layout

\begin_layout Standard
Entonces, la clave de producto utilizada en este caso es: 
\series bold
FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 14.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Clave de producto.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Saltar activación del producto.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 15.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Activación del producto.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para solucionar el problema de asignar un hostname único a cada máquina
 que sea instalada con este 
\emph on
Autounattend.xml 
\emph default
se dió con la siguiente solución.
 Utilizando un string representativo en el campo RegisteredOwner y un asterísco
 en el campo ComputerName, se obtiene un hostname pseudo-aleatorio, ya que
 estará compuesto por máximo ocho caracteres de RegisteredOwner y/o RegisteredOr
ganization concatenado con caracteres aleatorios.
 El campo ComputerName es un string con un tamaño máximo de quince caracteres.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 16.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Hostname, organización, propietario y zona horaria.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se debe ingresar nuevamente la configuración deseada.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 17.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Idioma, teclado, regional.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se debe ingresar nuevamente la configuración deseada.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 18.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Organización, propietario y zona horaria.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Selección de la configuración rápida de red.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 19.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Configuración de red.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Configuración de contraseñas de administrador.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 20.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Contraseña administrador.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Creación de cuentas de usuario.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 21.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Cuentas de usuario, administrador.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/capturas-windows/windows image configuracion 22.JPG
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Cuentas de usuario, invitado.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Crear nuevos medios de instalación de Windows 7 para la imagen personalizada
\end_layout

\begin_layout Standard
En la máquina técnica realizar las siguientes operaciones:
\end_layout

\begin_layout Itemize
Descomprimir todo el contenido de la imagen de instalación sin modificar
 de Windows 7 en 
\backslash
path-directorio-instalacion
\backslash
.
\end_layout

\begin_layout Itemize
En el sub-directorio Sources (
\backslash
path-directorio-instalacion
\backslash
Sources
\backslash
), substituir la imagen install.wim, por la recientemente imágen capturada
 imagenPersonalizada.wim, renombrándola como install.wim.
\end_layout

\begin_layout Itemize
En el directorio principal de donde ha sido extraída la imagen, copiar el
 archivo de respuestas de instalación Autounattend.xml.
\end_layout

\begin_layout Itemize
Abrir Deployment Tools Command Prompt como administrador, y ejecutar:
\end_layout

\begin_deeper
\begin_layout Itemize
oscdimg -m -h -u2 -bd:
\backslash
path-directorio-instalacion
\backslash
boot
\backslash
etfsboot.com d:
\backslash
path-directorio-instalacion
\backslash
 d:
\backslash
path-directorio-destino
\backslash
Win7-personalizado.iso
\end_layout

\end_deeper
\begin_layout Standard
En este punto se tiene una imagen de instalación personalizada y automatizada
 lista para ser instalada en cualquier equipo.
 A continuación, se verá la preparación necesaria del servidor Linux para
 poder instalar y configurar SAMBA y la integración de Windows 7 con Cobbler
 para el posterior despliegue a través de la red.
\end_layout

\begin_layout Subsection
El lado de Linux
\end_layout

\begin_layout Standard
Lo primero que se debe hacer es copiar todos los archivos necesarios, anteriorme
nte generados en Windows, al servidor de despliegue, Cobbler.
\end_layout

\begin_layout Standard
En el servidor crear el siguiente directorio, donde se colocarán los archivos
 winpe_cobbler_amd64.iso y Win7-personalizado.iso:
\end_layout

\begin_layout Standard

\family typewriter
sudo mkdir /var/lib/cobbler/isos
\end_layout

\begin_layout Standard
Darle los permisos necesarios:
\end_layout

\begin_layout Standard

\family typewriter
sudo chmod -R 777 /var/lib/cobbler/isos/*.iso
\end_layout

\begin_layout Standard
También es necesario crear un directorio que se utilizará como zona de intercamb
io entre Linux y Windows:
\end_layout

\begin_layout Standard

\family typewriter
sudo mkdir /windows/
\end_layout

\begin_layout Standard
En este directorio se debe copiar el contenido de la imagen de instalación
 de Windows personalizada, para ello:
\end_layout

\begin_layout Standard

\family typewriter
sudo mkdir /mnt/windows 
\end_layout

\begin_layout Standard

\family typewriter
sudo mount -o loop /root/isos/WIN7_X64.iso /mnt/windows 
\end_layout

\begin_layout Standard

\family typewriter
sudo cp -rf /mnt/windows /windows 
\end_layout

\begin_layout Standard

\family typewriter
sudo umount /mnt/windows
\end_layout

\begin_layout Standard
La zona de intercambio entre ambos sistemas operativos se logra utilizando
 SAMBA.
 
\end_layout

\begin_layout Standard
Para instalar SAMBA en CentOS 7 ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
sudo yum install -y SAMBA SAMBA-client SAMBA-common SAMBA-winbind 
\end_layout

\begin_layout Standard
Una vez finalizada la instalación agregar una ubicación compartida en el
 archivo de configuración 
\emph on
/etc/SAMBA/smb.conf
\emph default
 como se muestra a continuación:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[global]
\end_layout

\begin_layout Standard

\family typewriter
workgroup = PXESERVER
\end_layout

\begin_layout Standard

\family typewriter
server string = SAMBA Server Version %v
\end_layout

\begin_layout Standard

\family typewriter
log file = /var/log/SAMBA/log.%m
\end_layout

\begin_layout Standard

\family typewriter
max log size = 50
\end_layout

\begin_layout Standard

\family typewriter
idmap config * : backend = tdb
\end_layout

\begin_layout Standard

\family typewriter
cups options = raw
\end_layout

\begin_layout Standard

\family typewriter
netbios name = pxe
\end_layout

\begin_layout Standard

\family typewriter
map to guest = bad user
\end_layout

\begin_layout Standard

\family typewriter
dns proxy = no
\end_layout

\begin_layout Standard

\family typewriter
public = yes
\end_layout

\begin_layout Standard

\family typewriter
## Para instalaciones multiples no bloquear el kernel
\end_layout

\begin_layout Standard

\family typewriter
kernel oplocks = no
\end_layout

\begin_layout Standard

\family typewriter
nt acl support = no
\end_layout

\begin_layout Standard

\family typewriter
security = user
\end_layout

\begin_layout Standard

\family typewriter
guest account = nobody
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[imagen]
\end_layout

\begin_layout Standard

\family typewriter
comment = Windows 7 
\end_layout

\begin_layout Standard

\family typewriter
path = /windows
\end_layout

\begin_layout Standard

\family typewriter
read only = no
\end_layout

\begin_layout Standard

\family typewriter
browseable = yes
\end_layout

\begin_layout Standard

\family typewriter
public = yes
\end_layout

\begin_layout Standard

\family typewriter
printable = no
\end_layout

\begin_layout Standard

\family typewriter
guest ok = yes
\end_layout

\begin_layout Standard

\family typewriter
oplocks = no
\end_layout

\begin_layout Standard

\family typewriter
level2 oplocks = no
\end_layout

\begin_layout Standard

\family typewriter
locking = no
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Habiendo modificado la configuración reiniciar el servicio: 
\end_layout

\begin_layout Standard

\family typewriter
sudo systemctl restart smb
\end_layout

\begin_layout Standard
Corroborar que se pueden compartir archivos, si se hace desde otra pc Linux,
 es necesario tener los siguientes paquetes:
\end_layout

\begin_layout Standard

\family typewriter
sudo yum install SAMBA SAMBA-client SAMBA-common cifs-utils
\end_layout

\begin_layout Standard
Luego ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
sudo smbclient -L IP_del_servidor_Cobbler 
\end_layout

\begin_layout Standard

\family typewriter
sudo mkdir /media/SAMBA 
\end_layout

\begin_layout Standard

\family typewriter
sudo mount // IP_del_servidor_Cobbler /imagen/media/SAMBA/ 
\end_layout

\begin_layout Standard

\family typewriter
sudo ls /media/SAMBA/
\end_layout

\begin_layout Standard
Deberían aparecer ya los archivos compartidos en esa ubicación.
\end_layout

\begin_layout Subsubsection
Integración con Cobbler
\end_layout

\begin_layout Standard
Para integrar la imagen de instalación Windows al servidor Cobbler se debe
 añadir una entrada distro y una entrada de perfil a Cobbler.
\end_layout

\begin_layout Standard

\family typewriter
sudo cobbler distro add --name=windows7-x86_64 --kernel=/usr/share/syslinux/memd
isk --initrd=/var/lib/cobbler/isos/winpe_cobbler_amd64.iso --kopts="raw iso"
 --arch=x86_64 --breed=windows
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo cobbler profile add --name=windows7-x86_64 --distro=windows7-x86_64
\end_layout

\begin_layout Standard

\family typewriter
sudo cobbler sync 
\end_layout

\begin_layout Standard

\family typewriter
sudo systemctl restart cobblerd
\end_layout

\end_body
\end_document

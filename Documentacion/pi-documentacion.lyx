#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
\usepackage{babel}
\addto\captionsenglish{%
 \renewcommand{\figurename}{Figura }%
 \renewcommand{\contentsname}{Índice}%
 \renewcommand{\listfigurename}{Lista de figuras}%
 \renewcommand{\tablename}{Tabla }%
 \renewcommand{\listtablename}{Lista de tablas}%
 \renewcommand{\partname}{Capítulo }%
}
\end_preamble
\options listitoc, tablecaptionabove, bibtotoc
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\bullet 1 0 9 -1
\bullet 2 0 15 -1
\bullet 3 0 6 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\noindent

\family sans
\series bold
\size huge
Universidad Nacional de Córdoba
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename Imagenes/Escudo_UNC_modernoo.png
	width 10cm
	height 10cm
	keepAspectRatio
	rotateOrigin centerBottom

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\family sans
\series bold
\size largest
Facultad de Ciencias Exactas, Físicas y Naturales
\end_layout

\begin_layout Standard
\noindent
\align center

\family sans
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\family sans
\series bold
\size larger
Infraestructura tecnológica virtual con automatización y orquestación.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align right

\family sans
\series bold
Alumnos:
\series default
 Juan Arese, Werner Diers
\end_layout

\begin_layout Standard
\noindent
\align right

\family sans
\series bold
Director de PI: 
\series default
Eschoyez, Maximiliano Andrés 
\end_layout

\begin_layout Standard
\noindent
\align right

\family sans
\series bold
Co-director de PI:
\series default
 Migliazzo, Oscar Andrés
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Part
Introducción
\end_layout

\begin_layout Section
Resumen del Proyecto Integrador
\end_layout

\begin_layout Standard
El Sistema desarrollado en este Proyecto Integrador, pretende facilitar
 algunas de las tareas que los administradores de los laboratorios realizan
 en las salas de informática.
 Las funcionalidades desarrolladas permiten a los administradores (o incluso
 a cualquier persona sin conocimiento técnico) crear maquinas virtuales
 con un solo click, dichas maquinas virtuales cuentan con todos los servicios
 y programas necesarios para los alumnos de las diferentes carreras o inclusive
 se pueden crear maquinas virtuales con otros perfiles, como un perfil para
 docentes.
 Además, permite orquestar las políticas a seguir de las diferentes máquinas
 de la red.
\end_layout

\begin_layout Subsection
Descripción
\end_layout

\begin_layout Standard
El sistema de infraestructura virtual con automatización y orquestación,
 tiene como objetivo principal brindar una herramienta a los administradores
 de laboratorios que facilite la preparación y configuración de sus aulas
 de manera simple.
\end_layout

\begin_layout Standard
El sistema está dividido en dos partes.
 Una parte de la herramienta está destinada al despliegue en masa de máquinas
 virtuales.
 Permite al administrador, crear múltiples máquinas virtuales con escasa
 interacción humana, de forma automática.
 Pudiéndose especificar el sistema operativo deseado y componentes de hardware.
 Del mismo modo, en un laboratorio con máquinas físicas, es posible realizar
 el despliegue a través de la red.
\end_layout

\begin_layout Standard
La segunda parte está destinada a la administración de la configuración
 de las máquinas virtuales.
 El sistema permite aplicar cambios de configuración y políticas a un conjunto
 de máquinas como también a máquinas particulares.
 Esto evita que el administrador tenga que preparar cada estación de trabajo
 de a una por vez, disminuyendo la carga de trabajo y el tiempo requerido
 para llevar a cabo la tarea.
\end_layout

\begin_layout Standard
Teniendo en cuenta que las herramientas utilizadas en este sistema deben
 ser de uso libre se utilizará como sistepa operativo base alguna distribución
 GNU/Linux.
\end_layout

\begin_layout Standard
El sistema incluye desarrollo en el lenguaje de programación Python, bash
 y el lenguaje propio de Puppet, la herramienta utilizada para la orquestación.
 El servidor de aprovisionamiento, haciendo uso del protocolo PXE, será
 el encargado de atender las peticiones de los dispositivos para su instalación.
\end_layout

\begin_layout Standard
Este Proyecto Integrador servirá como base para futuros Proyectos.
\end_layout

\begin_layout Subsection
Objetivos 
\end_layout

\begin_layout Standard

\series bold
Principal:
\series default
 
\end_layout

\begin_layout Itemize
Desarrollar un sistema para manejar automatismos administrados de políticas
 de una institución o empresa, para que el administrador pueda configurar
 las máquinas virtuales o físicas que se utilizan en la misma.
 Como caso particular se tomará un laboratorio informático de aprendizaje.
\end_layout

\begin_layout Standard

\series bold
Secundarios: 
\end_layout

\begin_layout Itemize
Estudiar Sistemas Operativos para servidor.
\end_layout

\begin_layout Itemize
Estudiar herramientas de virtualización.
\end_layout

\begin_layout Itemize
Estudiar herramientas de aprovisionamiento.
 
\end_layout

\begin_layout Itemize
Estudiar herramientas de administración de configuración.
\end_layout

\begin_layout Itemize
Analizar protocolos para inicio a través de la red como PXE.
\end_layout

\begin_layout Standard

\series bold
Antecedentes de Proyectos similares 
\end_layout

\begin_layout Itemize
No hay antecedentes en este tema.
\end_layout

\begin_layout Subsection
Intereses personales 
\end_layout

\begin_layout Standard
La principal motivación en este Proyecto Integrador es darle un final a
 la carrera de grado de Ingeniería en Computación intentando abarcar la
 mayor cantidad de temáticas posibles.
 Las asignaturas que abarca principalmente son Redes de Computadoras, Sistemas
 Operativos, Ingeniería de Software, Informática, Comunicaciones de Datos
 y Algoritmos y estructuras de Datos.
 Abordamos temas como sistemas operativos, sistemas de archivos, protocolos,
 metodologías de desarrollo, redes de datos, programación en Python, Shell
 scripting, virtualización, diagramas UML.
\end_layout

\begin_layout Subsection
Intereses Institucionales 
\end_layout

\begin_layout Standard
La Facultad de Ciencias Exactas, Físicas y Naturales actualmente cuenta
 con alrededor de cinco aulas de informática, en las cuales se dictan materias
 de todos los ciclos y especialidades de ingeniería.
 La idea del Proyecto Integrador es desarrollar un sistema de infraestructura
 con automatización y orquestación que permita disminuir la carga de trabajo
 de los administradores de estas aulas y facilitar las tareas de mantenimiento
 de las mismas, cumpliendo con las políticas del área que administra las
 aulas.
\end_layout

\begin_layout Subsection
Metodología 
\end_layout

\begin_layout Standard
Para afrontar el Proyecto Integrador de la carrera se utilizó una metodología
 de desarrollo ágil de software basado en el desarrollo iterativo e incremental.
 El trabajo desarrollado en una unidad de tiempo es llamado una iteración,
 las cuales constan de un corto lapso de tiempo de entre una y tres semanas.
 Cada iteración se compone de un ciclo de vida que integra diversas etapas
 como planificación, definición de los requerimientos, investigación, diseño,
 codificación, pruebas y documentación.
 En cada iteración se agrega una nueva “funcionalidad” al sistema y a medida
 que avanzan los ciclos el sistema aumenta de tamaño, por esto lo llamamos
 incremental.
 Otra característica de la metodología ágil que se utilizó, es una comunicación
 fluida con el “cliente” que en este caso son los Directores del Proyecto
 Integrador, de los que también se obtienen los requerimientos.
 Esto permite una buena retroalimentación, con la cual se devuelven correcciones
 .
 No ser estrictos con la documentación es una característica que se tomó
 del desarrollo ágil, tener todo anotado luego facilita la generación del
 informe.
 
\end_layout

\begin_layout Standard

\series bold
Lugar previsto para la realización: 
\end_layout

\begin_layout Itemize
Laboratorio de Arquitectura de Computadoras, Facultad de Ciencias Exactas,
 Físicas y Naturales.
 
\end_layout

\begin_layout Standard

\series bold
Requerimiento de Instrumental y Equipos: 
\end_layout

\begin_layout Itemize
Computadora personal.
\end_layout

\begin_layout Standard

\series bold
Inversión económica: 
\end_layout

\begin_layout Itemize
Inversión provista por el alumno: ninguna
\end_layout

\begin_layout Itemize
Apoyo económico externo a la Facultad: ninguno.
\end_layout

\begin_layout Subsection
Requerimientos 
\end_layout

\begin_layout Standard
Los requerimientos del sistema se obtuvieron directamente desde el Director
 y el Codirector del Proyecto Integrador.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar distintos sistemas operativos:
\end_layout

\begin_deeper
\begin_layout Standard
CentOS 
\end_layout

\begin_layout Standard
Ubuntu
\end_layout

\begin_layout Standard
Debian
\end_layout

\begin_layout Standard
Windows 
\end_layout

\end_deeper
\begin_layout Enumerate
La herramienta debe poder aprovisionar máquinas servidores .
 
\end_layout

\begin_layout Enumerate
La herramienta debe aprovisionar a través de la red.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar utilizando plantillas.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar utilizando repositorios locales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder actualizar los repositorios locales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder setear politicas a las máquinas virtuales,utilizando
 Puppet.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder monitorizar el estado de las máquinas virtuales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe ser escalable, integrar nuevas máquinas virtuales fácilmente.
 
\end_layout

\begin_layout Enumerate
La herramienta debe utilizar licencias de código abierto.
 
\end_layout

\begin_layout Enumerate
La herramienta debe estar implementada en la versión más actual al momento
 de realizar el Proyecto Integrador.
\end_layout

\begin_layout Subsection
Cronograma a seguir
\end_layout

\begin_layout Standard
El cronograma está dividido en seis etapas diferentes:
\end_layout

\begin_layout Itemize
Familiarización con el sistema operativo GNU/Linux elegido.
 
\end_layout

\begin_layout Itemize
Investigación de diferentes herramientas de virtualización.
 
\end_layout

\begin_layout Itemize
Investigación de diferentes herramientas de aprovisionamiento.
\end_layout

\begin_layout Itemize
Pruebas de las herramientas seleccionadas.
 
\end_layout

\begin_layout Itemize
Pruebas de la herramienta de administración de configuración.
 
\end_layout

\begin_layout Itemize
Preparación y desarrollo del informe del trabajo final y cierre del mismo.
\end_layout

\begin_layout Subsection
Objetivo a alcanzar en cada etapa:
\end_layout

\begin_layout Itemize

\series bold
Primera etapa:
\series default
 conocer el sistema operativo GNU/Linux.
 La principal motivación, es la de informarse sobre la base donde se implementar
á el sistema desarrollado en este Proyecto Integrador.
 
\end_layout

\begin_layout Itemize

\series bold
Segunda etapa:
\series default
 obtener los conocimientos suficientes para crear y administrar máquinas
 virtuales.
 
\end_layout

\begin_layout Itemize

\series bold
Tercera etapa:
\series default
 conocer cuáles son las herramientas disponibles y utilizadas en ambientes
 de producción para el aprovisionamieto de máquinas, teniendo en cuenta
 que deben ser de código abierto, analizarlas y elegir la más apropiada
 para realizar el Proyecto Integrador.
 
\end_layout

\begin_layout Itemize

\series bold
Cuarta etapa: 
\series default
implementar las herramientas seleccionadas en conjunto.
 
\end_layout

\begin_layout Itemize

\series bold
Quinta etapa:
\series default
 realizar la implementación conjunta de todas las herramientas automatizando
 la instalación y realizar configuracines pertinentes en los sistemas ya
 instalados, por medio de Puppet.
 
\end_layout

\begin_layout Itemize

\series bold
Sexta etapa: 
\series default
desarrollo del informe del trabajo final
\end_layout

\begin_layout Part
Marco teórico
\end_layout

\begin_layout Standard
Previamente al abordaje del desarrollo, requerimos conocimientos teóricos
 que nos posibiliten comprender el entorno donde se ejecutarán las aplicaciones
 que componen el Sistema, las herramientas que darán soporte o permitirán
 cumplir con las funcionalidades previstas y las que se utilizarán para
 desarrollar.
 Algunas de las mismas fueron explícitamente solicitadas en los requerimientos.
 El resto de las herramientas, que están implícitas en los requerimientos,
 precisaron de investigación y pruebas para conocer si permiten cumplir
 estos requerimientos y además, si hay varias opciones, elegir la más convenient
e.
 Podemos dividir esta sección del informe en cuatro áreas diferentes:
\end_layout

\begin_layout Itemize
Sistema operativo 
\end_layout

\begin_layout Itemize
Virtualización 
\end_layout

\begin_layout Itemize
Aprovisionamiento 
\end_layout

\begin_layout Itemize
Orquestación
\end_layout

\begin_layout Standard
La información contenida en esta sección se desprende de las investigaciones
 realizadas en cada una de las etapas del Proyecto Integrador.
\end_layout

\begin_layout Section
Sistema operativo
\end_layout

\begin_layout Subsection
FreeBSD
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_freebsd.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
FreeBSD logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
FreeBSD es un sistema operativo basado en BSD para arquitecturas Intel (x86
 e Itanium), AMD64, AlphaTM y UltraSPARC.
 
\end_layout

\begin_layout Standard
FreeBSD viene con una excelente colección de herramientas de sistema como
 parte del sistema base.
 A pesar de esto, existen otras que no vienen incluidas y se necesitan instalar
 para utilizarlas.
 FreeBSD ofrece dos tecnologías complementarias para instalar software de
 terceros en el sistema: la Colección de puertos o ports de FreeBSD y los
 paquetes binarios.
 Los paquetes binarios son archivos simples que descargamos desde repositorios.
 Contienen una copia de los programas binarios precompilados de la aplicación
 y se pueden manipular con las herramientas de gestión de paquetes de FreeBSD:
 pkg_add , pkg_delete , pkg_info , etc.
 Por otro lado, existen ciertos pasos que se deben llevar a cabo para compilar
 un programa (descargar, desempaquetar, parchear, compilar e instalar).
 Los ficheros que conforman un port permiten que el sistema se encargue
 de todo esto, mediante un conjunto simple de órdenes.
 La colección de puertos para instalar se encuentra en /usr/ports.
\end_layout

\begin_layout Standard
FreeBSD proporciona compatibilidad binaria con muchos otros sistemas operativos
 tipo UNIX, como Linux.
 Esto es necesario, ya que muchos desarrolladores y compañías sólo desarrollan
 para Linux.
 La compatibilidad binaria permite a los usuarios utilizar en FreeBSD cerca
 del 90% de las aplicaciones desarrolladas para Linux sin que sea necesario
 realizar alguna modificación sobre la aplicación.
\end_layout

\begin_layout Standard
Otras características:
\end_layout

\begin_layout Itemize
Servicios multiusuario que permiten a mucha gente usar el sistema FreeBSD
 simultáneamente.
\end_layout

\begin_layout Itemize
Conexión de redes TCP/IP muy robusta, con soporte para estándares industriales.
 
\end_layout

\begin_layout Itemize
La protección de memoria que garantiza que las aplicaciones (o los usuarios)
 no se estorben los unos a los otros.
\end_layout

\begin_layout Itemize
Compatibilidad binaria con muchos programas nativos de Linux, SCO, SVR4,
 BSDI y NetBSD.
 
\end_layout

\begin_layout Itemize
Soporte para multiprocesamiento simétrico con múltiples CPUs.
\end_layout

\begin_layout Subsection
Debian
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_debian.gif
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Debian logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Debian es una distribución libre, por completo manejada por la comunidad,
 no está basada en ninguna otra distribución y por el contrario gran parte
 de las distribuciones actuales están basadas en ella.
 Debian es famoso por filosofía de estabilidad ante todo, por eso mismo,
 no tiene un cronograma de lanzamiento de nuevas versiones.
 Estas se liberán cuando estén realmente listas.
 Es una distribución ampliamente utilizada tanto como escritorio como en
 su versión para servidor.
\end_layout

\begin_layout Standard
En su última versión, Debian 8 Jessie, las siguientes arquitecturas tienen
 soporte: x32 (i386), x86-64 (amd64), Motorola/IBM PowerPC, MIPS, IBM S/390
 y ARM.
 
\end_layout

\begin_layout Standard
Este release incluye el nuevo estándar sistema de inicio 
\emph on
systemd.
\end_layout

\begin_layout Standard
Principales características de Jessie:
\end_layout

\begin_layout Itemize
Actualización de administrador de paquetes: apt 1.0.9.8.1 
\end_layout

\begin_layout Itemize
Núcleo del sistema: Linux kernel 3.16 
\end_layout

\begin_layout Itemize
Cambio a systemd.
 
\end_layout

\begin_layout Itemize
Entornos gráficos : Gnome 3.14, KDE 4.14, 
\end_layout

\begin_layout Itemize
Los puertos para el kernel de FreeBSD (kfreebsd-amd64 y kfreebsd-i386),
 incluídos para versiones anteriores no son parte de esta versión.
\end_layout

\begin_layout Itemize
Soporte UEFI para amd64, i386 y arm64.
\end_layout

\begin_layout Subsection
Debian GNU/kFreeBSD
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_debian_kfreebsd.png
	lyxscale 5
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Debian/kFreeBSD logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Debian GNU/kFreeBSD es un sistema operativo de propósito general.
 Es una distribución oficial de GNU Debian que usa el Kernel de FreeBSD
 en vez del Kernel de Linux.
 Cerca del 90% del Software de Debian está disponible para Debian GNU/kFreeBSD.
\end_layout

\begin_layout Standard
Debian GNU/kFreeBSD soporta ZFS desde el kernel.
 Esto también puede significar un mejor rendimiento y mayor estabilidad
 en discos que utilicen el sistema de archivos ZFS.
 Debian GNU/kFreeBSD podría instalarse en una jaula.
 Esto permitiría aprovechar todas las ventajas de FreeBSD en el servidor,
 brindándole la opción de usar Debian a los usuarios del servidor y eliminando
 la necesidad de que se familiaricen con FreeBSD.
\end_layout

\begin_layout Subsection
PC-BSD
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_pcbsd.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
PC-BSD logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
PC-BSD es un sistema operativo de escritorio basado en FreeBSD.
 La idea principal, es agregar las características conocidas de FreeBSD
 como sistema operativo para servidores, como lo son la estabilidad y la
 seguridad, a un sistema operativo de escritorio amigable.
\end_layout

\begin_layout Standard
Para la instalación, brinda una interfaz gráfica que permite la elección
 de opciones de instalación.
 Presenta dos perfiles de instalación, cada una con una serie de programas
 opcionales para seleccionar.
\end_layout

\begin_layout Standard
Un perfil de instalación es el Desktop o escritorio, orientado a computadoras
 de usuario.
 Básicamente esta opción es la idea de PC-BSD.
 Instala y configura el entorno de escritorio KDE por defecto.
 También se pueden seleccionar otros escritorios como GNOME o XFCE, herramientas
 de virtualización, herramientas de desarrollo, etc.
 El otro perfil de instalación está orientado a servidores.
 No instala paquetes de interfaz gráfica y permite instalar servidores web,
 servidores de base de datos, servidores de archivos, herramientas de virtualiza
ción, etc.
 PC-BSD además agrega lo que promete ser la nueva forma de administración
 de paquetes para FreeBSD: pkgng ( pkg next generation ).
 Esta herramienta no viene instalada por defecto en FreeBSD.
 Su funcionamiento se asemeja al apt-get de Linux.
\end_layout

\begin_layout Standard
Otra característica importante es que PC-BSD utiliza ZFS como sistema de
 archivos, instalándolo casi sin intervención del usuario (si así se desea).
 
\end_layout

\begin_layout Subsection
CentOS 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_centos.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CentOS logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
CentOS es un distribución Linux empresarial, basada en Red Hat Enterprise
 Linux.
 CentOS concuerda con la política de distribución de Red Hat y apunta a
 ser binariamente compatible en su totalidad.
 Cada versión de esta distro tiene soporte por siete años en cuestiones
 de actualizaciones de mantenimiento y seguridad, lo que se traduce en un
 ambiente confiable, predecible, reproducible, de bajo mantenimiento y seguro.
\end_layout

\begin_layout Standard
La principal ventaja de esta distro es que se obtiene un conjunto estable
 de la mayoría de paquetes que por lo general sólo incluyen correcciones
 de errores.
 En su última versión, CentOS 7 solo está disponible para la arquitectura
 x86_64, y representa un gran cambio frente a versiones anteriores del sistema
 operativo, como la inclusión de systemd, Gnome 3, GRUB 2, y el sistema
 de archivos XFS.
 El entorno de escritorio KDE también forma parte de la oferta de CentOS
 7.
 
\end_layout

\begin_layout Standard
Principales novedades de CentOS 7:
\end_layout

\begin_layout Itemize
Actualización del núcleo del sistema: Kernel 3.10.0.
 
\end_layout

\begin_layout Itemize
Soporte para Linux Containers.
 
\end_layout

\begin_layout Itemize
Inclusión de VMware Tools y controladores de gráficos 3D.
 
\end_layout

\begin_layout Itemize
OpenJDK-7 como JDK por defecto.
 
\end_layout

\begin_layout Itemize
Cambio a systemd.
 
\end_layout

\begin_layout Itemize
Cambio a firewalld y GRUB2 .
\end_layout

\begin_layout Itemize
XFS es el sistema de archivos por defecto y permite escalar la capacidad
 de almacenamiento del sistema hasta 500 terabytes.
 XFS es un sistema de archivos de 64 bits con journaling de alto rendimiento,
 y está especialmente indicado para discos grandes (superiores a 1 TB).
 No obstante y para necesidades menos exigentes se pueden emplear otros
 sistemas de archivos, como Ext4.
 
\end_layout

\begin_layout Itemize
iSCSI y FCoE (Fiber Channel over Ethernet) en el espacio del Kernel.
 
\end_layout

\begin_layout Itemize
Soporte para PPTv2 (Precision Time Protocol).
\end_layout

\begin_layout Itemize
Soporte para tarjetas Ethernet 40G.
 
\end_layout

\begin_layout Itemize
Soporte UEFI.
 
\end_layout

\begin_layout Standard
En cuanto a systemd, es el reemplazo de init como demonio para iniciar servicios
, procesos y recursos del sistema.
 Systemd es la nueva forma predeterminada de iniciar los sistemas Linux,
 y ha sido adoptado por Red Hat, Debian y Ubuntu, entre otros.
 CentOS 7 es compatible con Microsoft Active Directory (y obviamente con
 Red Hat), por lo que puede trabajar con facilidad en entornos heterogéneos.
 CentOS 7 incluye PCP (Performance Co-Pilot), un conjunto de frameworks
 y servicios en tiempo real para supervisar y monitorizar el rendimiento
 del sistema.
\end_layout

\begin_layout Subsection
Solaris
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/sistemas operativos/sistemas_operativos_solaris.gif
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solaris logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Solaris es un sistema operativo de tipo Unix desarrollado por Sun Microsystems
 desde 1992 como sucesor de SunOs.
 Es un sistema certificaco oficialmente como version de Unix.
 Aunque solaris fue desarrollado como software privado, la mayor parte de
 su codigo se ha liberado como proyecto de software libre denominado OpenSolaris.
 Solaris es famoso por su escalabilidad, especialmente en sistemas SPARC.
 Sun solaris se ejecuta sobre la arquitectura SPARC en 32 y 64 bits, o sobre
 procesadores x86 (incluidos Intel y AMD).
 Sin embargo, en agosto de 2010, Oracle decidió interrumpir la publicación
 y distribución de OpenSolaris.
\end_layout

\begin_layout Standard
Solaris tiene una reputación de ser muy adecuado para el multiprocesamiento
 simétrico (SMP), soportando un gran número de CPUs.
 Históricamente Solaris ha estado firmemente integrado con la plataforma
 hardware de Sun, SPARC, con la cual fue diseñado y promocionado como un
 paquete combinado.
 Esto proporcionaba frecuentemente unos sistemas más fiables pero con un
 coste más elevado que el del hardware de PC.
 
\end_layout

\begin_layout Standard
A partir de su versión 10, Sun Microsystems ha promocionado Solarios con
 sus propias estaciones de trabajo y servidores de 64 bits basados en procesador
es AMD Opteron e Intel Xeon, como también en sistemas de 32 bits.
 Esta versión añadió soporte para paravirtualización cuando es utilizada
 como “sistema operativo invitado” en ambientes basados en Xen.
 
\end_layout

\begin_layout Standard
En su última versión, 11.3, sus principales características son:
\end_layout

\begin_layout Itemize
Inculye una nueva versión de OpenStack (Juno) con soporte para topologías
 de red adicionales y nuevos servicios.
 
\end_layout

\begin_layout Itemize
SNAT, soporte Ipv6.
\end_layout

\begin_layout Itemize
Pools de almacenamiento.
 
\end_layout

\begin_layout Itemize
Aprovisionamiento de máquinas (bare metal provisioning) como servicio .
\end_layout

\begin_layout Itemize
Incluye soporte para desarrollo basado en la API REST utilizando el Demonio
 de Administración Remota (permite configuración remota de los sistemas
 Oracle usando Python, C y Java).
 
\end_layout

\begin_layout Itemize
Sistema de archivos ZFS.
\end_layout

\begin_layout Itemize
Solaris Containers
\end_layout

\begin_layout Section
Virtualización 
\end_layout

\begin_layout Standard
Virtualización es un término amplio para software ejecutándose, usualmente
 sistemas operativos, de manera concurrente y aislada de otros programas
 en el mismo sistema.
 Muchas de las implementaciones de virtualización utilizan un “hypervisor”,
 una capa de software que controla el harware y provee sistemas operativos
 huéspedes con acceso a los dispositivos de hardware subyacentes.
 El hypervisor permite ejecutar múltiples sistemas operativos en el mismo
 sistema físico ofreciendo hardware virtualizado al sistema opertativo huésped.
 Esta tecnología, provee un conjunto de herramientas para aumentar la flexibilid
ad y reducir los costos, los cuales son tópicos importantes en cualquier
 empresa o institución.
 En escencia, la virtualización imcrementa la flexibilidad desacoplando
 un sistema operativo y los servicios y aplicaciones soportados por él,
 de una plataforma de hardware física específica, permitiendo el establecimiento
 de múltiples entornos virtuales sobre una plataforma de hardware compartida.
 Estos entornos pueden ser creados localmente o aprovisionados extrenamente.
 La virtualización se destaca también apoyando la innovación a través del
 uso de entornos virtuales para practicar y aprender.
 Un estudiante puede comenzar un curso o trabajo un entorno de sistema conocido,
 estándar y aislado del entorno de producción; si se produce algún tipo
 de daño solo afecta al sistema virtual.
 Además se puede establecer entornos únicos de software para el aprendizaje
 sin demandar el uso exclusivo de recursos de hardware.
 Aunque en comparación los costos de inversión para tener un número elevado
 de máquinas físicas son mucho mayores que el costo para invertir en un
 servidor con altos recursos para realizar la virtualización, se podría
 decir que la virtualización posee inconvenientes vinculados con sus exigentes
 requerimientos de hardware, en cuanto a capacidad de procesamiento y de
 memoria RAM y de almacenamiento.
 Otra desventaja es que del sistema de virtualización depende del sistema
 operativo anfitrión.
 Es decir, el anfitrión es el punto débil del sistema ya que se comparte
 por todos los sistemas virtualizados, si se rompe éste, se rompen todas
 las máquinas virtuales.
\end_layout

\begin_layout Subsection
Tipos de virtualización
\end_layout

\begin_layout Subsubsection
Virtualización completa 
\end_layout

\begin_layout Standard
Consite en la virtualización de paquetes y herramientas para correr de forma
 totalmente virtualizada, sin modificaciones, sistemas operativos huéspedes.
 Este modo cuenta con la ventaja de consolidar sistemas viejos en hardware
 nuevo, más eficiente y reducir el espacio físico y costos de operación
 relativos al consumo energético y refrigeración de estos sistemas menos
 eficientes.
 La virtualización completa ofrece, sin embargo, menor rendimiento de entrada/sa
lida que instalaciones nativas (también llamadas “bare-metal” o “metal-pelado”)
 de sistemas operativos.
 Por ejemplo el software KVM, Xen, VMware Workstation o VirtualBox hacen
 uso de esta técnica.
 Cabe destacar que en el caso de KVM se requiere soporte de hardware para
 ejecutar la virtualización, ya sea con procesadores Intel o AMD.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_tipos_3.png
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de virtualización completa
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Para-virtualización 
\end_layout

\begin_layout Standard
Para-virtualización es un técnica de virtualización la cual implica ejecutar
 verisiones modificadas de los sistemas opetativos.
 El sistema operativo para-virtualizado es modificado para que se de cuenta
 que está siendo virtualizado, ofreciendo un habilidad aumentada para la
 optimización, ya que el huésped está al tanto de su entorno.
 El rendimiento está generalmente muy cerca de la ejecución nativa de sistemas
 operativos no virtualizados.
 Por ejemplo, utilizan esta técnica KVM, XEN y VMware Server ESX.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_tipos_1.png
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de paravirtualización
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Para-virtualización de drivers
\end_layout

\begin_layout Standard
La para-virtualización y la virtualización completa pueden ser combinadas
 para permitir a sistemas operativos no modificados recibir un rendimiento
 cercano de entrada/salida al de ejecución nativa, por medio de drivers
 para-virtualizados en sistemas opetativos completamente virtualizados.
\end_layout

\begin_layout Subsubsection
Virtualización a nivel del sistema operativo 
\end_layout

\begin_layout Standard
También llamada virtualización basada enc ontenedores, esta técnica virtualiza
 un servidor físico a nivel del sistema operativo, permitiendo que múltiples
 servidores virtuales aislados y seguros se ejecuten sobre un solo servidor
 físico.
 Con la virtualización basada en contenedores, no existe la sobrecarga asociada
 con tener a cada huésped ejecutando un sistema operativo completamente
 instalado.
 Este enfoque también puede mejorar el rendimiento porque hay un solo sistema
 operativo encargándose de los avisos de hardware.
 Una desventaja de la virtualización basada en contenedores, sin embargo,
 es que cada invitado debe utilizar el mismo sistema operativo que utiliza
 el host.
 Por ejemplo, Jaulas con Warden en FreeBSD, OpenVZ o Linux-Vserver usan
 esta técnica.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_tipos_2.png
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de virtualización a nivel de SO
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Virtualización de aplicaciones
\end_layout

\begin_layout Standard
La virtualización de aplicaciones consiste en correr una aplicación sobre
 una máquina virtual usando los recursos reales.
 Por ejemplo la máquina virtual JAVA.
\end_layout

\begin_layout Subsubsection
Emulación 
\end_layout

\begin_layout Standard
Un emulador es hardware o software que permite a un sistema de computación
 comportarse como otro sistema.
 Generalmente, un emulador permite a un sistema correr software o utilizar
 dispositivos perisféricos dieñads para el otro sistema.
 Por ejemplo Qemu es un emulador muy usual en ingeniería.
 
\end_layout

\begin_layout Subsection
Herramientas de virtualización 
\end_layout

\begin_layout Standard
Algunas de las herramientas más utilizadas para virtualizar son las siguientes,
 sin embargo como uno de los requisitos es utilizar herramientas de código
 abierto, no se indagó acerca de VMWare: 
\end_layout

\begin_layout Itemize
VirtualBox 
\end_layout

\begin_layout Itemize
KVM/Qemu 
\end_layout

\begin_layout Itemize
Xen
\end_layout

\begin_layout Itemize
OpenVZ
\end_layout

\begin_layout Itemize
Docker
\end_layout

\begin_layout Itemize
VMWare Workstation 
\end_layout

\begin_layout Subsubsection
VirtualBox
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_virtualbox.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
VirtualBox logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
VirtualBox, desarrollado por Oracle, es un virtualizador completo de propósito
 general para hardware x86, orientado al uso para servidor, escritorio y
 embebido.
 Como software de código abierto, se puede utilizar bajo la licencia GNU
 General Public License 2 (GPL2) .
 
\end_layout

\begin_layout Standard
AL día de la fecha, VirtualBox corre en Windows, Linux, Macintosh y Solaris
 y soporta una amplia variedad de sistemas operativos, entre ellos RHEL(7,6,5,4)
, Windows (NT 4.0, 2000, XP, Server 2003, Vista, Windows 7, Windows 8, Windows
 10), DOS/Windows 3.x, Linux (2.4, 2.6, 3.x and 4.x), Solaris y OpenSolaris,
 OS/2, y OpenBSD.
 
\end_layout

\begin_layout Subsubsection
KVM/Qemu 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_kvm.png
	height 3cm

\end_inset


\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_qemu.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
KVM/Qemu logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
KVM (Kernel-based Virtual Machine), desarrollado por Red Hat Enterprise
 Linux, es una infraestructura de virtualización completa para el kernel
 de Linux que lo transforma en un hypervisor.
 Fue incorporado a la línea principal del kernel Linux en la versión 2.6.20.
 KVM requiere un procesador con hardware que permita extensión para virtualizaci
ón (Intel VT o AMD-V).
 También está disponible para instalarlo desde los “ports” de FreeBSD en
 la forma de módulos de kernel.
 
\end_layout

\begin_layout Standard
La para-virtualización tiene soporte para ciertos dispositivos en Linux,
 OpenBSD, FreeBSD y Windows (entre otros) utilizando la API VirtIO.
 Se tiene placa Ethernet, un controlador de entrada/salida de disco paravirtual,
 gráficos VGA.
 
\end_layout

\begin_layout Standard
Qemu puede utilizarse como emulador y como virtualizador.
 Cuando se utiliza como virtualizador, Qemu toma un rendimiento cercano
 al nativo.
 Para ello, debe ejecutarse bajo el hypervisor Xen o KVM.
 En conjunto KVM/Qemu, KVM es quien hace las veces de árbitro del acceso
 al CPU y memoria, y Qemu emula los recursos de hardware.
 
\end_layout

\begin_layout Subsubsection
Xen 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_xen.gif
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Xen logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Xen, desarrollado por University of Cambridge Computer Laboratory y mantenido
 por IBM, HP, Intel, AMD, RedHat, es una herramienta de virtualización que
 se ejecuta por debajo del sistema operativo y actúa como hypervisor.
\end_layout

\begin_layout Standard
Esta herramienta permite trabajar con virtualización completa y con paravirtuali
zación.
 Como KVM y VirtualBox, también posee una larga lista de sistemas operativos
 soportados.
\end_layout

\begin_layout Subsubsection
OpenVZ 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_openvz.png
	lyxscale 50
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
OpenVZ logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
OpenVZ es una herramienta de virtualización para Linux basada en contenedores.
 OpenVZ crea múltiples contenedores aislados en un servidor físico y asegurando
 que las aplicaciones no entren en conflicto.
 Utiliza un kernel de Linux modificado y por consiguiente sólo puede correr
 Linux.
 Todos los contenedores comparten la misma arquitectura y versión del kernel.
 Cada contenedor se comporta como un servidor autónomo.
 Ya que OpenVZ emplea un modelo de kernel único, es tan escalable como kernel
 Linux 2.6, lo que significa que soporta hasta 64 CPUs y hasta 64 GiB de
 RAM.
 Un entorno virtual único se puede escalar hasta el equipo físico entero.
 También cuenta con migración en vivo que posibilita mover un contenedor
 de in servidor físico a otro sin apagar el contenedor.
 Un propietario (root) de un servidor físico OpenVZ (conocido como Nodo
 de Hardware) puede ver todos los procesos y archivos de los contenedores.
 Esto hace la administración masiva de escenarios posible: se puede ejecutar
 un simple script de intérprete de comandos que actualice todos (o sólo
 algunos seleccionados) los contenedores a la vez.
\end_layout

\begin_layout Subsubsection
Docker
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/virtualizacion/virtualizacion_herramientas_docker_2.jpg
	lyxscale 50
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Docker logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Aprovisionamiento 
\end_layout

\begin_layout Standard
En general, aprovisionamiento, significa proveer o hacer que algo esté disponibl
e.
 El término es utilizado en un gran variedad de contextos en el área de
 Tecnologías de Información.
 En este Proyecto Integrador, el término hace referencia a lo siguiente:
 Aprovisionamiento es el conjunto de acciones para preparar una máquina
 virtual, con el sistema apropiado, datos y software, y dejarla lista para
 su operación.
 
\end_layout

\begin_layout Itemize
Tareas típicas que se tienen que llevar a cabo para que esto suceda son:
 
\end_layout

\begin_layout Itemize
Seleccionar el conjunto de hardware virtualizado (memoria RAM, disco, cantidad
 de procesadores asignados, placa de red, etc) para crear una máquina virtual
 bare-metal.
\end_layout

\begin_layout Itemize
Cargar el sistema operativo adecuado.
\end_layout

\begin_layout Itemize
Configurar el sistema (dirección IP, gateway, DNS, hostname, MAC, etc).
\end_layout

\begin_layout Itemize
Actualizar el sistema y aplicar parches.
\end_layout

\begin_layout Itemize
Cargar el conjunto de aplicaciones necesarias.
\end_layout

\begin_layout Itemize
Configurar el sistema para adaptarlo a las políticas definidas de la institución.
\end_layout

\begin_layout Standard
En resumen, el aprovisionamiento de máquinas virtuales se realiza basado
 en los recursos disponibles y en los requisitos específicos de cada máquina
 virtual, según sea la funcionalidad que se le vaya a dar.
\end_layout

\begin_layout Subsection
Herramientas de aprovisionamiento 
\end_layout

\begin_layout Standard
Algunas de las herramientas de código abierto más utilizadas para aprovisionar
 son las siguientes: 
\end_layout

\begin_layout Itemize
Cobbler
\end_layout

\begin_layout Itemize
FAI
\end_layout

\begin_layout Itemize
Vagrant 
\end_layout

\begin_layout Itemize
Foreman
\end_layout

\begin_layout Subsubsection
Cobbler 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_cobbler.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cobbler logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cobbler es un servidor Linux de aprovisionamiento que centraliza y simplifica
 el control de los servicios incluyendo DHCP, TFTP y DNS con el propósito
 de realizar installaciones de sistemas operativos basadas en la red.
 Puede ser configurado para PXE, reinstalaciónes y huéspedes virtualizados
 utilizando Xen, KVM o VMWare como también dispositivos físicos.
 Está dirigido especialmente a Red Hat Linux y sus derivados, pero es posible
 configurarlo para que inicie con PXE otras distribuciones de Linux como
 Debian, Ubuntu o Knoppix.
 Es una herramienta que se ecuentra en creciente desarrollo y cada vez añade
 más soporte a distintas distros e incluso a FreeBSD y a futuro Windows.
 Actualmente cuenta con poco soporte para el sistema operativo de Microsoft.
 
\end_layout

\begin_layout Standard
Cuenta con un sistema integrado para administración de configuración pero
 también cuenta con soporte para la integrar la herramienta de administración
 de configuración Puppet.
 Cobbler se basa en el mecanismo de Kickstart y ofrece perfiles de instalación
 que pueden ser aplicados a una o muchas máquinas.
 La información de contenida en un plantilla kickstart puede ser modificada
 dinámicamente pasando variables (llamadas ksmeta) o utilizando snippets,
 donde se puede mantener el código comúm simplificando la lectura y minimizando
 el tamaño del archivo kickstart.
\end_layout

\begin_layout Subsubsection
Fully Automatic Installation (FAI)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_fai.png
	lyxscale 75
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
FAI logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
FAI es un sistema no interactivo para instalar, personalizar y administrar
 sistemas Linux y configuraiones de software en computadoras como también
 en máquinas virtuales y entornos chroot, desde pequeñas redes hasta una
 infraestructura grande escalable y clusters.
 Es una herramienta para la instalación totalmente automáica de Debian y
 otras distros de Linux como Suse, Red Hat, Solaris, vía red, DVDs personalizado
s de instalación o en entornos chroot.
 
\end_layout

\begin_layout Standard
Algunas de las características más importantes:
\end_layout

\begin_layout Itemize
Instalar y actualizar Debian, Ubuntu, SUSE, Red Hat, etc.
\end_layout

\begin_layout Itemize
Despliegue centralizado y administración de configuración.
\end_layout

\begin_layout Itemize
Recuperació de desastre integrado.
\end_layout

\begin_layout Itemize
Fácil configuración de software RAID y LVM.
\end_layout

\begin_layout Itemize
Instalar máquinas virtuales usando KVM, Xen y VirtualBox.
\end_layout

\begin_layout Itemize
Control remoto vía SSH durante la instalación.
\end_layout

\begin_layout Subsubsection
Vagrant
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_vagrant.png
	lyxscale 15
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Vagrant logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vagrant provee entornos fáciles de reproducir, configurar construidos sobre
 tecnología industrial estándar.
 Vagrant es un software que crea y configura entornos de desarrollo virtuales
 aprovisionando sobre VirtualBox, VMware, KVM y contenedores Linux.
 Es una software que se encuentra una capa encima de estas herramientas.
 Luego herramientas de administración de configuración como Ansible, Chef,
 Salt, y Puppet pueden ser utilizadas para instalar y configurar automáticamente
 el software en la máquina.
\end_layout

\begin_layout Subsubsection
Foreman 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/aprovisionamiento/aprovisionamiento_foreman.png
	lyxscale 60
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Foreman logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Foreman es una herramienta para el aprovisionamiento, configuración y monitoriza
ción de servidores físicos y virtuales.
 Puede aprovisionar máquinas bare-metal, virtualizadas y en la nube a través
 de installaciones desatendidas por medio de DHCP, DNS, TFTP y PXE .
 Tiene una gran integración con software de administración de configuración
 como Puppet, Chef, Salt y otros por medio de plugins.
\end_layout

\begin_layout Standard
Algunas de sus características son:
\end_layout

\begin_layout Itemize
Descubrir, aprovisioinar y actualizar toda la infraestructura bare-metal.
\end_layout

\begin_layout Itemize
Crear y gestionar instancias entre nubes privadas y públicas.
 
\end_layout

\begin_layout Itemize
Agrupar hosts y dirigirlos en conjunto, sin importar la ubicación.
 
\end_layout

\begin_layout Itemize
Reveer cambios históricos para auditoría y resolución de problemas.
\end_layout

\begin_layout Subsection
Protocolo PXE
\end_layout

\begin_layout Standard
El protocolo PXE (Preboot Execution Enviroment) es un estándar que les permite
 a computadoras, dentro de una red, que todavía no fueron cargadas con un
 sistema opetativo, ser configuradas e iniciadas remotamente por un administrado
r.
 Utiliza una extensión de opciones del protocolo DHCP.
\end_layout

\begin_layout Standard
En resumen, PXE funciona del siguiente modo:
\end_layout

\begin_layout Standard
El cliente inicializa el protocolo realizando un broadcast de DHCPDISCOVER,
 conteniendo una extensión que identifica la solicitud como la de un cliente
 que utiliza PXE.
 Asumiendo que un servidor DHCP que implementa este protocolo extendido,
 luego de algunos pasos intermedios, el servidor envía al cliente una lista
 de Boot Servers.
 El cliente descubre un Boot Server del tipo seleccionado y recibe el nombre
 de un archivo ejecutable en dicho servidor.
 El cliente utiliza TFTP (Trivial File Transfer Protocol) para descargar
 el ejecutable.
 Finalmente, el cliente inicia la ejecución del la imágen seleccionada.
\end_layout

\begin_layout Standard
Si un cliente es utiliza PXE y el servidor no, el servidor ignoa el código
 PXE previniendo la discontinuidad en las operaciones de DHCP y del Bootstrap
 Protocol.
\end_layout

\begin_layout Standard
PXE especifica los protocoles por los cuales un cliete solicita y descarga
 una imágen ejecutable desde un Boot Server y los mínimos requisitos para
 el entorno de ejecución cuando la imágen es corrida.
\end_layout

\begin_layout Standard
Las ventajas de utilizar PXE incluyen:
\end_layout

\begin_layout Itemize
La máquina cliente no necesariamente necesita un sistema opetarivo o un
 disco rígido.
 
\end_layout

\begin_layout Itemize
Como este protocolo es independiente del vendedor nuevos tipos de computadoras
 pueden ser añadidos a la red.
\end_layout

\begin_layout Subsubsection
PXE APIs
\end_layout

\begin_layout Standard

\series bold
Preboot Services API:
\series default
 Contiene muchas funciones de control e información.
\end_layout

\begin_layout Standard

\series bold
Trivial File Transport Protocol (TFTP) API:
\series default
 Habilita la apertura y cierre de conexiones TFPT, la lectura desde una
 conexión TFTP y la escritura en otra.
\end_layout

\begin_layout Standard

\series bold
User Datagram Protocol (UDP) API:
\series default
 Habilita la apertura y cierre de conexiones TFPT, la lectura desde una
 conexión UDP y la escritura en otra.
\end_layout

\begin_layout Standard

\series bold
Universal Network Driver Interface (UNDI) API:
\series default
 Habilita el control básico de entrada/salida a través de la interfaz de
 red del cliente.
 Esto permite la utilización de protocolos universales de controladores
 para que el mismo controlador pueda ser usado en cualquier interfaz que
 soporte esta API.
\end_layout

\begin_layout Standard
El siguiente diagrama ilustra la relación entre los NBP y las APIs de PXE:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/pxe/pxe_api_1.png
	lyxscale 50
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
APIs de PXE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Funcionamiento de PXE
\end_layout

\begin_layout Enumerate
El cliente realiza un broadcast de un mensaje DHCPDISCOVER al puerto estándar
 DHCP (UDP 67).
 Un campo de opciones en este mensaje contiene:
\end_layout

\begin_deeper
\begin_layout Enumerate
Etiqueta para el identificador del cliente UUID.
\end_layout

\begin_layout Enumerate
Etiqueta para la versión de UNDI (Universal Network Device Interface) del
 cliente.
\end_layout

\begin_layout Enumerate
Etiqueta para la arquitectura del cliente.
\end_layout

\begin_layout Enumerate
La opción 60, Class ID, puesta a to “PXEClient:Arch:xxxxx:UNDI:yyyzzz”.
\end_layout

\end_deeper
\begin_layout Enumerate
El servidor DHCP responde enviando un mensaje DHCPOFFER al cliente en el
 puerto estándar DHCP (UDP 68).
 El mensaje contiene parámetros estándar DHCP:
\end_layout

\begin_deeper
\begin_layout Enumerate
Una dirección IP para el cliente.
\end_layout

\begin_layout Enumerate
Parámetros configurados por el administrador.
\end_layout

\end_deeper
\begin_layout Enumerate
Del DHCPOFFER que es recivido, el cliente guarda:
\end_layout

\begin_deeper
\begin_layout Enumerate
La dirección IP.
\end_layout

\begin_layout Enumerate
Parámetros configurados por el administrador.
\end_layout

\begin_layout Enumerate
Una lista de Boot Servers del campo “Boot Server” en las etiquetas PXE del
 DHCPOFFER.
\end_layout

\end_deeper
\begin_layout Enumerate
El cliente debe enviar una solicitud por la dirección del Boot Server al
 servidor y esperar por el acuse de recibo (acknowledgment – ACK).
\end_layout

\begin_layout Enumerate
El cliente selecciona y descubre un Boot Server.
 Este paquete puede ser enviado por broadcast al puerto 67.
 Este paquete es el mismo que el DHCPDISCOVER inicial en el paso uno,excepto
 que es codificado como DHCPREQUEST y ahora contiene lo siguiente:
\end_layout

\begin_deeper
\begin_layout Enumerate
La IP asignada al cliente por el servidor DHCP.
\end_layout

\begin_layout Enumerate
Una etiqueta con el identificador del cliente (UUID).
\end_layout

\begin_layout Enumerate
Una etiqueta con la versión de UNDI del cliente.
\end_layout

\begin_layout Enumerate
Una etiqueta con la arquitectura del cliente.
\end_layout

\begin_layout Enumerate
La opción 60, Class ID, puesta a to “PXEClient:Arch:xxxxx:UNDI:yyyzzz”.
\end_layout

\begin_layout Enumerate
El tipo de Boot Server en el campo de opciones de PXE.
\end_layout

\end_deeper
\begin_layout Enumerate
El Boot Server envía un paquete DHCPACK unicast al cliente.
 Este ACK contiene:
\end_layout

\begin_deeper
\begin_layout Enumerate
El nombre del archivo ejecutable.
\end_layout

\begin_layout Enumerate
Parámetros de configuración MTFTP.
\end_layout

\begin_layout Enumerate
Otras opciones necesarias para que el NBP pueda ser ejecutado.
\end_layout

\end_deeper
\begin_layout Enumerate
El cliente descarga el archivo ejecutable utilizando TFTP (puerto 69).
 El archivo descargado y la ubicación del código descargado en memoria depende
 de la arquitectura de la CPU del cliente.
\end_layout

\begin_layout Enumerate
El cliente PXE determina si es necesaria la verificación de autenticidad
 del archivo descargado.
 Si se requiere se envía otro DHCPREQUEST preguntando por credenciales.
\end_layout

\begin_layout Enumerate
El cliente inicia la ejecución del código descargado.
\end_layout

\begin_layout Standard
El cliente PXE esperará por la información necesaria unos 60 segundos.
 La etapa DHCPDISCOVER puede repetirse hasta cuatro veces, con tiempos de
 espera de 4,8,16 y 32 segundos respectivamente.
 Si el cliente recive la DHCPOFFER dentro de esl tiempo, se procederá con
 DHCPREQUEST.
 Si no, se detendrá con un error de PXE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/pxe/pxe_proceso.png
	lyxscale 50
	width 15.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Proceso de PXE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Orquestación
\end_layout

\begin_layout Standard
La orquestación describe el alineamiento automatizado, la coordinación y
 la administración de complejos sistemas de computadoras, middleware y servicios.
 En este sentido, la orquestaciónse trata de alinear los requisitos de negocio
 con las aplicaciones, datos e infraestructura.
 Define las políticas y niveles de servicio a través de flujos de trabajo
 automatizados, aprovisionamiento y gestión de cambio.
 Esto crea una infraestructura alineada con la aplicación que puede ser
 escalada hacia arriba o abajo basándose en las necesidades de cada aplicación.
\end_layout

\begin_layout Standard
La orquestación también provee la gestión centralizada de los recursos.
 Por ejemplo, reduce el tiempo y esfuerzo para desplegar múltiples instancias
 de una sola aplicación.
 Cuando es necesario que se creen más instacias de diferentes aplicaciones,
 herramientas automatizadas pueden realizar tareas que, previamente, podían
 ser llevadas a cabo sólo por múltiples administradores.
\end_layout

\begin_layout Standard
Un escenario que se puede encontrar, por ejemplo, un administrador necesita
 desplegar una aplicación web, pero para hacerlo, primero debe crear lel
 servidor de base de datos.
 Luego debe incluir en la base de datos todas las direcciones IP que pueden
 conectarse al servidor, y también agregar este nuevo servidor a la herramienta
 que lo monitorea, o abrir un puerto particular antes de proceder.
 Cada tarea expuesta puede ser automatizada, pero el conjunto de estas automatiz
aciones, junto con la coordinación secuencial de las mismas, realizada sin
 tener en cuenta el tipo de sistema operativo en el que corren, describen
 un proceso, en el cual actúa la orquestación.
\end_layout

\begin_layout Standard
No hay que confundir los términos automatización y orquestación.
 Éstos se podrían comparar con tarea y proceso.
 
\end_layout

\begin_layout Standard
La optimización de un proceso, por ejemplo, no se puede conseguir cimplemente
 por la automatización.
 A la automatización le concierne una tarea: ejecutar un servidor web, configura
r un servidor web, detener un servicio.
 A la orquestación, sin embargo, le concierne la ejecución de un flujo de
 trabajo (si se quiere automatizado) de un proceso.
 Un porceso de aprovisionamiento lleva a cabo múltiples tareas e involucrar
 múltiples sistemas.
 El objetivo de la orquestación no es sólo ejecutar automáticamente un servidor,
 lo cual aumenta la velocidad en el proceso de despliegue y lleva las aplicacion
es a producción más rápido.
 También permite una oportunidad para optimizar aquellos procesos para mejorar
 aún más la velocidad de despliegue.
\end_layout

\begin_layout Standard
Una de las maneras más simples de optimizar un proceso es eliminar los pasos
 repetitivos.
\end_layout

\begin_layout Standard
Entonces, automatización trata acerca de codificar tareas y orquestación
 acerca de codificar procesos.
 Esta última toma ventaja de la automatización para reutilizar bloques básicos.
\end_layout

\begin_layout Subsection
Herramientas de orquestación
\end_layout

\begin_layout Standard
Algunas de las herramientas de código abierto más utilizadas para orquestar
 son las siguientes: 
\end_layout

\begin_layout Itemize
Puppet 
\end_layout

\begin_layout Itemize
Chef 
\end_layout

\begin_layout Itemize
Ansible
\end_layout

\begin_layout Subsubsection
Puppet 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/orquestacion/orquestacion_puppet.png
	lyxscale 75
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Puppet logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es un sistema de orquestación que permite definir el estado de la infraestructur
a, forzando automáticamente que se llegue al estado correcto definido.
\end_layout

\begin_layout Standard
Puppet es una herramienta diseñada para administrar la configuración de
 sistemas similares a Unix y a Microsoft Windows de forma declarativa, es
 decir, se establece el estado requerido en vez como llegar al mismo..
 El usuario describe los recursos del sistema y sus estados utilizando el
 lenguaje declarativo que proporciona Puppet.
 Esta información es almacenada en archivos denominados “manifiestos”.
 Puppet descubre la información del sistema a través de una utilidad llamada
 Facter, y compila los manifiestos en un catálogo específico del sistema
 que contiene los recursos y la dependencia de dichos recursos, estos catálogos
 son ejecutados en los sistemas de destino.
 La capa de abstracción de recursos permite a los administradores describir
 la configuración en términos de alto nivel, tales como usuarios, servicios
 y paquetes sin necesidad de especificar los comandos específicos del sistema
 operativo (como rpm, yum, apt).
\end_layout

\begin_layout Standard
Puppet funciona bajo la arquitectura cliente servidor donde un puppet master
 indica a sus agentes las configuraciones que deben aplicar.
 Además, los masters pueden aplicar manifiestos a sí mismos.
 Notar que hay dos etapas: 
\end_layout

\begin_layout Enumerate
Compilar los catálogos 
\end_layout

\begin_layout Enumerate
Aplicar los catálogos
\end_layout

\begin_layout Standard
Un catálogo es un archivo que describe los deseos de un estado de sistema
 para un nodo en particular.
 Enumera todos los recursos que necesitan ser administrados, así como las
 dependencias entre esos recursos.
\end_layout

\begin_layout Standard
En esta arquitectura, los nodos administrados corren la aplicación puppet-agent,
 usualmente en segundo plano y uno o más servidores corren la aplicación
 puppetmaster administrada por un servidor web (como Apache.) Periódicamente,
 los agentes piden al master el catálogo.
 El master, compila y corre el catálogo del nodo usando varias fuentes de
 información a las que tiene acceso.
 Una vez que recibe el catálogo, el agente chequea cada recurso descrito
 en él.
 Si encuentra algún recurso que no está en el estado deseado, se realizan
 los cambios necesarios para corregirlos.
 Luego de aplicar el catálogo, el agente enviá un reporte al master.
\end_layout

\begin_layout Standard
Los sistemas soportados son Linux (Red Hat Enterprise y derivados, Debian,
 Ubuntu, Fedora), Unix (BSD, Mac OS X, Oracle Solaris, AIX) y Windows.
\end_layout

\begin_layout Subsubsection
Chef 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/orquestacion/orquestacion_chef.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Chef logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es una herramienta de automatización de infraestructura de sistemas o administra
ción de configuraciones.
 Se enfoca en seguir un conjunto de pasos (llamados recetas) con el propósito
 de presentar un producto final ya listo para trabajar y/o probar.
\end_layout

\begin_layout Standard
Existen 2 tipos de versiones: 
\end_layout

\begin_layout Standard

\series bold
Chef Server
\series default
 está enfocado a ser el servidor central que permite suministrar a los diferente
s nodos clientes con las diversas configuraciones necesarias, las cuales
 se mantienen alojadas en el servidor.
 El cliente sondea periódicamente al Chef Server para corroborar las últimas
 políticas y estado de la red, en caso que haya algún parámetro desactualizado,
 el cliente lo actualiza.
 Además ofrece balanceo de carga, escalabilidad, búsquedas rápidas ente
 otros.
\end_layout

\begin_layout Standard

\series bold
Chef Solo
\series default
 es la versión de código abierto y reside localmente en el nodo, esto quiere
 decir que toda la información y recetas necesarias para configurar el nodo
 deben estar presentes en su disco duro.
 Esta herramienta utiliza Ruby-DLS para escribir las “recetas” (configuraciones
 de sistemas que describen como son manejadas las aplicaciones).
 Estas recetas, que pueden ser agrupadas para facilitar la administración,
 describen de forma secuencial una serie de recursos que deben estar en
 un estado particular.
\end_layout

\begin_layout Standard
Chef Server es soportado sobre RHEL/CentOS/Oracle Linux, y Ubuntu.
 Mientras que el soporte para los clients es AIX, RHEL/CentOS, FreeBSD,
 Mac OS X, Solaris (OS), Microsoft Windows, Ubuntu, ArchLinux, Debian, Fedora,
 y otros.
 
\end_layout

\begin_layout Subsubsection
Ansible 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/orquestacion/orquestacion_ansible.png
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ansible logo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es una plataforma para configurar y administrar computadoras.
 Combina instalación multi-nodo, ejecuciones de tareas ad hoc y administración
 de configuraciones.
 
\end_layout

\begin_layout Standard
Ansible distingue dos tipos: controladores y nodos.
 Primero, existe una única máquina de control donde la orquestación comienza.
 Los nodos son manejados desde esa máquina por OpenSSH.
 La máquina de control conoce a los nodos a través de un inventario.
 Esta herramienta usa una arquitectura sin agentes, es decir, los nodos
 no necesitan instalar ni ejecutar en segundo plano ningún proceso que se
 comunique con la máquina de control.
 Sin embargo, los nodos deben contar con Python >= 2.4 y las máquinas de
 control con Python 2.6.
\end_layout

\begin_layout Standard
Dispone de módulos que trabajan sobre JSON y la salida estándar puede ser
 escrita en cualquier lenguaje.
 Nativamente utiliza YAML para describir configuraciones de los sistemas.
\end_layout

\begin_layout Standard
Los sistemas operativos soportados en las máquinas de control son la mayoría
 de las distribuciones Linux y Unix (Red Hat, Debian, CentOS, OSX, y BSD)
 entre otros excepto Windows.
\end_layout

\begin_layout Standard
Ansible puede instalarse en ambientes virtualizados, nubes públicas y privadas,
 incluyendo VMWare, OpenStack, AWS, Eucalyptus, KVM y CloudStack.
\end_layout

\begin_layout Part
Desarrollo
\end_layout

\begin_layout Section
Elección de la plataforma
\end_layout

\begin_layout Standard
Una vez realizada la interiorización de las diferentes herramientas utilizadas
 en el mercado, se decidió unificar la plataforma para el desarrollo del
 Proyecto Integrador.
 
\end_layout

\begin_layout Standard
Al principio se había comenzado a trabajar con FreeBSD, de manera remota
 con un servidor que dispone el Laboratorio de Arquitectura de Computadoras.
 Sin embargo, no se encontraron herramientas de aprovisionamiento y orquestación
 con la suficiente documentación o soporte para este sistema operativo.
 Por lo tanto, como sistema operativo base fue elegido CentOS 7, su última
 versión al día de la fecha.
 Esto es debido a que junto con su versión empresarial, es un sistema operativo
 muy robusto y confiable orientado a servidores y tal vez sea el más utilizado
 en el mercado.
 Además, se tuvo en cuenta la nueva estandarización del iniciador de sistemas,
 systemd, para esta versión del sistema operativo y para gran parte de las
 futuras entregas en diferentes distribuciones Linux, orientadas a servidor
 y también de escritorio.
\end_layout

\begin_layout Standard
Habiendo elegido CentOS 7, se optó por virtualizar haciendo uso de KVM,
 la cual fue desarrollada nativamente para esta distribución de Linux y
 que cuenta con una extensa documentación.
 A su vez, en el Laboratorio de Computación, existe un servidor que utiliza
 esta herramienta para servir a las terminales de ciertas aulas de informática.
 Consultando con los Directores del Proyecto, a profesionales en el tema
 se llegó a la conclusión que KVM es una herramienta estable y apta para
 un entorno de producción.
\end_layout

\begin_layout Standard
Para el aprovisionamiento de máquinas virtuales también por motivos de desarroll
o nativo, recomendación de profesionales que la han utilizado y en base
 a lecturas en foros que tratan este tema, se eligió a Cobbler, ya que es
 la más estable y fiable para entornos de producción.
 También cuenta con soporte integrado para orquestación con Puppet, herramienta
 que fue elegida por ser parte de los requerimientos del Proyecto.
\end_layout

\begin_layout Section
KVM/Qemu
\end_layout

\begin_layout Subsection
Arquitectura
\end_layout

\begin_layout Standard
En este Proyecto se utiliza la técnica de virtualización completa.
 En particular, la arquitectura que utiliza KVM es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/kvm/kvm_arquitectura_1.png
	lyxscale 50
	width 15.5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrama de arquitecura de KVM/Qemu
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Requerimientos de KVM
\end_layout

\begin_layout Standard
El hipervisor KVM requiere que el microprocesador cuente con VT-x para procesado
res de Intel o con AMD -V para los propios de AMD.
 Para poder confirmar que un un procesador cuenta con esto, en los sistemas
 basados en Linux, se debe ejecutar el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
grep -E 'svm|vmx' /proc/cpuinfo 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La salida de este comando es una porción del archivo /proc/cpuinfo en el
 cual se detallan las diferentes flags que contiene el procesador, entre
 ellas, la svm (AMD) o vmx (Intel).
 En caso de no poseer esas flags, el procesador no soporta hiper-virtualización
 y la salida será vacía.
\end_layout

\begin_layout Standard
La siguiente, es la salida obtenida con un AMD Athlon(tm) II P360 Dual-Core
 Processor de 1,7GHz:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat
 pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp
 lm 3dnowext 3dnow constant_tsc rep_good nopl nonstop_tsc extd_apicid pni
 monitor cx16 popcnt lahf_lm cmp_legacy 
\color red
svm
\color inherit
 extapic cr8_legacy abm sse4a 3dnowprefetch osvw ibs skinit wdt nodeid_msr
 hw_pstate npt lbrv svm_lock nrip_save 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Se debe asegurar que el módulo de KVM este cargado, para esto ejecutamos
 :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
lsmod | grep kvm 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La salida obtenida, nuevamente en la misma máquina que en el caso anterior
 es:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
kvm_amd 60554 0 kvm 448375 1 kvm_amd 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En caso de no estar cargados los módulos, se deben cargar manualmente.
\end_layout

\begin_layout Subsection
Restricciones de KVM
\end_layout

\begin_layout Itemize
El número máximo de CPUs por huésped es elevado (240 para RHE 7.1) por lo
 que no aplica en este trabajo.
 
\end_layout

\begin_layout Itemize
La virtualización anidada no está soportada.
 
\end_layout

\begin_layout Itemize
Sobre utilización de memoria es soportada por KVM utilizando el disco de
 swap.
 
\end_layout

\begin_layout Itemize
Sobre utilización de CPUs es soportada por KVM, se recomienda no utilizar
 más de diez CPUs virtuales por cada CPU físico.
\end_layout

\begin_layout Itemize
Virtualización de dispositivos SCSI no está soportada.
 Virtualización de dispositivos IDE en KVM es limitada a cuatro por huésped.
 
\end_layout

\begin_layout Itemize
Soporta 32 slots para dispositivos PCI (paravirtualizados) y 8 de estos
 por cada slot (datos RHE7) 
\end_layout

\begin_layout Itemize
La asignación de dispositivos referenciados a dispositivos físicos son de
 uso exclusivo a la VM .
\end_layout

\begin_layout Itemize
La migración y salvado, o restauración de la VM no está soportada mientras
 el dispositivo esté en uso.
 
\end_layout

\begin_layout Itemize
KVM no soporta kernels de real time.
 
\end_layout

\begin_layout Subsection
Instalación de paquetes de virtualización
\end_layout

\begin_layout Standard
Se deben ejecutar los siguientes comandos:
\end_layout

\begin_layout Standard

\family typewriter
yum update 
\end_layout

\begin_layout Standard

\family typewriter
yum install qemu-kvm qemu-img 
\end_layout

\begin_layout Standard
Y se recomienda la instalación de los siguientes paquetes, con el siguiente
 comando:
\end_layout

\begin_layout Standard

\family typewriter
yum install kvm libvirt python-virtinst qemu-kvm virt-manager libvirt qemu-syste
m-x86 qemu-img libvirt-python libvirt-client virt-install virt-viewer python-vir
tinst
\end_layout

\begin_layout Subsection
Instalación utilizando kickstart con virt-install
\end_layout

\begin_layout Standard
Para conocer como utilizar virt-install revisar el man del mismo con:
\end_layout

\begin_layout Standard

\family typewriter
man virt-install
\end_layout

\begin_layout Standard
Se puede automatizar la instalación de un sistema operativo utilizando un
 kickstart, es decir, un archivo que le indica al sistema operativo como
 debe instalarse, éste, además, permite ejecutar configuraciones pre y pos
 instalación.
 Se indica el archivo kickstart deseado en la creación de la maquina virtual,
 añadiendo la siguiente sección al comando virt-install:
\end_layout

\begin_layout Standard

\family typewriter
--extra-args="ks=http://192.168.100.1/ks.cfg 
\end_layout

\begin_layout Standard
Como se ve, el archivo se llama (en este caso) 
\family typewriter
ks.cfg 
\family default
y est alojado en un host con la direccioón IP 192.18.100.1
\end_layout

\begin_layout Subsection
Booteo por red con libvirt
\end_layout

\begin_layout Standard
Se necesita un servidor para PXE con DHCP y TFTP, dnsmasq y un servidor
 configurado por cobbler.
\end_layout

\begin_layout Subsubsection
Configuración de la red 
\end_layout

\begin_layout Standard
CentOS 7 soporta las siguientes configuraciones de red para la virtualización:
\end_layout

\begin_layout Itemize
Redes virtuales usando NAT (Network Address Translation)
\end_layout

\begin_layout Itemize
Dispositivos físicos distribuidos usando la asignación de dispositivos PCI
\end_layout

\begin_layout Itemize
Redes puenteadas (bridge) 
\end_layout

\begin_layout Standard
Se debe habilitar NAT, bridge o asignar directamente un dispositivo PCI
 para permitir a host externos acceder a los servicios de red en las máquinas
 virtuales huéspedes.
 
\end_layout

\begin_layout Subsubsection
NAT con libvirt 
\end_layout

\begin_layout Standard
Uno de los métodos más comunes para compartir las conexiones de red es usar
 NAT forwading (también conocido como redes virtuales).
 
\end_layout

\begin_layout Subsubsection
Configuración del host 
\end_layout

\begin_layout Standard
Cada instalación estándar de libvirt provee una conectividad basada en NAT
 a las máquinas virtuales como red virtual por defecto.
 Verificar que está disponible con el comando '
\family typewriter
virsh net-list --all
\family default
'.
 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# virsh net-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Nombre 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Estado 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Inicio automático 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Persistente 
\end_layout

\begin_layout Standard

\family typewriter
--------------------------------------------------------------------------------
-----------
\end_layout

\begin_layout Standard

\family typewriter
default
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 activo
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 si
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 si 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Si no se encuentra, lo siguiente puede ser usado en el archivo de configuración
 XML (
\family typewriter
/etc/libvirtd/qemu/myguest.xml
\family default
) para el huésped:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
ll /etc/libvirt/qemu
\end_layout

\begin_layout Standard

\family typewriter
total 24
\end_layout

\begin_layout Standard

\family typewriter
drwxr-xr-x 3 root root 4096 sep 7 11:42 ./
\end_layout

\begin_layout Standard

\family typewriter
drwxr-xr-x 6 root root 4096 sep 1 11:57 ../
\end_layout

\begin_layout Standard

\family typewriter
-rw------- 1 root root 3435 sep 3 10:58 centosLImpio.xml 
\end_layout

\begin_layout Standard

\family typewriter
-rw------- 1 root root 3458 sep 7 11:42 master.xml 
\end_layout

\begin_layout Standard

\family typewriter
drwxr-xr-x 3 root root 4096 sep 1 11:57 networks/ 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La red por defecto está definida desde 
\family typewriter
/etc/libvirt/qemu/networks/default.xml
\end_layout

\begin_layout Standard
Para marcar la red por defecto para iniciar automáticamente:
\end_layout

\begin_layout Standard

\family typewriter
# virsh net-autostart default
\end_layout

\begin_layout Standard

\family typewriter
Network default marked as autostarted
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para iniciar la red por defecto:
\end_layout

\begin_layout Standard

\family typewriter
# virsh net-start default
\end_layout

\begin_layout Standard

\family typewriter
Network default started
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Una vez que la red por defecto de libvirt está corriendo, se verá un dispositivo
 bridge aislado.
 Este dispositivo no tiene ninguna interfaz física añadida.
 El nuevo dispositivo utiliza NAT e IP forwarding para conectarse a la red
 física.
 No añadir nuevas interfaces.
\end_layout

\begin_layout Standard

\family typewriter
# brctl show 
\end_layout

\begin_layout Standard

\family typewriter
bridge name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

bridge id
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 STP enabled 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

interfaces 
\end_layout

\begin_layout Standard

\family typewriter
virbr0 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

8000.000000000000 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
libvirt añade reglas de iptables las cuales permiten el tráfico desde y
 hacia las máquinas virtuales huéspedes unidas al dispositivo virbr0 en
 las cadenas (chains) INOUT, FORWARD, OUTPUT y POSTROUTING.
 libvirt luego intenta habilitar el parámetro ip_forward.
 Algunas otras aplicaciones tal vez deshabiliten ip_forward por lo tanto
 lo mejor es dejar esta configuración fija añadiendo lo siguiente a 
\family typewriter
/etc/sysctl.conf
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
net.ipv4.ip_forward = 1 
\end_layout

\begin_layout Subsubsection
Configuración de las máquinas virtuales huéspedes
\end_layout

\begin_layout Standard
Una vez que la configuración del host está completa, una máquina virtual
 huésped puede ser conectada a la red virtual basada en su nombre.
 Para conectar a un huésped a la red virtual por defecto, lo siguiente puede
 ser utilizado en el archivo de configuración XML para el huésped (
\family typewriter
/etc/libvirtd/qemu/myguest.xml
\family default
):
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
<interface type='network'> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<source network='default'/> 
\end_layout

\begin_layout Standard

\family typewriter
</interface> 
\end_layout

\begin_layout Standard
Definir la dirección MAC es opcional.
 Si no se define una, una dirección MAC es automáticamente generada y usada
 como la dirección MAC del dispositivo bridge utilizado por la red.
 Definirla manualmente es útil para mantener la consistencia o la facilidad
 de referencia a través del ambiente, o para evitar la posibilidad de conflicto
 (muy escasa).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
<interface type='network'>
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<source network='default'/> 
\end_layout

\begin_layout Standard

\family typewriter
<mac address='00:16:3e:1a:b3:4a'/>
\end_layout

\begin_layout Standard

\family typewriter
</interface>
\end_layout

\begin_layout Subsection
Bridged networking
\end_layout

\begin_layout Standard
Bridged networking (también conocido como virtual network switching) es
 usado para poner las interfaces de red de la máquinas virtuales en la misma
 red que la interfaz física.
\end_layout

\begin_layout Subsubsection
Bridged networking con Virtual Machine Manager
\end_layout

\begin_layout Standard
Procedimiento para crear un bridge con virt-manager: 
\end_layout

\begin_layout Enumerate
Desde el menú principal de virt-manager, ir a Editar > Detalles de la Conexión
 > Interfaces de Red (Edit > Connection Details > Network Interfaces) .
\end_layout

\begin_layout Enumerate
Pulsar el ícono + en la parte inferior.
\end_layout

\begin_layout Enumerate
En el Tipo de Interfaz (Interface type) del menú que se despliega, seleccionar
 Bridge y luego continuar.
 
\end_layout

\begin_layout Enumerate
En el campo Nombre (Name) ingresar un nombre como por ejemplo virbr0 o br0.
 
\end_layout

\begin_layout Enumerate
Seleccionar un Modo de inicio (Start mode) del menú desplegable.
 Seleccionar onboot (activa la interfaz bridge en el próximo reinicio de
 la máquina virtual).
\end_layout

\begin_layout Enumerate
Seleccionar la casilla Activar ahora (Activate now) para activarlo inmediatament
e.
 
\end_layout

\begin_layout Enumerate
Para configurar Configuraciones IP (IP settings) o Configuraciones Bridge
 (Bridge settings) realizar los cambios necesarios y pulsar OK al finalizar.
 
\end_layout

\begin_layout Enumerate
Seleccionar la interfaz física para conectar a las máquinas virtuales.
 
\end_layout

\begin_layout Enumerate
Pulsar Finalizar (Finish).
 
\end_layout

\begin_layout Enumerate
Seleccionar el bridge a utilizar y pulsar Aplicar (Apply).
\end_layout

\begin_layout Standard
Para detener la interfaz, pulsar Detener Interfaz (Stop Interface).
 Luego para eliminarla pulsar Delete Interface (Borrar Interfaz).
 
\end_layout

\begin_layout Subsubsection
Utilizar la interfaz por defecto virbr0
\end_layout

\begin_layout Standard
Para utrilizar la interfaz bridge por defecto, en el caso de arranque a
 través de la red por medio de PXE, en el paso 5/5 de la creación de una
 nueva máquina virtual con virt-manager, seleccionar bajo Opciones Avanzadas
 
\begin_inset Quotes eld
\end_inset

Especificar el nombre del dispositivo compartido
\begin_inset Quotes erd
\end_inset

 y en 
\begin_inset Quotes eld
\end_inset

Nombre del bridge
\begin_inset Quotes erd
\end_inset

 ingresar 
\family typewriter
virbr0
\family default
.
 
\end_layout

\begin_layout Subsection
Pools de almacenamiento
\end_layout

\begin_layout Standard
Un pool de almacenamiento es un conjunto de almacenamiento guardado por
 un administrador.
 Los pools de almacenamiento son divididos en volúmenes de almacenamiento
 por los administradores, y los volúmenes son asignados a las VM's como
 dispositivos de bloques.
\end_layout

\begin_layout Standard
Por ejemplo, el administrador de almacenamiento responsable por un servidor
 NFS crea un disco compartido que almacena toda la información de las VM's.
 El administrador definiría un pool de almacenamiento en el host de virtualizaci
ón usando el detalle de disco compartido.
 En este ejemplo, el administrador quiere que 
\family typewriter
nfs.example.com:/path/to/share
\family default
 sea montado en
\family typewriter
 /vm_data
\family default
.
 Cuando el pool es iniciado, libvirt monta el compartido en el directorio
 especifico, tal como lo haría el administrador del sistema logueándose
 y ejecutando mount.
 Si el pool está configurado con autostart, libvirt asegura que el disco
 compartido NFS es montado en el directorio especificado cuando libvirt
 es iniciado.
 Una vez que el pool esté iniciado, el directorio en el disco compartido
 NFS es reportado como un volúmen de almacenamiento y el path de los SV
 (storage volumes) pueden ser consultados por las APIs de libvirt.
 El path del SV puede entonces ser copiado en la sección que describe la
 fuente de almacenamiento en el archivo XML de las VM's para dispositivos
 de bloques.
 En el caso de NFS, una aplicación que usa las APIs de libvirt puede crear
 y eliminar SV en el SP(storage pool).
 No todos los tipos de SP soportan creación y destrucción de volúmenes.
 
\end_layout

\begin_layout Standard
Los SP y SV no son requeridos por la mayoría de las operaciones de las VM's.
 Note que uno de las características de libvirt is el protocolo remoto,
 entonces es posible administrar todos los aspectos de los ciclos de vida
 de las VM's así como las configuraciones de los recursos requeridos por
 las VM's.
 Esas operaciones deben representar a un host remoto con las API de libvirt.
 En otras palabras, un administrador usando aplicaciones de libvirt puede
 asegurar un usuario para desempeñar todas las tareas para configurar la
 maquina física para las VM's.
 Aunque el SP es un contenedor virtual, está limitado por dos factores:
 
\end_layout

\begin_layout Itemize
El tamaño máximo permitido por qemu-kvm y 
\end_layout

\begin_layout Itemize
el tamaño del disco de la máquina física.
\end_layout

\begin_layout Standard
Los siguientes son los tamaños máximos permitidos:
\end_layout

\begin_layout Itemize
virtio-blk -> 8 Exabytes 
\end_layout

\begin_layout Itemize
Ext4 -> 16 Terabytes 
\end_layout

\begin_layout Itemize
XFS -> 8 Exabytes
\end_layout

\begin_layout Standard
Libvirt usa un directorio basado en un SP, el 
\family typewriter
/var/lib/libvirt/images
\family default
, como el SP por defecto.
 Este, puede ser cambiado por otro.
\end_layout

\begin_layout Itemize

\series bold
Local storage pools:
\series default
 Los LSP están directamente unidos a la máquina física servidor.
 Los LSP incluyen : Directorios locales, discos directamente conectados,
 particiones físicas y LVM.
 Esos SV almacenan las imágenes de las VM's o son unidas a la VM's como
 almacenamiento adicional.
 Los LSP no son apropiados para muchos entornos de producción dado que no
 soportan migración en vivo
\end_layout

\begin_layout Itemize

\series bold
Networked storage pools:
\series default
 Loss NSP incluyen almacenamiento de dispositivos compartidos sobre una
 red usando protocolos estándar.
 NSP es requerido cuando las VM's migran entre dos máquinas físicas con
 virt-manager, pero es opcional cuando migran con virsh.
 Los protocolos soportados por los NSP incluyen: 
\end_layout

\begin_layout Itemize
Fibre Channel-based LUNs 
\end_layout

\begin_layout Itemize
iSCSI 
\end_layout

\begin_layout Itemize
NFS 
\end_layout

\begin_layout Itemize
GFS2 
\end_layout

\begin_layout Itemize
SCSI RDMA protocols (SCSI RCP)
\end_layout

\begin_layout Standard
Crear un SP basado en un disco usando virsh.
\end_layout

\begin_layout Enumerate
Crear una etiqueta GTP (GUID partition table) en el disco: 
\end_layout

\begin_layout Standard

\family typewriter
# 
\end_layout

\begin_layout Standard

\family typewriter
parted /dev/sdb 
\end_layout

\begin_layout Standard

\family typewriter
GNU Parted 2.1 
\end_layout

\begin_layout Standard

\family typewriter
Using /dev/sdb Welcome to GNU Parted! Type 'help' to view a list of commands.
 
\end_layout

\begin_layout Standard

\family typewriter
(parted) mklabel 
\end_layout

\begin_layout Standard

\family typewriter
New disk label type? gpt 
\end_layout

\begin_layout Standard

\family typewriter
(parted) quit 
\end_layout

\begin_layout Standard

\family typewriter
Information: You may need to update /etc/fstab.
\end_layout

\begin_layout Standard

\family typewriter
# 
\end_layout

\begin_layout Standard
2.
 Crear archivo de configuración del SP
\end_layout

\begin_layout Standard
Crear un archivo XML temporal conteniendo la información del SP requerida
 por el nuevo dispositivo.
 El archivo debe contener el formato mostrado abajo y contener los siguientes
 campos:
\end_layout

\begin_layout Standard

\series bold
<name>guest_images_disk</name> 
\series default
El parámetro determina el nombre del SP.
\end_layout

\begin_layout Standard

\series bold
<device path = '/dev/sdb' />
\series default
 Especifica el path donde se almacena el dispositivo.
\end_layout

\begin_layout Standard

\series bold
<target> <path>/dev</path></target> 
\series default
Determina la localización en el host físico donde es unido el volúmen creado
 con el SP.
\end_layout

\begin_layout Standard

\series bold
<formattype= 'gpt'/> 
\series default
Especifica el tipo de tabla de la partición.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
A modo de ejemplo se tiene:
\end_layout

\begin_layout Standard

\family typewriter
<pool type='disk'> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<name>guest_images_disk</name>
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<source> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<device path='/dev/sdb'/> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<format type='gpt'/> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

</source> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<target> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<path>/dev</path> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

</target>
\end_layout

\begin_layout Standard

\family typewriter
</pool> 
\end_layout

\begin_layout Standard
3.
 Asignar el dispositivo
\end_layout

\begin_layout Standard
Añadir la definición del storage pool usando el comando virsh pool-define
 con la configuración XML creada en el paso anterior.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-define ~/guest_images_disk.xml 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images_disk defined from /root/guest_images_disk.xml 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images_disk 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

inactive 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no 
\end_layout

\begin_layout Standard
4.
 Iniciar el storage pool 
\end_layout

\begin_layout Standard
Iniciar el storage pool con el comando 
\family typewriter
virsh pool-start
\family default
.
 Verificar que el pool es iniciado con el comando 
\family typewriter
virsh pool-list –all
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-start guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images_disk started 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 State
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images_disk
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no 
\end_layout

\begin_layout Standard
5.
 Habilitar inicio automático
\end_layout

\begin_layout Standard
El inicio automático configura el servicio libvirtd para iniciar el storage
 pool cuando el servicio inicia.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-autostart guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images_disk marked as autostarted 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images_disk 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard
6.
 Verificar la configuración del storage pool
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para verificar que el storage pool fue creado correctamente, los tamaños
 reportados correctamente y el estado sea 
\family typewriter
'running'
\family default
, ejecutar 
\family typewriter
virsh pool-info
\family default
.
 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-info guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Name: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
UUID: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

551a67c8-5f2a-012c-3844-df29b167431c 
\end_layout

\begin_layout Standard

\family typewriter
State: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

running 
\end_layout

\begin_layout Standard

\family typewriter
Capacity: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

465.76 GB 
\end_layout

\begin_layout Standard

\family typewriter
Allocation: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

0.00
\end_layout

\begin_layout Standard

\family typewriter
Available: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

465.76 GB 
\end_layout

\begin_layout Standard

\family typewriter
# ls -la /dev/sdb 
\end_layout

\begin_layout Standard

\family typewriter
brw-rw----.
 1 root disk 8, 16 May 30 14:08 /dev/sdb 
\end_layout

\begin_layout Standard

\family typewriter
# virsh vol-list guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Path
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Subsubsection
Borrar un storage pool utilizando virsh
\end_layout

\begin_layout Standard
1.
 Para evitar inconvenientes con otras máquinas virtuales huéspedes utilizando
 el mismo pool, lo mejor es pararlo y liberar los recursos usados por el
 mismo:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-destroy guest_images_disk
\end_layout

\begin_layout Standard
2.
 Eliminar las definiciones del storage pool:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-undefine guest_images_disk
\end_layout

\begin_layout Subsubsection
Crear sotrage pools basados en directorios con virsh
\end_layout

\begin_layout Standard
1.
 Crear la definición del storage pool
\end_layout

\begin_layout Standard
Usar el comando virsh pool-define-as para definir un nuevo storage pool.
 Hay dos opciones requeridas para la creación de un storage pool basado
 en directorio:
\end_layout

\begin_layout Itemize
El nombre del storage pool
\end_layout

\begin_layout Itemize
El path a un sistema de directorios de archivos para guardar los archivos
 imágenes del huésped.
 Si el directorio no existe, virsh lo creará.
 
\end_layout

\begin_layout Standard
Este ejemplo utilizat el directorio /guest_images.
 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-define-as guest_images dir - - - - "/guest_images" Pool guest_image
s defined
\end_layout

\begin_layout Standard
2.
 Verificar que el storage pool aparece en la lista 
\end_layout

\begin_layout Standard
Verificar que el storage pool es creado correctamente y el estado lo muestra
 como inactivo.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
--------------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

inactive 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no
\end_layout

\begin_layout Standard
3.
 Crear el directorio local
\end_layout

\begin_layout Standard
Usar el comando virsh pool-build para construir el storage pool basado en
 directorio para el directorio guest_images (por ejemplo) como se muestra:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-build guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images built 
\end_layout

\begin_layout Standard

\family typewriter
# ls -la /guest_images 
\end_layout

\begin_layout Standard

\family typewriter
total 8 
\end_layout

\begin_layout Standard

\family typewriter
drwx------.
 2 root root 4096 May 30 02:44 .
 
\end_layout

\begin_layout Standard

\family typewriter
dr-xr-xr-x.
 26 root root 4096 May 30 02:44 ..
 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

inactive 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no 
\end_layout

\begin_layout Standard
4.
 Iniciar el storage pool 
\end_layout

\begin_layout Standard
Usar el comando pool-start para habilitar un directorio de storage pool,
 permitiendo que los volúmenes permitidos del pool sean usados como imágenes
 de disco de los huéspedes.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-start guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images started
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 no 
\end_layout

\begin_layout Standard
5.
 Habilitar inicio automático
\end_layout

\begin_layout Standard
El inicio automático configura el servicio libvirtd para iniciar el storage
 pool cuando el servicio inicia.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-autostart guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images marked as autostarted 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard
6.
 Verificar la configuración del storage pool 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-info guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Name: guest_images 
\end_layout

\begin_layout Standard

\family typewriter
UUID: 779081bf-7a82-107b-2874-a19a9c51d24c 
\end_layout

\begin_layout Standard

\family typewriter
State: running 
\end_layout

\begin_layout Standard

\family typewriter
Persistent: yes 
\end_layout

\begin_layout Standard

\family typewriter
Autostart: yes 
\end_layout

\begin_layout Standard

\family typewriter
Capacity: 49.22 GB 
\end_layout

\begin_layout Standard

\family typewriter
Allocation: 12.80 GB 
\end_layout

\begin_layout Standard

\family typewriter
Available: 36.41 GB 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# ls -la /guest_images 
\end_layout

\begin_layout Standard

\family typewriter
total 8 
\end_layout

\begin_layout Standard

\family typewriter
drwx------.
 2 root root 4096 May 30 02:44 .
 
\end_layout

\begin_layout Standard

\family typewriter
dr-xr-xr-x.
 26 root root 4096 May 30 02:44 ..
 
\end_layout

\begin_layout Standard

\family typewriter
# 
\end_layout

\begin_layout Standard
Para verificar que el storage pool fue creado correctamente, los tamaños
 reportados correctamente y el estado sea 
\family typewriter
'running'
\family default
.
 Si se quiere que el pool sea accesible incluso si la máquina virtual huésped
 no está corriendo, asegurarse que 
\family typewriter
Persistent
\family default
 sea indicado como 
\family typewriter
yes
\family default
.
 Si se quiere que el pool inicie automáticamente cuando comienze el servicio,
 asegurarse que 
\family typewriter
Autostart
\family default
 esté indicado como 
\family typewriter
yes
\family default
.
\end_layout

\begin_layout Subsubsection
Borrar un storage pool utilizando virsh 
\end_layout

\begin_layout Standard
1.
 Para evitar inconvenientes con otras máquinas virtuales huéspedes utilizando
 el mismo pool, lo mejor es pararlo y liberar los recursos usados por el
 mismo:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-destroy guest_images_disk
\end_layout

\begin_layout Standard
2.
 Opcionalmente, si se quiere eliminat el directorio donde el storage pool
 reside, utilizar el siguiente comando:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-delete guest_images_disk
\end_layout

\begin_layout Standard
3.
 Eliminar la definición del storage pool:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-undefine guest_images_disk 
\end_layout

\begin_layout Section
Cobbler
\end_layout

\begin_layout Standard
Para poder alojar las imágenes de los sistemas operativos, el servidor Cobbler
 debe contar con al menos 25 GB de disco.
 Para evitar inconvenientes, deshabilitar SELinux y el firewall, de la siguiente
 forma.
 Editar el archivo /
\family typewriter
etc/sysconfig/selinux
\family default
 y setear:
\end_layout

\begin_layout Standard

\family typewriter
SELINUX=disabled
\end_layout

\begin_layout Standard
En el caso del firewall ejecutar: 
\end_layout

\begin_layout Standard

\family typewriter
systemctl stop firewalld.service
\end_layout

\begin_layout Standard

\family typewriter
systemctl mask firewalld.service 
\end_layout

\begin_layout Standard

\family typewriter
systemctl status firewalld.service
\end_layout

\begin_layout Standard
O bien, si no se desea desactivarlo, permitir el acceso al los siguientes
 puertos de http 80/443, cobbler 69 y 25151.
\end_layout

\begin_layout Subsection
Instalación.
\end_layout

\begin_layout Standard
Primero y principal, Cobbler necesita Python, alguna versión superior a
 la 2.6.
 Además, requiere la instalación de los siguientes paquetes:
\end_layout

\begin_layout Itemize
createrepo
\end_layout

\begin_layout Itemize
httpd (apache2 for Debian/Ubuntu)
\end_layout

\begin_layout Itemize
mkisofs mod_wsgi (libapache2-mod-wsgi for Debian/Ubuntu)
\end_layout

\begin_layout Itemize
mod_ssl (libapache2-mod-ssl)
\end_layout

\begin_layout Itemize
python-cheetah 
\end_layout

\begin_layout Itemize
python-netaddr
\end_layout

\begin_layout Itemize
python-simplejson 
\end_layout

\begin_layout Itemize
python-urlgrabber 
\end_layout

\begin_layout Itemize
PyYAML (python-yaml for Debian/Ubuntu) 
\end_layout

\begin_layout Itemize
rsync 
\end_layout

\begin_layout Itemize
syslinux 
\end_layout

\begin_layout Itemize
tftp-server (atftpd for Debian/Ubuntu) 
\end_layout

\begin_layout Itemize
yum-utils 
\end_layout

\begin_layout Standard
Mientras que cobbler web solo requiere Django (python-django para Debian/Ubuntu).
\end_layout

\begin_layout Standard
Entonces:
\end_layout

\begin_layout Standard

\family typewriter
yum update
\end_layout

\begin_layout Standard

\family typewriter
yum install *
\end_layout

\begin_layout Standard
Se debe añadir los repositorios necesarios para la instalación de Cobbler:
\end_layout

\begin_layout Standard

\family typewriter
wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
\end_layout

\begin_layout Standard

\family typewriter
rpm -Uvh epel-release-*
\end_layout

\begin_layout Standard
Instalar Cobbler junto con: 
\end_layout

\begin_layout Standard

\family typewriter
yum install cobbler cobbler-web dhcp pykickstart system-config-kickstart
 dhcp tftp httpd xinetd fence-agents-all -y
\end_layout

\begin_layout Subsection
Configuración.
\end_layout

\begin_layout Standard
Las siguientes configuraciones deberían ser realizadas antes de comenzar
 a usar Cobbler.
 
\end_layout

\begin_layout Standard
Editar 
\family typewriter
/etc/xinetd.d/tftp
\family default
 modificando 
\family typewriter
disable = yes
\family default
 por no.
 Luego ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
systemctl start rsyncd 
\end_layout

\begin_layout Standard

\family typewriter
systemctl enable rsyncd
\end_layout

\begin_layout Paragraph
Configurar DHCP
\end_layout

\begin_layout Standard
Copiar el archivo de configuración de ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf
\end_layout

\begin_layout Standard
Verificar en cada caso la versión de dhcp.
\end_layout

\begin_layout Standard
Luego editar 
\family typewriter
/etc/dhcp/dhcpd.conf 
\family default
y modificarlo como sea necesario, por ejemplo se tiene:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# A slightly different configuration for an internal subnet.
\end_layout

\begin_layout Standard

\family typewriter
subnet 192.168.100.0 netmask 255.255.255.0 { 
\end_layout

\begin_layout Standard

\family typewriter
range 192.168.100.100 192.168.100.254; 
\end_layout

\begin_layout Standard

\family typewriter
option domain-name-servers puppet; 
\end_layout

\begin_layout Standard

\family typewriter
option domain-name "localdomain"; 
\end_layout

\begin_layout Standard

\family typewriter
option routers 192.168.100.1; 
\end_layout

\begin_layout Standard

\family typewriter
option broadcast-address 192.168.100.255; 
\end_layout

\begin_layout Standard

\family typewriter
default-lease-time 600; 
\end_layout

\begin_layout Standard

\family typewriter
max-lease-time 7200; } 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Añadir a 
\family typewriter
/etc/hosts 
\family default
la dirección del servidor y su hostname (puppet).
 Luego configurar el parámetro 
\family typewriter
ServerName
\family default
 en 
\family typewriter
/etc/httpd/conf/httpd.conf 
\family default
con el nombre del host, en este caso será
\family typewriter
 puppet.
\end_layout

\begin_layout Standard
ServerName puppet
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Inicio y activación de los servicios para inicio automático:
\end_layout

\begin_layout Standard
systemctl start httpd
\family typewriter
.service
\end_layout

\begin_layout Standard
systemctl start dhcpd
\family typewriter
.service
\end_layout

\begin_layout Standard
systemctl start xinetd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
systemctl start cobblerd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
systemctl enable httpd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
systemctl enable dhcpd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
systemctl enable xinetd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
systemctl enable cobblerd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
Al monento de ingresar al servidor por medio de la página web, se pedirá
 usuario y contraseña.
 Por defecto, la contraseña y usuario del servidor es “cobbler”.
 Entonces, se genera una nueva contraseña encriptada con:
\end_layout

\begin_layout Standard

\family typewriter
openssl passwd -1
\end_layout

\begin_layout Standard
Lo que dará algo similar a:
\end_layout

\begin_layout Standard

\family typewriter
Password: Verifying - Password: $1$U.Svb2gw$MNHrAmG.axVHYQaQRySR5/
\end_layout

\begin_layout Standard
Es necesario editar el archivo 
\family typewriter
/etc/cobbler/settings 
\family default
para cambiar la línea 
\family typewriter
“default_password_crypted”
\family default
 con la nueva contraseña generada.
\end_layout

\begin_layout Standard

\family typewriter
default_password_crypted: "$1$U.Svb2gw$MNHrAmG.axVHYQaQRySR5/" 
\end_layout

\begin_layout Standard
Para habilitar la interfaz web de Cobbler y configurar usuario y contraseña,
 modificar las siguientes líneas del archivo 
\family typewriter
/etc/cobbler/modules.conf 
\family default
para que queden de este modo:
\end_layout

\begin_layout Standard

\family typewriter
[authentication] module = authn_configfile
\end_layout

\begin_layout Standard

\family typewriter
[authorization] module = authz_allowall 
\end_layout

\begin_layout Standard
Ahora, para cambiar el usuario y la contraseña para la interfaz web, correr
 el siguiente comando e ingresar la contraseña preferida dos veces:
\end_layout

\begin_layout Standard

\family typewriter
htdigest /etc/cobbler/users.digest "Cobbler" admin
\end_layout

\begin_layout Standard
En este caso el usuario es admin y la contraseña se ingresa luego de ejecutar
 el comando.
 Por defecto se tiene usuario cobbler y contraseña cobbler.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Luego modificar “manage_dhcp: 0” para habilitar que cobbler administre DHCP:
\end_layout

\begin_layout Standard

\family typewriter
manage_dhcp: 1 
\end_layout

\begin_layout Standard
Configurar ahora la dirección IP del servidor Cobbler en las variables “server”
 y “next_server”, por ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
next_server: 192.168.100.200 
\end_layout

\begin_layout Standard

\family typewriter
server: 192.168.100.200 
\end_layout

\begin_layout Standard
EL siguiente paso es modificar el archivo 
\family typewriter
/etc/cobbler/dhcp.template
\family default
 y realizar los cambios necesarios:
\end_layout

\begin_layout Standard

\family typewriter
subnet 192.168.100.0 netmask 255.255.255.0 { 
\end_layout

\begin_layout Standard

\family typewriter
option routers 192.168.100.1; 
\end_layout

\begin_layout Standard

\family typewriter
option domain-name-servers 192.168.100.1; 
\end_layout

\begin_layout Standard

\family typewriter
option subnet-mask 255.255.255.0; 
\end_layout

\begin_layout Standard

\family typewriter
range dynamic-bootp 192.168.100.100 192.168.100.254; 
\end_layout

\begin_layout Standard

\family typewriter
default-lease-time 21600; 
\end_layout

\begin_layout Standard

\family typewriter
max-lease-time 43200; 
\end_layout

\begin_layout Standard

\family typewriter
next-server $next-server; 
\end_layout

\begin_layout Standard

\family typewriter
class "pxeclients" { match if substring (option vendor-class-identifier,
 0, 9) = "PXEClient"; 
\end_layout

\begin_layout Standard

\family typewriter
if option pxe-system-type = 00:02 {
\end_layout

\begin_layout Standard

\family typewriter
filename "ia64/elilo.efi"; 
\end_layout

\begin_layout Standard

\family typewriter
} else if option pxe-system-type = 00:06 {
\end_layout

\begin_layout Standard

\family typewriter
filename "grub/grub-x86.efi"; } 
\end_layout

\begin_layout Standard

\family typewriter
else if option pxe-system-type = 00:07 {
\end_layout

\begin_layout Standard

\family typewriter
filename "grub/grub-x86_64.efi"; } 
\end_layout

\begin_layout Standard

\family typewriter
else { filename "pxelinux.0"; 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Editar el archivo 
\family typewriter
/etc/debmirror.conf
\family default
 comentando lo siguiente:
\end_layout

\begin_layout Standard

\family typewriter
#@dists="sid"; 
\end_layout

\begin_layout Standard

\family typewriter
#@arches="i386"; 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
El próximo paso es descargar los “network boot loaders” con 
\family typewriter
el comnado cobbler get-loaders.
\end_layout

\begin_layout Standard
Por último reiniciar los servicios:
\end_layout

\begin_layout Standard
systemctl restart httpd
\family typewriter
.service
\end_layout

\begin_layout Standard
systemctl restart dhcpd
\family typewriter
.service
\end_layout

\begin_layout Standard
systemctl restart xinetd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
systemctl restart cobblerd
\family typewriter
.service
\family default
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Sincronizar cobbler 
\family typewriter
cobbler sync.
\end_layout

\begin_layout Subsection
Importar imágenes ISO al servidor Cobbler
\end_layout

\begin_layout Standard
Para hacer esto se utiliza el comando mount.
 Primero crear un directorio y luego montar el archivo ISO:
\end_layout

\begin_layout Standard

\family typewriter
mkdir /mnt/centos
\end_layout

\begin_layout Standard

\family typewriter
mount -t iso9660 -o loop,ro /path/to/isos/CentOS-7-x86_64-DVD-1503-01.iso
 /mnt/centos
\end_layout

\begin_layout Standard
Luego ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
cobbler import --name=centos7 --arch=x86_64 --path=/mnt/centos 
\end_layout

\begin_layout Standard
Ésto creará una copia local en el servidor, dando lugar a un nuevo objeto
 
\begin_inset Quotes eld
\end_inset

distro
\begin_inset Quotes erd
\end_inset

 y 
\begin_inset Quotes eld
\end_inset

profile
\begin_inset Quotes erd
\end_inset

.
 Los cuales se pueden verificar con:
\end_layout

\begin_layout Standard

\family typewriter
cobbler distro list
\end_layout

\begin_layout Standard

\family typewriter
cobbler profile list
\end_layout

\begin_layout Subsection
Tópicos generales de Cobbler
\end_layout

\begin_layout Subsubsection
Modelado
\end_layout

\begin_layout Standard
Cobbler utiliza objetos para definir la configuración de aprovisionamiento.
 A medida que se desciende por el árbol de objetos, las variables se sobre
 escriben y se añaden a la información definida en los objetos superiores.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Imagenes/cobbler/cobbler_modelado.png
	lyxscale 50
	width 15.5cm
	height 10cm
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modelado de Cobbler
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Distros
\end_layout

\begin_layout Standard
Distribución que se desea instalar.
 Importar el contenido de la distro ayuda a disminuir el tiempo de instalación
 ya que no se utilizan fuentes de instalación externas.
 Generalmente es más fácil utilizar el comando 
\family typewriter
\emph on
import 
\family default
\emph default
en vez de añadir la distribución manualmente.
\end_layout

\begin_layout Subsubsection
Profiles
\end_layout

\begin_layout Standard
Un perfil o profile asocia una distribución a opciones especializadas adicionale
s, como puede ser un kickstart.
 Los perfiles son el núcleo del aprovisionamiento y debe existir al menos
 uno por cada distribución.
 Un perfil puede representar, por ejemplo, una configuración de web server
 o de escritorio.
\end_layout

\begin_layout Subsubsection
Systems 
\end_layout

\begin_layout Standard
Los grabaciones de sistemas mapean una pieza de hardware (o una máquina
 virtual) con el profile asignado a correr en ella.
 Esto puede verse como una forma de asignarle un rol a un sistema específico.
 Cuando se aprovisiona vía koan y PXE, no es necesario crearlos ya que son
 útiles cuando una personalización de un sistema específico es necesaria.
 Por ejemplo, personalizar la MAC, si hay un rol específico para una máquina
 dada, se debería crear una grabación del sistema para ésta.
\end_layout

\begin_layout Subsubsection
Images 
\end_layout

\begin_layout Standard
Cobbler puede bootear imágenes físicamente o virtualmente.
 Los despliegues de máquinas no basadas en imágenes son generalmente más
 fáciles para trabajar y llevan a una infraestructura más sustentable.
 La mayoría de las instalaciones de cobbler están directamente basadas en
 la distribución (kernel + initrd).
 La siguiente página documenta algunas cosas que no están basadas en kernel
 + initrd y muestra como instalarlas con cobbler y koan.
 Por ejemplo, trata la instalación de sistemas operativos Windows usando
 qemu/KVM: 
\end_layout

\begin_layout Standard

\family typewriter
https://fedorahosted.org/cobbler/wiki/AllAboutImages
\end_layout

\begin_layout Standard

\family typewriter
https://fedorahosted.org/cobbler/wiki/KoanWithIsos
\end_layout

\begin_layout Subsubsection
Repositorios 
\end_layout

\begin_layout Standard
Espejar repositorios le permite a Cobbler espejar el árbol de instalación
 (
\family typewriter
cobbler import
\family default
) y también paquetes opcionales.
 Si se espeja todo esto localmente en la red, las instalaciones y actualizacione
s serán más rápidas (usualmente es válido realizar esto para largos setups
 en datacenters, laboratorios, etc).
 Si un profile tiene un repositorio dado, este repositorio puede ser automáticam
ente configurado durante el aprovisionamiento y los sistemas instalados
 podrán usarlo como espejo (
\family typewriter
yum_post_install_mirror
\family default
 debe estar habilitado).
 Si se especifica una lista de paquetes para –rpm-list, se puede espejar
 solo esa parte del repositorio, más sus dependencias.
 Por ejemplo, si se espeja FC6 Extras, para descargar Cobbler y Koan, ponemos
 
\family typewriter
–rpm-list=”cobbler koan”
\family default
 y se saltea la parte de los paquetes de juegos.
 Esta función sólo funciona para repositorios http o ftp.
\end_layout

\begin_layout Standard
Los repositorios pueden ser creados del siguiente modo:
\end_layout

\begin_layout Standard

\family typewriter
cobbler repo add --mirror=url --name=string [--rpmlist=list] 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset

 [--creatrepo-flags=string] [--keep-updated=Y/N] [--priority=number] [--arch=str
ing] [--mirror-locally=Y/N] [--breed=yum|rsync|rhn]
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Donde
\end_layout

\begin_layout Standard

\series bold
mirror:
\series default
 Es la dirección del espejo yum.
 Puede ser una URL rsync:// , una ubicación ssh o una ubicación http://
 o ftp:// de un espejo.
 Direcciones del filesystem tabién funcionan.
 Esta dirección debe especificar un repositorio exacto a espejar, solo una
 arquitectura y una distribución.
\end_layout

\begin_layout Standard

\series bold
name: 
\series default
Este nombre es el usado para guardar la ubicación del espejo.
\end_layout

\begin_layout Standard

\series bold
rpm-list:
\series default
 Con esta opción se puede decidir espejar solo una parte de un repositorio
 (la lista de paquetes dados más dependencias).
 Por ejemplo : 
\family typewriter
--rpm-list="paquete_1 paquete_2"
\family default
.
 Esta opción sólo funciona con repositorios http:// y ftp:// para espejos
 de otros tipos esta opción será ignorada.
\end_layout

\begin_layout Standard

\series bold
createrepo-flags:
\series default
 Especifica banderas opcionales para añadir a la herramienta 
\family typewriter
createrepo
\family default
 la cual es llamada cuando se ejecuta 
\family typewriter
cobbler reposync
\family default
 para el repositorio dado.
 Por defecto se tiene 
\family typewriter
’-c cache’
\family default
.
\end_layout

\begin_layout Standard

\series bold
keep-updated: 
\series default
Especifica si el repositorio debería ser o no actualizado durante una ejecución
 normal de 
\family typewriter
cobbler reposync
\family default
.
 El repositorio puede seguir siendo actualizado por el nombre.
\end_layout

\begin_layout Standard

\series bold
mirror-locally: 
\series default
Cuando se configura a N, especifica que este repositorio yum se utiliza
 para ser referenciado directamente por kickstarts y no para ser espejado
 localmente en el servidor cobbler.
 Solo espejos con URLs http:// y ftp:// son soportados cuando se utiliza
 
\family typewriter
--mirror-locally=N
\family default
, no se puede usar URLs del filesystem.
\end_layout

\begin_layout Standard

\series bold
priority: 
\series default
Especifica la prioridad del repositorio (menor número, mayor prioridad)
 que se aplica a máquinas instaladas usando los repositorios que tienen
 el plugin yum priorities instalado.
 Por defecto se tiene 99.
\end_layout

\begin_layout Standard

\series bold
arch: 
\series default
Especifica la arquitectura que el repositorio debeía utilizar.
 Por defect se utiliza la arquitectura del servidor cobbler.
\end_layout

\begin_layout Standard

\series bold
breed: 
\series default
Usualmente cobbler comprenderá este parámetro si no se entrega.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para crear un repositorio local, por ejemplo para instalar Puppet en una
 instalación desde cero, y sin una conexión a Internet, primero es necesario
 tener los paquetes necesarios y sus dependencias, para ello se ejecuta:
\end_layout

\begin_layout Standard

\family typewriter
sudo yum install --downloadonly --downloaddir=<directory> <package>
\end_layout

\begin_layout Standard
Donde se debe reemplazar 
\family typewriter
<directory> 
\family default
por el directorio donde se descargará el paquete con sus dependencias y
 
\family typewriter
<package>
\family default
 por el 
\family typewriter
puppet.
\end_layout

\begin_layout Standard
Una vez obtenidos, crear una carpeta con el nombre del repositorio en 
\family typewriter
/var/www/cobbler/repo_mirror 
\family default
por ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
sudo mkdir /var/www/cobbler/repo_mirror/puppet
\end_layout

\begin_layout Standard
Luego es necesario añadirlo al servidor:
\end_layout

\begin_layout Standard

\family typewriter
cobbler repo add --name=puppet --keep-updated=N --arch=x86_64 --mirror-locally=Y
 --breed=yum
\end_layout

\begin_layout Standard
Donde 
\family typewriter
--name 
\family default
debe ser el mismo que el de la carpeta creada anteriormente.
 Acto seguido ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
createrepo /var/www/cobbler/repo_mirror/puppet
\end_layout

\begin_layout Standard

\family typewriter
cobbler reposync
\end_layout

\begin_layout Standard
Para añadir este nuevo repositorio a un profile de instalación existente:
\end_layout

\begin_layout Standard

\family typewriter
cobbler profile edit --name=centos7 --repos=puppet 
\end_layout

\begin_layout Standard
Se muestra la información acerca del mismo con:
\end_layout

\begin_layout Standard

\family typewriter
cobbler repo report --name=puppet
\end_layout

\begin_layout Subsubsection
Repositorio local separado de Cobbler.
\end_layout

\begin_layout Standard
En el caso que se desee crear un repositorio local que no dependa del servidor
 Cobbler, se debe primero instalar los servicios necesarios para el funcionamien
to del servicio de repositorios:
\end_layout

\begin_layout Standard

\family typewriter
sudo yum install -y createrepo vsftpd lftp
\end_layout

\begin_layout Standard
Una vez hecho ésto, se tiene que crear el árbol de directorios adecuado
 de acuerdo a la aplicación.
 Éste puede estar divido como se desee, por ejemplo, por sistema operativo,
 por distribución, por arquitectura, etc.
\end_layout

\begin_layout Standard
Se recomienda utilizar como base el directorio 
\family typewriter
/var/ftp 
\family default
dado que se utilizará este sistema de transmisión de archivos.
\end_layout

\begin_layout Standard
Una vez creado el sistema de archivos, se guardan los correspondientes paquetes
 rpm en los lugares adecaudos, acordes a cómo se haya creado el árbol de
 archivos, y se ejecuta el siguiente comando:
\end_layout

\begin_layout Standard

\family typewriter
creterepo -v /var/ftp/nombre_repo.repo
\end_layout

\begin_layout Standard
Es necesario entonces configurar el demonio 
\family typewriter
vsftpd
\family default
 editando el archivo 
\family typewriter
/etc/vsftpd/vsftpd.conf
\family default
.
 Hay diversas configuraciones posibles, pero hay dos puntos importantes
 que deben existir:
\end_layout

\begin_layout Enumerate

\family typewriter
anonymous_enable=YES
\family default
: Indica que se puede acceder vía ftp de manera anónima.
\end_layout

\begin_layout Enumerate

\family typewriter
anon_root=/var/ftp
\family default
:Indica la raíz del directorio al cual se puede acceder de manera anónima.
\end_layout

\begin_layout Standard
Además, añadir la regla adecuada al firewall para permitir el acceso al
 puerto 21 o en su defecto, desactivar el firewall.
\end_layout

\begin_layout Standard
Por último, iniciar el servicio:
\end_layout

\begin_layout Standard

\family typewriter
systemctl start vsftpd
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En el lado del cliente es necesario informar del nuevo repositorio.
 Para ésto, crear un archivo en 
\family typewriter
/etc/yum.repos.d/nombredelrepo.repo 
\family default
con el siguiente contenido:
\end_layout

\begin_layout Standard

\family typewriter
[nombredelrepo] 
\end_layout

\begin_layout Standard

\family typewriter
name=nombredelrepo
\end_layout

\begin_layout Standard

\family typewriter
comment ="Repositorio local para proyecto integrador" 
\end_layout

\begin_layout Standard

\family typewriter
baseurl=ftp://IP_servidor/nombre_del_sistema_de_archivos
\end_layout

\begin_layout Standard

\family typewriter
gpgcheck=0 
\end_layout

\begin_layout Standard

\family typewriter
enabled=1
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para utilizar este repositorio primero hay que habilitarlo:
\end_layout

\begin_layout Standard

\family typewriter
yum --enablerepo="nombredelrepo.repo"
\end_layout

\begin_layout Standard
Luego es necesario actualizar base de datos de repositorios:
\end_layout

\begin_layout Standard

\family typewriter
yum makecache
\end_layout

\begin_layout Standard
Al momento de instalar un paquete, yum pedirá la clave pública GPG, si no
 se tiene instalada, se puede importar con el comando:
\end_layout

\begin_layout Standard

\family typewriter
rpm --import public.gpg.key
\end_layout

\begin_layout Standard
En caso de no se tenga clave pública alguna, es posible desactivar la verificaci
ón de la misma en 
\family typewriter
/etc/yum.conf
\family default
 poniendo a cero el valor de 
\family typewriter
gpgcheck.
\end_layout

\begin_layout Standard
Es posible utilizar sólo el repositorio recién creado y excluir los demás,
 para ello:
\end_layout

\begin_layout Standard

\family typewriter
yum --disablerepo=* --enablerepo=nombredelrepo install paquete
\end_layout

\begin_layout Subsubsection
Buildiso
\end_layout

\begin_layout Standard
Frecuentemente un entorno no puede soportar PXE porque otro grupo posee
 el control sobre las configuraciones DHCP y no entregará una entrada de
 
\family typewriter
next-server
\family default
 o sólo se están usando IPs estáticas.
 Esto se soluciona fácilmente:
\end_layout

\begin_layout Standard

\family typewriter
# cobbler buildiso
\end_layout

\begin_layout Standard
Este comando copia todos el kernel/initrd de la distro a una 'imagen de
 CD' booteable y genera un menú para la ISO que es esencialmente equivalente
 al menú PXE provisto para la instalación de máquinas por red vía Cobbler.
 Por defecto el menú del CD booteable va a incluir todos los profiles y
 systems.
\end_layout

\begin_layout Standard
Si se necesita instalar en un laboratorio u otro ambiente que no tenga acceso
 por red al servidor cobbler, se puede copiar completamente el árbol de
 la distribución más el profile y los systems records a una imagen.
\end_layout

\begin_layout Standard

\family typewriter
# cobbler buildiso --standalone –distro="distro1" 
\end_layout

\begin_layout Subsubsection
Import
\end_layout

\begin_layout Standard
El propósito de “
\family typewriter
cobbler import
\family default
” es configurar un servidor de instalación por red para una o más distribuciones.
 Éste espeja contenido basado en un imagen DVD, un archivo ISO, un árbol
 en un filesystem, un espejo externo rsync o una ubicación SSH.
\end_layout

\begin_layout Standard

\family typewriter
$ cobbler import --path=/path/to/distro –name=F12
\end_layout

\begin_layout Standard
Este ejemplo muestra los dos argumentos requeridos para import: --path y
 –name.
\end_layout

\begin_layout Standard
Luego de que import es ejecutado, cobbler tratará de detectar el tipo de
 distribución y automáticamente asignar kickstarts.
 Por defecto, proveerá el sistema borrando el disco duro, configurando eth0
 para DHCP y utilizando la contraseña por defecto “cobbler”.
 Si esto no es deseado, editar los archivos kickstart en 
\family typewriter
/var/lib/cobbler/kickstarts
\family default
 para hacer algo distinto o cambiar la configuración del kickstart después
 que cobbler cree el profile.
 El contenido espejado es guardado automáticamente en 
\family typewriter
/var/www/cobbler/ks_mirror
\family default
.
 
\end_layout

\begin_layout Standard
Ejemplos:
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=rsync://mirrorserver.example.com/path/ --name=fedora
 --arch=x86
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=root@192.168.1.10:/stuff --name=bar
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/mnt/dvd --name=baz --arch=x86_64
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/path/to/stuff –name=glorp
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/path/where/filer/is/mounted --name=anyname 
\backslash
 --available-as=nfs://nfs.example.org:/where/mounted/
\end_layout

\begin_layout Standard
Una vez importado, ejecutar “
\family typewriter
cobbler list
\family default
” o “
\family typewriter
cobbler report
\family default
” para ver que se ha añadido.
 Si se quiere forzar la utilización de una plantilla kickstart de cobbler
 para todos los profiles creados por un import, se puede pasar la opción
 
\family typewriter
–kickstart
\family default
 a import para saltar la auto detección del kickstart.
\end_layout

\begin_layout Subsubsection
Kickstarts
\end_layout

\begin_layout Standard
Los kickstarts son archivos que indican cómo debe ser configurado el sistema
 operativo, el archivo contiene palabras claves, valores y en otros casos
 solo contienen la palabra clave que en sí misma es una configuracion especifica.
 
\end_layout

\begin_layout Standard
Algunas palabras clave (keywords) son opcionales, mientras que otras son
 necesarias para la instalación.
\end_layout

\begin_layout Paragraph
Keywords
\end_layout

\begin_layout Itemize

\series bold
autopart (optional)
\series default
 : Creación automática de particiones, 1 GB o más para el directorio raíz
 ( / ), una partición de intercambio y una partición de arranque apropiada
 para la arquitectura .
 Uno o más de los tamaños de las particiones por defecto puede ser redefinido
 con la zona de directivas.
\end_layout

\begin_layout Itemize

\series bold
ignoredisk (optional)
\series default
 : Hace que el instalador ignore los discos especificados.
\end_layout

\begin_deeper
\begin_layout Standard
La sintaxis es:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

dignoredisk --drives=drive1,drive2,...
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
auth or authconfig (required) :
\series default
Establece las opciones de autenticación para el sistema.
 Es similar al comando authconfig , que se puede ejecutar después de la
 instalación .
 Por defecto, las contraseñas son encriptadas y no utilizan shadow .
\end_layout

\begin_layout Itemize

\series bold
bootloader (required): 
\series default
Especifica cómo se debe instalar el gestor de arranque.
\end_layout

\begin_layout Itemize

\series bold
clearpart (optional) :
\series default
 Elimina las particiones del sistema, antes de la creación de nuevas particiones
 .
 Por defecto no se eliminan las particiones .
\end_layout

\begin_layout Itemize

\series bold
cmdline (optional) : 
\series default
Realiza la instalación en un modo de línea de comandos completamente no
 interactivo.
 Cualquier solicitud por interacciones detendrá la instalación.
\end_layout

\begin_layout Itemize

\series bold
device (optional) : 
\series default
El comando de dispositivo , indica al programa de instalación para instalar
 módulos adicionales , es en este formato :
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

device <type><moduleName> --opts=<options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
driverdisk (optional) : 
\series default
Disquetes de controladores se pueden usar durante instalaciones kickstart.
\end_layout

\begin_layout Itemize

\series bold
firewall (optional) : 
\series default
Esta opción corresponde a la pantalla de configuración de firewall en el
 programa de instalación.
\end_layout

\begin_layout Itemize

\series bold
firstboot (optional) :
\series default
 Determinar si el agente de configuración se inicia la primera vez que se
 arranca el sistema .
 Si se activa, el paquete firstboot debe estar instalado.
 Si no se especifica, esta opción está desactivada por defecto.
\end_layout

\begin_layout Itemize

\series bold
halt (optional) : 
\series default
Detiene el sistema después de que la instalación se ha completado con éxito
 .
 Esto es similar a una instalación manual, en donde Aanaconda muestra un
 mensaje y espera a que el usuario presione una tecla antes de reiniciar.
 Durante una instalación Kickstart, si no se especifica el método de terminación
, la opción reboot se utiliza como predeterminado.
\end_layout

\begin_layout Itemize

\series bold
graphical (optional) : 
\series default
Realice la instalación kickstart en modo gráfico .
 Este es el valor predeterminado .
\end_layout

\begin_layout Itemize

\series bold
install (optional) : 
\series default
Le dice al sistema para instalar un sistema nuevo en lugar de actualizar
 un sistema existente.
 Este es el modo por defecto.
 
\end_layout

\begin_layout Itemize

\series bold
ignore disk (optional) : 
\series default
Se utiliza para especificar los discos que Aanaconda no debe tocar durante
 la partición , el formato, y la limpieza .
 Este comando tiene un único argumento necesario , que toma una lista separada
 por comas de nombres de unidad de ignorar.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

ignoredisk --drives=[disk1,disk2,...]
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
interactive (optional) : 
\series default
Utiliza la información proporcionada en el archivo kickstart durante la
 instalación, pero permite la inspección y modificación de los valores dados
 .
 Se le presentará con cada pantalla del programa de instalación con los
 valores del archivo kickstart .
 Puede aceptar los valores haciendo clic en Siguiente o cambiar los valores
 y haga clic en Siguiente para continuar.
\end_layout

\begin_layout Itemize

\series bold
key (optional): 
\series default
Especifique una clave de instalación, que es necesaria para ayudar en la
 selección de paquetes e identificar su sistema con fines de apoyo.
 Este comando es Red Hat Enterprise Linux específico.
\end_layout

\begin_layout Itemize

\series bold
keyboard (required) : 
\series default
Establece el tipo de teclado.
\end_layout

\begin_layout Itemize

\series bold
lang (required) : 
\series default
Establece el idioma que desea utilizar durante la instalación y el idioma
 predeterminado para utilizar en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
logvol (optional) : 
\series default
Crea un Logical Voume con la sintaxis:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

logvol <mntpoint> --vgname=<name> --size=<size> --name=<name><options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
logging (optional) : 
\series default
Este comando controla el registro de errores de Aanaconda durante la instalación.
 No tiene ningún efecto en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
monitor (optional) : 
\series default
Si no se da el comando monitor, Aanaconda utilizará X para detectar automáticame
nte la configuración del monitor.
\end_layout

\begin_layout Itemize

\series bold
network (optional) : 
\series default
Configura la información de red para el sistema.Si la instalación no requiere
 redes y la información de la red no se proporciona en el archivo kickstart,
 el programa de instalación asume que la instalación debe hacerse sobre
 eth0 a través de una dirección IP dinámica ( BOOTP / DHCP), y configura
 el sistema final, instalado para determinar su dirección IP de forma dinámica.
 
\end_layout

\begin_layout Itemize

\series bold
part or partition (required for installs, ignored for upgrades) : 
\series default
Crea una partición en el sistema.
\end_layout

\begin_layout Itemize

\series bold
poweroff (optional) : 
\series default
Apaga el sistema luego de que la instación se complete exitosamente.
\end_layout

\begin_layout Itemize

\series bold
raid (optional) : 
\series default
Monta un sistema RAID.
\end_layout

\begin_layout Itemize

\series bold
reboot (optional) : 
\series default
Reinicia el sistema después de una instalación exitosa.
\end_layout

\begin_layout Itemize

\series bold
repo (optional) : 
\series default
Configura un repositorio adicional YUM que puede ser utilizado como fuente
 para la instalación de paquetes.
\end_layout

\begin_layout Itemize

\series bold
rootpw (required) : 
\series default
Establece la contraseña de root.
\end_layout

\begin_layout Itemize

\series bold
selinux (optional) : 
\series default
Establece el estado del SElinux en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
services (optional) :
\series default
Modifica el conjunto predeterminado de servicios que se ejecutarán bajo
 el nivel de ejecución predeterminado.
\end_layout

\begin_layout Itemize

\series bold
shutdown (optional) : 
\series default
Apaga el sistema después de una instalación exitosa.
\end_layout

\begin_layout Itemize

\series bold
text (optional) : 
\series default
Realiza la instalación kickstart en modo texto.
 Las instalaciones Kickstart se ejecutan en modo gráfico por defecto.
\end_layout

\begin_layout Itemize

\series bold
timezone (required) : 
\series default
Selecciona la zona horaria del sistema.
\end_layout

\begin_layout Itemize

\series bold
upgrade (optional) : 
\series default
Indica que se realiza una actualización del sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
user (optional) :
\series default
 Crea usuario en el sistema.
\end_layout

\begin_layout Itemize

\series bold
vnc (optional) : 
\series default
Permite que la instalación gráfica pueda ser vista de forma remota a través
 de VNC.
\end_layout

\begin_layout Itemize

\series bold
volgroup (optional) : 
\series default
Crea logical volume group con la sintaxis:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

volgroup <name><partition><options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
zerombr (optional) : 
\series default
Si se especifica zerombr, y si es su único argumento, cualquier tabla de
 partición no válidas que se encuentran en los discos son inicializadas.
 Esto destruye todos los contenidos de discos con tablas de partición inválidas.
 
\end_layout

\begin_layout Subsubsection
Snippets
\end_layout

\begin_layout Standard
Los snippets son una forma de reutilizar bloques de código entre kickstarts
 (también funcionan en otros tipos de archivos).
 Esto quiere decir que cada vez que el texto SNIPPET aparezca en un archivo
 kickstart será reemplazado por los contenidos en el archivo correspondiente
 dentro de 
\emph on
/var/lib/cobbler/snippets/.
 
\emph default
Esto permite la reutilización de código en cada plantilla, aliviando también
 la lectura de las mismas.
\end_layout

\begin_layout Standard
Para utilizar un snippet, es necesario crear un archivo en el directorio
 
\emph on
/var/lib/cobbler/snippets/nuevo_snippet 
\emph default
y, en un archivo kickstart, al momento de llamar a esta porción de código
 se utiliza:
\end_layout

\begin_layout Standard

\family typewriter
\emph on
$SNIPPET('nuevo_snippet')
\end_layout

\begin_layout Standard
Los snippets pueden ser guardados en subdirectorios para una mejor organización.
 El orden de precedencia será como sigue:
\end_layout

\begin_layout Standard

\family typewriter
\emph on
/var/lib/cobbler/snippets/$subdirectorio/$nombre_del_snippet 
\end_layout

\begin_layout Standard
Para referenciarlo desde el archivo kickstart, ahora se tiene:
\end_layout

\begin_layout Standard

\family typewriter
\emph on
$SNIPPET('direcorio/nuevo_snippet ')
\end_layout

\begin_layout Standard
Cobbler no reconoce caracteres que no estén en el alfabeto inglés, por este
 motivo se recomienda no utilizar caracteres especiales como 
\emph on
ñ
\emph default
 u otros que lleven tilde.
\end_layout

\begin_layout Subsubsection
Firewall
\end_layout

\begin_layout Standard
Dependiendo del uso, será necesario asegurar que está configurado para permitir
 el acceso a los servicios correctos.
 Un ejemplo de configuración es el siguiente:
\end_layout

\begin_layout Standard
# Firewall configuration written by system-config-securitylevel
\end_layout

\begin_layout Standard
# Manual customization of this file is not recommended.
 
\end_layout

\begin_layout Standard
*filter :INPUT ACCEPT [0:0]
\end_layout

\begin_layout Standard
:FORWARD ACCEPT [0:0] 
\end_layout

\begin_layout Standard
:OUTPUT ACCEPT [0:0]
\end_layout

\begin_layout Standard
-A INPUT -p icmp --icmp-type any -j ACCEPT
\end_layout

\begin_layout Standard
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
\end_layout

\begin_layout Standard
# LOCALHOST
\end_layout

\begin_layout Standard
-A INPUT -i lo -j ACCEPT
\end_layout

\begin_layout Standard
# SSH
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT 
\end_layout

\begin_layout Standard
# DNS 
\end_layout

\begin_layout Standard
- TCP/UDP -A INPUT -m state --state NEW -m udp -p udp --dport 53 -j ACCEPT
 -A INPUT -m state --state NEW -m tcp -p tcp --dport 53 -j ACCEPT 
\end_layout

\begin_layout Standard
# DHCP 
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m udp -p udp --dport 68 -j ACCEPT 
\end_layout

\begin_layout Standard
# TFTP
\end_layout

\begin_layout Standard
- TCP/UDP -A INPUT -m state --state NEW -m tcp -p tcp --dport 69 -j ACCEPT
 -A INPUT -m state --state NEW -m udp -p udp --dport 69 -j ACCEPT 
\end_layout

\begin_layout Standard
# NTP
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m udp -p udp --dport 123 -j ACCEPT 
\end_layout

\begin_layout Standard
# HTTP/HTTPS
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A INPUT
 -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT 
\end_layout

\begin_layout Standard
# Syslog for cobbler
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m udp -p udp --dport 25150 -j ACCEPT 
\end_layout

\begin_layout Standard
# Koan XMLRPC ports 
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m tcp -p tcp --dport 25151 -j ACCEPT -A INPUT
 -m state --state NEW -m tcp -p tcp --dport 25152 -j ACCEPT
\end_layout

\begin_layout Standard
#-A INPUT -j LOG 
\end_layout

\begin_layout Standard
-A INPUT -j REJECT --reject-with icmp-host-prohibited
\end_layout

\begin_layout Standard
COMMIT
\end_layout

\begin_layout Subsubsection
SELinux
\end_layout

\begin_layout Standard
SI no se desea desactivarlo, para permitir el acceso del servidor web Apache
 por SELinux se puede hacer:
\end_layout

\begin_layout Standard

\family typewriter
setsebool -P httpd_can_network_connect true
\end_layout

\begin_layout Subsubsection
PXE
\end_layout

\begin_layout Standard
La instalación en máquinas “bare metal” desde la red utilizando PXE es directa.
 Se necesita configurar DHCP: 
\end_layout

\begin_layout Itemize
Si el servidor DHCP está en otro lado y no en el servidor Cobbler, se debe
 setear “
\family typewriter
next-server
\family default
” para especificar el servidor Cobbler.
 
\end_layout

\begin_layout Itemize
Si se está corriendo DHCP localmente y se quiere que Cobbler lo administre,
 se debe configurar la variable manage_dhcp a 1 en 
\family typewriter
/etc/cobbler/settings
\family default
, editar 
\family typewriter
/etc/cobbler/dhcp.template
\family default
 para cambiar configuración por defecto y ejecutar “
\family typewriter
cobbler sync
\family default
”.
\end_layout

\begin_layout Standard
Una vez que se tenga el PXE configurado, todos los profiles compatibles
 aparecerá por nombre en el menú de booteo PXE.
 Se puede seleccionar uno de la lista o por defecto la máquina booteará
 localmente.
 Si se quiere adjuntar un sistema particular a un profile particular la
 próxima vez que reinicie, se debe ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
cobbler system add --name=example --mac=$mac-address --profile=$profile-name
 
\end_layout

\begin_layout Standard
Luego la máquina booteará directamente con el profile seleccionado sin mostrar
 el menú.
\end_layout

\begin_layout Subsubsection
Reinstalación
\end_layout

\begin_layout Standard
Si se necesita reinstalar un sistema operativo a una máquina que tiene corriendo
 uno distinto, se puede utilizar:
\end_layout

\begin_layout Standard

\family typewriter
yum install koan 
\end_layout

\begin_layout Standard

\family typewriter
koan --server=bootserver.example.com --list=profiles koan --replace-self --server=
bootserver.example.com --profile=F12-i386 /sbin/reboot
\end_layout

\begin_layout Standard
El sistema instalará el nuevo sistema operativo luego del reinicio, sin
 interacción requerida.
\end_layout

\begin_layout Subsubsection
Virtualización
\end_layout

\begin_layout Standard
Si se quiere instalar un huésped virtual (KVM o Xen) se puede hacer:
\end_layout

\begin_layout Standard

\family typewriter
yum install koan
\end_layout

\begin_layout Standard

\family typewriter
koan --server=bootserver.example.com --virt --virt-type=xenpv –profile=F12-i386-xe
n
\end_layout

\begin_layout Standard
Se puede utilizar KVM u otro método de virtualización.
\end_layout

\begin_layout Subsubsection
Integración con Puppet
\end_layout

\begin_layout Standard
Este ejemplo es relativamente avanzado, involucrando “
\family typewriter
mgmt-classes
\family default
” de Cobbler para controlar diferentes tipos de configuración inicial.
 Pero si en cambio se opta por poner la mayor parte de la configuración
 inicial en Puppet en vez de aquí, entonces podría ser más simple.
\end_layout

\begin_layout Paragraph
Manter class mappings en cobbler
\end_layout

\begin_layout Standard
Primero se debe asignar “
\family typewriter
management classes
\family default
” a la distro, profile o system.
\end_layout

\begin_layout Standard

\family typewriter
cobbler distro edit --name=distro1 --mgmt-classes="distro1" 
\end_layout

\begin_layout Standard

\family typewriter
cobbler profile add --name=webserver --distro=distro1 --mgmt-classes="webserver
 likes_llamas" --kickstart=/etc/cobbler/my.ks 
\end_layout

\begin_layout Standard

\family typewriter
cobbler system edit --name=system --profile=webserver --mgmt-classes="orange"
 –dns-name=system.example.org
\end_layout

\begin_layout Standard
Para Puppet el –dns-name (mostrado arriba) debe estar configurado porque
 esto es lo que Puppet estará enviando a Cobbler y es como encontrará el
 sistema.
 Puppet no tiene conocimiento sobre el nombre del sistema objeto en Cobbler.
 Para hacerlo de forma segura, probablemente se utilice FQDN aquí (lo cual
 es lo que se quiere si se utiliza cobbler para administrar DNS).
 
\end_layout

\begin_layout Paragraph
External Nodes 
\end_layout

\begin_layout Standard
Cobbler provee uno, así configura Puppet para usar 
\family typewriter
/usr/bin/cobbler-ext-nodes
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
[main] 
\end_layout

\begin_layout Standard

\family typewriter
external_nodes = /usr/bin/cobbler-ext-nodes 
\end_layout

\begin_layout Standard
y también añadir lo siguiente al archivo de configuración: 
\end_layout

\begin_layout Standard

\family typewriter
node_terminus = exec
\end_layout

\begin_layout Standard
Ésto es un script simple que toma el información en la siguiente URL, la
 cual es una URL que siempre retorna un documento YAML en la forma que Puppet
 espera que sea retornado.
 Este archivo contiene todos los parámetros y clases que están para ser
 asignadas en el nodo en cuestión.
 Esta URL de Cobbler es: 
\family typewriter
http://cobbler/cblr/svc/op/puppet/hostname/foo
\end_layout

\begin_layout Standard
y esto retornará datos como: 
\end_layout

\begin_layout Standard

\family typewriter
--- classes: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- distro1 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- webserver 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- likes_llamas 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- orange 
\end_layout

\begin_layout Standard

\family typewriter
parameters: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

tree: 'http://.../x86_64/tree'
\end_layout

\begin_layout Standard
Estos parámetros vienen de todo lo que Cobbler monitorea en “
\family typewriter
--ks-meta
\family default
” (también es un parámetro).
 De este modo se puede fácilmente añadir parámetros como añadir clases y
 mantener todo organizado en un lugar.
 En caso de tener parámetros o clases globales para añadir, esto se puede
 hacer editando los siguientes campos en
\family typewriter
 /etc/cobbler/settings
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
mgmt_classes: [ ] 
\end_layout

\begin_layout Standard

\family typewriter
mgmt_parameters: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

from_cobbler: 1
\end_layout

\begin_layout Subsubsection
Replicate
\end_layout

\begin_layout Standard
Este comando descarga la configuración de un servidor Cobbler a otro.
 Sirve para tener implementaciones de High Availability, recuperación de
 desastres o para balanceo de carga.
\end_layout

\begin_layout Standard

\family typewriter
cobbler replicate --master=master.example.org
\end_layout

\begin_layout Standard
Con los argumentos por defecto, solo la metadata de la distribución y del
 perfil es sincronizada.
 A continuación se muestra los argumentos que se le pueden pasar a Cobbler
 para que replique: 
\end_layout

\begin_layout Standard

\family typewriter
# cobbler replicate --help 
\end_layout

\begin_layout Standard

\family typewriter
Usage: cobbler [options]
\end_layout

\begin_layout Standard

\family typewriter
Options: -h, --help show this help message and exit 
\end_layout

\begin_layout Standard

\family typewriter
--master=MASTER Cobbler server to replicate from.
 
\end_layout

\begin_layout Standard

\family typewriter
--distros=PATTERN pattern of distros to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--profiles=PATTERN pattern of profiles to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--systems=PATTERN pattern of systems to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--repos=PATTERN pattern of repos to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--image=PATTERN pattern of images to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--omit-data do not rsync data 
\end_layout

\begin_layout Standard

\family typewriter
--prune remove objects (of all types) not found on the master
\end_layout

\begin_layout Paragraph
Setup
\end_layout

\begin_layout Standard
En cada servidor que será la réplica del master, instalar Cobbler normalmente
 y asegurarse que 
\family typewriter
/etc/cobbler/settings
\family default
 y 
\family typewriter
/etc/cobbler/modules.conf 
\family default
están configurados apropiadamente.
 Utilizar cobbler check para ver si existe algún error.
 El comando no modificará estos archivos.
 
\end_layout

\begin_layout Standard
Los archivos son transferidos por rsync (sobre ssh) o por scp, por lo que
 es necesario tener un agente ssh antes de utilizar el comando de réplica
 o si no, utilizar authorized_keys en el host remoto.
\end_layout

\begin_layout Section
Puppet
\end_layout

\begin_layout Standard
El agente y el servidor se comunican vía HTTPS con verificación de cliente.
 El nodo maestro (servidor) provee una interfaz HTTPS con varios extremos
 disponibles.
 Cuando se pide o enviá cualquier cosa al servidor, el agente hace un pedido
 HTTPS o a uno de esos extremos.
\end_layout

\begin_layout Standard
Client-vefied HTTPS quiere decir que cada maestro o agente tiene un identificado
r por certificado SSL y examinan los certificados de sus contrapartes para
 decidir si permite un intercambio de información.
 Puppet incluye un constructor de certificado de autorización para administrar
 los certificados.
 Los agentes puede pedir automáticamente los certificados vía la API HTTP
 del maestro.
 El administrador del nodo maestro puede usar el comando 
\family typewriter
puppet cert
\family default
 para inspeccionar los pedidos y firmar nuevos certificados; los agentes
 pueden entonces descargar los certificados firmados.
 
\end_layout

\begin_layout Subsection
Pre-instalación
\end_layout

\begin_layout Standard
Puppet usualmente corre bajo la arquitectura cliente-servidor, pero además,
 puede correr en una arquitectura autocontenida.
 La decisión determina que paquetes serán instalados y que configuraciones
 extra necesarias se harán.
 
\end_layout

\begin_layout Standard
Se toma la opción de utilizar la arquitectura cliente-servidor.
 Se debe completar la instalación y configuración de todos los puppet servers
 antes de instalar cualquier agente.
 El servidor necesariamente debe correr en un sistema basado en Unix.
\end_layout

\begin_layout Subsubsection
Requerimientos de sistema y chequeo de versión de sistema operativo
\end_layout

\begin_layout Itemize

\series bold
Hardware:
\series default
 El agente Puppet no tiene requerimientos particulares de hardware y corre
 prácticamente en cualquier computadora, sin embargo, el servidor es un
 recurso intensivo y debe ser instalado en un servidor robusto y dedicado.
 Como mínimo, el servidor debe tener dos procesadores y al menos 2GB de
 RAM, para administrar eficientemente mil nodos, debe poseer entre 2 y 4
 procesadores y 4GB de RAM.
 
\end_layout

\begin_layout Itemize

\series bold
Sistemas operativos soportados:
\series default
 Hay una gran variedad de distribuciones Linux que soportan puppet, entre
 ellas destaca la utilizada para la realización del Proyecto, CentOS 7.
 
\end_layout

\begin_layout Itemize

\series bold
Ruby:
\series default
 Se soportan varias versiones de Ruby, pero se recomienda el uso de las
 versiones 2.1.x.
\end_layout

\begin_layout Itemize

\series bold
Librerías obligatorias:
\series default
 Facter 2.4.3 o posterior, Hiera 2.0.0 o posterior, json gem cualquier versión
 moderna, rgen gem 0.6.6 o posterior.
\end_layout

\begin_layout Itemize

\series bold
Librerías opcionales:
\series default
 msgpack gem es requerido si se utiliza msgpack racionalización.
\end_layout

\begin_layout Subsubsection
Chequeo de la configuración de red
\end_layout

\begin_layout Standard
En un agent/master deployment se debe preparar la red para el tráfico de
 puppet.
 
\end_layout

\begin_layout Itemize

\series bold
Firewall:
\series default
 Si no se deshabilita, el servidor debe permitir conexiones entrantes al
 puerto 8140 y los agentes deben ser capaces de conectarse a ese puerto.
 
\end_layout

\begin_layout Itemize

\series bold
Resolución de nombres:
\series default
 Cada nodo debe tener un nombre único.
\end_layout

\begin_layout Subsection
Instalación 
\end_layout

\begin_layout Standard
Primero se debe instalar puppetserver.
 Para ello habilitar los paquetes de los repositorios de Puppet Labs:
\end_layout

\begin_layout Standard

\family typewriter
sudo rpm -ivh https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
 
\end_layout

\begin_layout Standard
Instalar el puppet master con el siguiente comando:
\end_layout

\begin_layout Standard

\family typewriter
yum install puppetserver
\end_layout

\begin_layout Standard
No iniciar el servicio aún.
\end_layout

\begin_layout Subsubsection
Asignación de memoria 
\end_layout

\begin_layout Standard
Por defecto, puppet server está configurado para usar 2GB de RAM pero si
 se quiere experimentar con puppet server en una VM se puede asignar tan
 poco como 512MB de memoria.
 Para cambiar la asignación de memoria se edita el archivo de configuración,
 que se encuentra en 
\family typewriter
/etc/sysconfig/puppetserver
\family default
 y modificar la siguiente línea:
\end_layout

\begin_layout Standard

\family typewriter
# Modify this if you'd like to change the memory allocation, enable JMX,
 etc 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

JAVA_ARGS="-Xms2g -Xmx2g"
\end_layout

\begin_layout Standard
Si se desea por ejemplo, utilizar 1536MB se debe reemplazar 2g por 1536m:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

JAVA_ARGS="-Xms
\family default
1536
\family typewriter
m -Xmx
\family default
1536
\family typewriter
m"
\end_layout

\begin_layout Standard
Luego, para aplicar los cambios, se debe reiniciar el servicio.
 No obstante, no se recomienda utilizar puppetmaster con menos de 2GB.
\end_layout

\begin_layout Subsubsection
Instalar el paquete puppet-agent
\end_layout

\begin_layout Standard
Según sea el sistema operativo sobre el que se instalará, se tiene:
\end_layout

\begin_layout Standard

\series bold
Centos y derivados:
\series default
 Del mismo modo que para el servidor, es necesario añadir el repositorio
 y luego instalar:
\end_layout

\begin_layout Standard

\family typewriter
sudo rpm -Uvh https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
 
\end_layout

\begin_layout Standard

\family typewriter
sudo yum install puppet-agent
\end_layout

\begin_layout Standard

\series bold
Ubuntu y derivados: 
\series default
Habilitar el repositorio según sea el caso como el siguiente ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
wget https://apt.puppetlabs.com/puppetlabs-release-pc1-wheezy.deb
\end_layout

\begin_layout Standard

\family typewriter
sudo dpkg -i puppetlabs-release-pc1-wheezy.deb
\end_layout

\begin_layout Standard

\family typewriter
sudo apt-get update
\end_layout

\begin_layout Standard

\family typewriter
sudo apt-get install puppet-agent
\end_layout

\begin_layout Standard

\series bold
Windows: 
\series default
Descargar el paquete instalador desde https://downloads.puppetlabs.com/windows/?_g
a=1.232745247.1868267244.1457442550
\end_layout

\begin_layout Itemize
Arquitectura x64: Se recomienda el uso de 
\family typewriter
puppet-agent-<VERSION>-x64.msi 
\family default
o 
\family typewriter
puppet-agent-<VERSION>-x86.msi
\family default
.
 
\end_layout

\begin_layout Itemize
Arquitectura x86: Debe utilizar 
\family typewriter
puppet-agent-<VERSION>-x86.msi
\family default
.
 
\end_layout

\begin_layout Standard
La instalación puede ser gráfica o automática.
 Para la última, desde el cuadro 
\begin_inset Quotes eld
\end_inset

Ejecutar
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard

\family typewriter
msiexec /qn /norestart /i puppet-agent-<VERSION>-x64.msi PUPPET_MASTER_SERVER=pup
pet
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
No iniciar el servicio aún.
 
\end_layout

\begin_layout Standard
Por defecto, el valor del hostname de servidor es puppet, si se nombró de
 otra forma a la máquina servidora del puppet server, se debe editar esto.
\end_layout

\begin_layout Subsubsection
Configuraciones para los agentes
\end_layout

\begin_layout Paragraph
Básicas:
\end_layout

\begin_layout Itemize
server: El nombre del nodo maestro al cual se le pedirán los manifiestos.
 Por defecto es puppet 
\end_layout

\begin_layout Itemize
certname: Nombre con el cual el nodo agente pide el certificado y se presenta
 al servidor.
 
\end_layout

\begin_layout Itemize
environment: Indica el entorno solicitado cuando se contacta al maestro.
 De cualquier forma, el maestro puede configurarse para ignorar esta configuraci
ón.
 
\end_layout

\begin_layout Paragraph
Comportamiento de la ejecución: 
\end_layout

\begin_layout Itemize
noop: Si está habilitado, el agente no reializará ningún trabajo, en cambio
 mirará qué cambios tendría que realizar y lo reporta al servidor.
 
\end_layout

\begin_layout Itemize
priority: Permite asignar el valor “nice” para evitar que otras aplicaciones
 de la CPU no mueran por inanición mientras se aplican los catálogos.
\end_layout

\begin_layout Itemize
report: Indica si se deben enviar reportes, por defecto es 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 .
\end_layout

\begin_layout Itemize
tags: Limita a los agentes a correr recursos con ciertas etiquetas.
 
\end_layout

\begin_layout Itemize
usecacheonfailure: Se utiliza para tomar el último buen catálogo si el master
 no posee uno bueno.
 
\end_layout

\begin_layout Itemize
prerun_command y postrun_command: Comandos que se desean correr de cada
 lado de puppet
\end_layout

\begin_layout Paragraph
Comportamiento del servicio: 
\end_layout

\begin_layout Itemize
runinterval: Indica cada cuanto tiempo el agente se contacta con el servidor
 para pedirle los manifiestos.
 Por defecto es 30 minutos.
 
\end_layout

\begin_layout Itemize
waitforcert: Indica al agente que persista si no puede obtener su certificado.
 Por defecto está habilitado.
 
\end_layout

\begin_layout Paragraph
Útilies cuando se ejecutan los agentes desde Cron: 
\end_layout

\begin_layout Itemize
splay y splaylimit: Se utiliza para sincronizar el agente y el servidor
 si el primero utiliza un cron en lugar del demonio.
 
\end_layout

\begin_layout Itemize
daemonize: Se debe colocar esta opción en falso si se utiliza un cron.
\end_layout

\begin_layout Itemize
onetime: Sale luego de terminar el puppet actual.
 Debe ser 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 si se utiliza un cron.
\end_layout

\begin_layout Subsubsection
Configuraciones para los servidores:
\end_layout

\begin_layout Paragraph
Básicas:
\end_layout

\begin_layout Itemize
dns_alt_names: Una lista de los hostnames de los servidores permitidos para
 usar cuando actúan como 
\begin_inset Quotes eld
\end_inset

masters environment
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
path: Indica la ubicación del entorno.
 
\end_layout

\begin_layout Itemize
basemodulepath: Una lista de las ubicaciones que contienen módulos que pueden
 ser usados en todos los entornos.
\end_layout

\begin_layout Itemize
manifest: El principal punto de entrada para compilar los catálogos.
 Por defecto es 
\begin_inset Quotes eld
\end_inset

site.pp
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
reports: Controlador de reportes que se usa.
\end_layout

\begin_layout Paragraph
Configuraciones de CA:
\end_layout

\begin_layout Itemize
ca: Si actúa como un autoridad de certificación.
\end_layout

\begin_layout Itemize
ca_ttl: Indica por cuánto tiempo son válidos los certificados.
\end_layout

\begin_layout Itemize
autosign: Indica si los certifcados deben ser firmados de forma automática
 o manual.
\end_layout

\begin_layout Standard
Como ejemplo de configuración se tiene, en el nodo que corre puppetserver,
 a la configuración por defecto, añadir:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
certname = puppet
\end_layout

\begin_layout Standard

\family typewriter
server = puppet
\end_layout

\begin_layout Standard

\family typewriter
runinterval = 2m
\end_layout

\begin_layout Subsubsection
Ejecutar puppet
\end_layout

\begin_layout Standard
Para el puppet server, si es el único maestro en el deployment, o si actuará
 como el servidor de CA para un sitio con múltiples maestros, se debe ejecutar
 puppet como sigue:
\end_layout

\begin_layout Standard

\family typewriter
sudo puppet master --verbose --no-daemonize
\end_layout

\begin_layout Standard
Esto creará el certificado de CA y el certificado del puppet master, con
 los nombres DNS apropiados incluidos.
 Una vez que se muestre en pantalla 
\family typewriter
Notice: Starting Puppet master version <VERSION>
\family default
, tipear Ctrl-C para matar el proceso.
\end_layout

\begin_layout Standard
Para corroborar la creación y firmado del servicio:
\end_layout

\begin_layout Standard

\family typewriter
sudo puppet cert list --all
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En caso que el maestro no haga las veces de CA, para solicitar un certificado,
 ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
sudo puppet agent --test --ca_server=<SERVER> 
\end_layout

\begin_layout Standard
Luego en el nodo maestro que sí oficia de CA:
\end_layout

\begin_layout Standard

\family typewriter
sudo puppet cert list 
\end_layout

\begin_layout Standard

\family typewriter
sudo puppet cert --allow-dns-alt-names sign <NAME> 
\end_layout

\begin_layout Standard
Este último es para firmar el certificado.
 Luego en el nuevo maestro, ejecutar nuevamente 
\family typewriter
sudo puppet agent --test --ca_server=<SERVER> 
\family default
para recibir el certificado.
\end_layout

\begin_layout Subsection
Tópicos generales de Puppet
\end_layout

\begin_layout Subsubsection
Module
\end_layout

\begin_layout Standard
Un módulo o module, es un conjunto de código de Puppet enpaquetado junto
 con los otros archivos y datos, que se necesita administrar sobre algún
 aspecto del sistema.
 Consiste en una estructura predefinida de directorios que ayudan a Puppet
 a encontrar los contenidos del módulo.
 Para ver los módulos instalados se puede ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
puppet module list
\end_layout

\begin_layout Standard
Existe un repositorio público (The Puppet Forge) donde se pueden encontrar
 módulos hechos por la comunidad y también mantenidos por Puppet Labs.
\end_layout

\begin_layout Standard
Los módulos son auto-contenidos y separados.
 Su estructura de archivo le da a Puppet una forma consistente de localizar
 cualquier clase, plantillas, plugins y binarios requeridos para satisfacer
 la funcionalidad del módulo.
\end_layout

\begin_layout Standard
Todos los módulos accesibles por el puppet master están localizados en los
 directorios especificados por la variable 
\family typewriter
'modulepath'
\family default
 en el archivo de configuración de Puppet.
 Para encontrar esta variable en cualquier sistema con Puppet, se puede
 ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
puppet agent --configprint modulepath 
\end_layout

\begin_layout Subsubsection
Node group 
\end_layout

\begin_layout Standard
Los grupos de nodos o node groups permiten segmentar todos los nodos de
 la infraestructura en grupos separados configurables basados en la información
 colectada por 'facter tool'.
\end_layout

\begin_layout Subsubsection
Resources
\end_layout

\begin_layout Standard
Cada recurso o resource, describe algún aspecto de un sistema y su estado,
 como por ejemplo, un servicio que debería estar ejecutándose o un paquete
 que se quiere instalado.
 El bloque de código que describe un recurso se llama declaración de recurso
 (resource declaration).
 Estas declaraciones de recurso están escritas en código Puppet, un DLS
 (Domain Specific Language) construido en Ruby.
 El DLS de Puppet es un leguaje declarativo en vez de imperativo.
 Esto quiere decir que en vez de definir un proceso o un conjunto de comandos,
 el código de Puppet describe (o declara) solo el estado final deseado,
 y depende de proveedores integrados para lidiar con la implementación.
\end_layout

\begin_layout Standard

\family typewriter
puppet resource tool -> puppet resource <type> <name> 
\end_layout

\begin_layout Standard
Puppet incluye una variedad de tipos de recursos integrados, que permiten
 administrar varios aspectos de un sistema.
 Algunos de los tipos de recursos claves que generalmente se encuentran
 en un sistema son los siguientes:
\end_layout

\begin_layout Standard

\family typewriter
user 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un usuario 
\end_layout

\begin_layout Standard

\family typewriter
group 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un grupo de usuario 
\end_layout

\begin_layout Standard

\family typewriter
file 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un archivo específico 
\end_layout

\begin_layout Standard

\family typewriter
package 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un paquete de software 
\end_layout

\begin_layout Standard

\family typewriter
service 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un servicio corriendo
\end_layout

\begin_layout Standard

\family typewriter
cron 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un trabajo pogramado de cron 
\end_layout

\begin_layout Standard

\family typewriter
exec 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un comando externo 
\end_layout

\begin_layout Standard

\family typewriter
host 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un host
\end_layout

\begin_layout Standard
Una declaración de recurso seguirá un patrón como el de abajo:
\end_layout

\begin_layout Standard

\family typewriter
tipo {'título': 
\end_layout

\begin_layout Standard

\family typewriter
atributo => 'valor', 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Itemize

\series bold
Título: 
\series default
Es un string que identifica un recurso para el compilador de Puppet.
\end_layout

\begin_deeper
\begin_layout Standard
El título no tiene que coincidir con lo que va a administrar en el sistema,
 pero a menudo se desea eso.
 
\end_layout

\begin_layout Standard
Los títulos deben ser únicos por tipos de recursos, se puede tener un paquete
 y un servicios ambos con el mismo título, pero no dos servicios con ese
 título.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Atributos: 
\series default
Los atributos describen el estado deseado para un recurso; cada atributo
 maneja algún aspecto del recurso.
 
\end_layout

\begin_deeper
\begin_layout Standard
Cada tipo de recurso tiene su propio juego de atributos.
 Muchos tipos de recursos tienen atributos claves y una gran cantidad de
 opcionales.
\end_layout

\begin_layout Standard
Todos los atributos declarados deben tener un valor; el tipo de dato del
 valor depende de los que acepte el atributo.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Comportamiento: 
\series default
Una declaración de recurso agrega un recurso al catálogo y le dice a Puppet
 que administre el estado del recurso.
 Cuando Puppet aplica el catálogo compilado, lo que hará es:
\end_layout

\begin_deeper
\begin_layout Itemize
Leer el estado actual del recurso en el sistema objetivo.
\end_layout

\begin_layout Itemize
Comprar el estado actual con el deseado
\end_layout

\begin_layout Itemize
Si es necesario, realizar cambios para llevar el estado actual al deseado.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Recursos no administrados: 
\series default
Si el catálogo no contiene un recurso, implica que Puppet ya no lo administra,
 pero no que lo 
\begin_inset Quotes eld
\end_inset

elimina
\begin_inset Quotes erd
\end_inset

, si se desea eliminarlo, se debe aclararlo en su estado deseado.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
ensure => absent
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Singularidad: 
\series default
Puppet no permite que se declare un mismo recurso dos veces.
 Esto prevee conflictos de valores.
 Si múltiples clases requieren el mismo recurso se puede usar una clase
 o un recurso virtual para añadirlo al catálogo en múltiples lugares sin
 duplicar.
\end_layout

\begin_layout Itemize

\series bold
Relaciones y orden: 
\series default
Por defecto, Puppet aplica los recursos sin seguir el orden en que fueron
 escritos.
 Esto, se puede desactivar con la opción de ordenado.
 Sin embargo, si un recurso debe ser aplicado antes o después de otro, se
 puede indicar una relación entre ellos.
 Incluso se puede indicar que cambios en un recurso causen que otro se refresque.
\end_layout

\begin_layout Itemize

\series bold
Cambios, eventos y reportes: 
\series default
Si Puppet realiza cambios, en un recurso, registra esos cambios como eventos.
 Esos eventos aparecerán en el 
\emph on
log
\emph default
 y en el reporte de ejecución de puppet.
\end_layout

\begin_layout Itemize

\series bold
Independencia de alcance: 
\series default
Los recursos no están sujetos a los alcances.
 Un recurso, en cualquier ámbito, se puede referenciar desde cualquier otro
 ámbito.
\end_layout

\begin_layout Itemize

\series bold
Atributos especiales de los recursos.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Name/Namevar: 
\series default
Define un recurso en el sistema objetivo.

\emph on
 
\emph default
Por ejemplo, el 
\emph on
name
\emph default
 de un servicio o paquete es el nombre por el cual las herramientas de paquetes
 o servicios lo reconocen o en el caso de un archivo, su namevar es el path.
 Esto es diferente al título, el cual identifica un recurso para el compilador
 de Puppet.
 Sin embargo, ellos a veces tienen el mismo valor.

\series bold
 
\series default
La separación de nombre y título permite administrar un recurso que mantiene
 su título, pero que tiene diferente nombre en diferentes plataformas.
 Por ejemplo, un servicio 
\emph on
ntp 
\emph default
en sistemas Red Hat tiene por nombre 
\emph on
ntpd 
\emph default
y en sistemas debian
\emph on
 ntp .
\end_layout

\begin_layout Itemize

\series bold
Ensure: 
\series default
Esto generalmente maneja el aspecto más importante de un recurso en el sistema
 objetivo.
 Indica si el archivo existe, si el servicio está corriendo o parado, si
 el paquete está instalado, etc.
\end_layout

\end_deeper
\begin_layout Paragraph*
Tipos de recursos
\end_layout

\begin_layout Standard
Todos los tipos tienen un atributo especial llamado namevar.
 Este es el atributo usado para identificar univocamente un recurso en el
 sistema de destino.
 Si no se especifica un valor para el namevar, este valor es tomado por
 defecto según el título del recurso.
\end_layout

\begin_layout Standard
Ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
file { '/etc/passwd': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

owner => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

group => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

mode => 644 
\end_layout

\begin_layout Standard

\family typewriter
} 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En este código, 
\family typewriter
/etc/passwd
\family default
 es el título del recurso 
\emph on
file
\emph default
, otros códigos de Puppet pueden hacer referencia al recurso como File['/etc/pas
swd'] para declarar relación.
 Porque el path es el 
\emph on
namevar
\emph default
 para el tipo file y si no se le provee un valor, toma uno por defecto que
 es 
\emph on
/etc/passwd.
\end_layout

\begin_layout Standard

\series bold
Atributos
\series default
: A veces llamados parámetros, determinan el estado deseado para un recurso.
 Cualquiera de ellos modifica directamente el sistema (internamente, las
 llamadas “propiedades”) o afectan cómo el recurso se comporta.
 
\end_layout

\begin_layout Standard

\series bold
Proveedores (providers
\series default
): Implementan el mismo tipo de recursos en diferentes tipos de sistemas,
 ellos suelen hacer esto llamando a comandos externos.
 Aunque Puppet seleccionará automáticamente un proveedor apropiado por defecto,
 se lo puede sobrescribir con el atributo 
\emph on
provider
\emph default
.
 Por ejemplo, el recurso 
\emph on
package
\emph default
 de sistemas Red Hat tiene por defecto YUM como 
\emph on
provider
\emph default
, pero se puede especificar 
\family typewriter
provider => gem 
\family default
para instalar librerías de Ruby con gem.
 
\end_layout

\begin_layout Standard

\series bold
Características (features):
\series default
 Son habilidades que algunos proveedores pueden no soportar.
 Generalmente una característica corresponderá con algunos valores permitidos
 por un recurso de un atributo, por ejemplo, si un paquete soporta la caracterís
tica 
\emph on
purgeable
\emph default
, se puede especificar 
\family typewriter
ensure => purged 
\family default
para borrar los archivos de configuración instalados por el paquete.
\end_layout

\begin_layout Standard
Algunas de las referencias de tipo más importantes son las explicadas a
 continuación:
\end_layout

\begin_layout Itemize

\series bold
Computer:
\series default
 Manejo de objetos de la computadora usando DirectyoryService en un Mac
 OS X.
 Sirve para adjuntar políticas MCX a los objetos localhost creados.
\end_layout

\begin_layout Itemize

\series bold
Cron:
\series default
 Instalar y manejar trabajos Cron.
 Todo Cron creado por Puppet requiere un comando y al menos un atributo
 de un periodo (horas, minutos,meses, etc).
 Mientras el nombre del Cron no es parte del trabajo actual, el nombre es
 almacenado en un comentario comenzando con 
\family typewriter
\emph on
#Puppet Name:
\family default
\emph default
.
 Ese comentario es usado para conicidir entadas crontab creadas por Puppet
 con un recurso Cron.
 
\end_layout

\begin_layout Itemize

\series bold
Exec:
\series default
 Ejecuta comandos externos.
 Cualquier comando en un recurso Exec debe poder correr múltiples veces
 sin causar daños.
 
\end_layout

\begin_layout Itemize

\series bold
File:
\series default
 El manejo de archivos incluye contenido, dueño, y permisos.
 El tipo archivo puede manejar archivos, directorios y enlaces simbólicos.
 
\end_layout

\begin_layout Itemize

\series bold
Filebucket:
\series default
 Un repositorio para almacenar y recuperar archivos conformados por MD5
 checksum.
 Puede ser local a cada nodo agente o centralizado en un servidor Puppet.
 Todos los Puppet Master proveen un servicio filebucket que los agentes
 pueden acceder vía HTTP.
 
\end_layout

\begin_layout Itemize

\series bold
Group:
\series default
 Manejo de grupos.
 En muchas plataformas esto sólo puede crear grupos.
 La membresía de los grupos debe ser administrada por cada usuario individual
 .
 
\end_layout

\begin_layout Itemize

\series bold
Host:
\series default
 Instalar y manejar entradas de hosts.
 Para muchos sistemas, esas entradas deben estar solo en /etc/hosts, pero
 algunos SO tienen diferentes soluciones.
 
\end_layout

\begin_layout Itemize

\series bold
Interface:
\series default
 Esto representa una interfaz de router o switch.
 Es posible gestionar el modo interfaz y las características switchport.
 
\end_layout

\begin_layout Itemize

\series bold
K5login:
\series default
 Controla el archivo .k5login para un usuario.
 
\end_layout

\begin_layout Itemize

\series bold
Mailalias:
\series default
 Crea un alias email en la base de datos de alias local.
 
\end_layout

\begin_layout Itemize

\series bold
Maillist:
\series default
 Controla la lista de emails.
 Este tipo de recurso puede solo crear y remover listas, no puede reconfigurar
 listas actuales.
 
\end_layout

\begin_layout Itemize

\series bold
Mcx:
\series default
 Manejo de objetos MCX usando DirectoryService en MAC OS X.
 
\end_layout

\begin_layout Itemize

\series bold
Mount:
\series default
 Maneja de filesystems montados, incluyendo agregar la informacion de montaje
 a la tabla de montaje.
 El comportamiento actual depende de el valor de el parámetro 
\emph on
ensure.
\end_layout

\begin_layout Itemize

\series bold
Notify:
\series default
 Envió de un mensaje arbitrario a el log del agente en tiempo de ejecución.
 
\end_layout

\begin_layout Itemize

\series bold
Package:
\series default
 Manejo de paquetes.
 Hay una bifurcación básica en los paquetes soportados correctamente: Algunos
 tipos de paquetes como yum y apt pueden recuperar sus propios archivos
 de paquetes, mientras que otros no pueden.
 Para esos paquetes, se puede usar el parametro 
\emph on
source
\emph default
 para poner el archivo adecuado.
 
\end_layout

\begin_layout Itemize

\series bold
Resources:
\series default
 Este es un metatipo que puede controlar otro tipo de recursos.
 Cualquier metaparámetro especificado aquí sera pasado a los recursos generados,
 por lo que puede purgar recursos no administrados.
 
\end_layout

\begin_layout Itemize

\series bold
Schedule:
\series default
 Define el programa para Puppet.
 Los recursos pueden ser limitados por un programa usando el metaparámetro
 schedule.
 
\end_layout

\begin_layout Itemize

\series bold
SelBoolean: 
\series default
Manejo de SELinux Boolean en sistemas que soportan SELinux.
 
\end_layout

\begin_layout Itemize

\series bold
SelModule: 
\series default
Manejo de carga y descarga de modulos de política de SELinux en el sistema.
 
\end_layout

\begin_layout Itemize

\series bold
Service: 
\series default
Controla servicios en ejecución.
 El soporte de este recurso varía ampliamente según el concepto de servicio
 de la plataforma.
 
\end_layout

\begin_layout Itemize

\series bold
Ssh_authorized_key: 
\series default
Manejo de llaves autorizadas SSH.
 Actualmente solo dos tipos de llaves son soportadas.
 
\end_layout

\begin_layout Itemize

\series bold
Sshkey: 
\series default
Instala y administra las llaves de host SSH.
 
\end_layout

\begin_layout Itemize

\series bold
Stage: 
\series default
Un tipo de recurso para crear nuevos escenarios.
 
\end_layout

\begin_layout Itemize

\series bold
Tidy: 
\series default
Remueve archivos base no deseados con criterios específicos.
 
\end_layout

\begin_layout Itemize

\series bold
User: 
\series default
Administración de usuarios.
 
\end_layout

\begin_layout Itemize

\series bold
Vlan: 
\series default
Administra VLANs en un router o switch 
\end_layout

\begin_layout Itemize

\series bold
Yumrepo: 
\series default
La descripción del lado del cliente de un repositorio YUM.
 La configuración de un repositorio se encuentra en 
\emph on
/etc/yum.conf 
\emph default
y el archivo indicado por la opción 
\emph on
reposdir
\emph default
 en ese archivo.
 
\end_layout

\begin_layout Itemize

\series bold
Zfs: 
\series default
Administración de ZFS.
 Crea, destruye y configura las propiedades en instancias ZFS.
 
\end_layout

\begin_layout Itemize

\series bold
Zpool: 
\series default
Administración de zpools.
 Crea y elimina zpools.
 El proveedor no sincroniza, solo reporta diferencias.
 Soporta vdevs con espejos, raidz, logs y spares
\end_layout

\begin_layout Subsubsection
Manifiests 
\end_layout

\begin_layout Standard
Un manifiesto o manifest, es un archivo de texto que contiene código Puppet
 y posee la extensión .pp.
 Para comprobar la sintaxis de un manifiesto se puede utilizar:
\end_layout

\begin_layout Standard

\family typewriter
puppet parser validate <manifiesto.pp> 
\end_layout

\begin_layout Standard
El parseador no retornará nada si no hay errores, en caso de que se detecte
 un error debe ser corregido antes de continuar.
 Si se trata de aplicar un manifiesto que no ha sido declarado, no cambiará
 nada en el sistema.
 Para ésto se debe crear un 
\family typewriter
.pp
\family default
 que contenga un sentencia:
\end_layout

\begin_layout Standard

\family typewriter
include módulo::clase
\end_layout

\begin_layout Standard
Antes de aplicar cambios en el sistema, se puede utilizar la bandera 
\family typewriter
–noop
\family default
 para compilar el catálogo (catálogo) y notificar los cambios que Puppet
 habría realizado si hubiera sido ejecutado sin 
\family typewriter
–noop
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
puppet apply --noop 
\end_layout

\begin_layout Subsubsection
Catálogos
\end_layout

\begin_layout Standard
Los manifiestos de Puppet pueden usar lógica condicional para describir
 muchas configuraciones de nodos como una.
 Antes de configurar un nodo, Puppet compila los manifiestos en un catálogo,
 el cual solo es válido para un único nodo y no contiene lógica ambigua.
\end_layout

\begin_layout Standard
Los catálogos son documentos estáticos los cuales contienen recursos y relacione
s.
 
\end_layout

\begin_layout Standard
En la arquitectura estándar maestro/agente, los nodos solicitan los catálogos
 al Puppet Server, el cual los compila cuando son solicitados.
 Los agentes mantienen en caché sus más recientes catálogos, si al pedir
 el catálogo, el master falla al compilarlo, ellos reusaran su catálogo
 cacheado.
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
Una clase es un bloque de código Puppet con nombre.
 Una clase administrará generalmente un conjunto de recursos relacionados
 a una función simple o un componente del sistema.
 Las clases usualmente contienen otras clases; este anidamiento provee una
 forma estructurada de juntar funciones de clases diferentes como componentes
 de soluciones más grandes.
 Para utilizar una clase, se necesita definirla escribiendo una definición
 de clase y guardándola en un archivo manifiesto.
 Cuando Puppet se ejecuta, parseará este manifiesto y guardará la definición
 de clase; luego ésta puede ser declarada para aplicarla en los nodos de
 la infraestructura.
 En Puppet las clases son singleton, lo que quiere decir que una clase puede
 ser declarada sólo una vez en un nodo dado.
 Cuando se declara una clase:
\end_layout

\begin_layout Standard

\family typewriter
include módulo::clase
\end_layout

\begin_layout Standard

\family typewriter
módulo
\family default
 le indica a Puppet donde encontrar esa 
\family typewriter
clase
\family default
.
 Sin embargo, para la clase principal de un módulo, además de llevar el
 mismo nombre que el módulo mismo, Puppet reconoce el nombre especial del
 archivo '
\family typewriter
init.pp
\family default
' como el manifiesto que contendrá la clase principal de un módulo.
 
\end_layout

\begin_layout Subsubsection
Funciones
\end_layout

\begin_layout Standard
Hay dos tipos de funciones en Puppet, statements (declaraciones) y rvalues.
 Las statements no retornan argumentos, son utilizadas para hacer trabajos
 independientes como importar.
 Rvalues retornan valores y pueden ser usadas solo en un statement requiriendo
 un valor, como una asignación o una declaración case.
\end_layout

\begin_layout Standard
Las funciones se ejecutan en el Puppet master, no se ejecutan en el agente.
 Por lo tanto sólo tienen acceso a los comandos y datos disponibles en el
 nodo maestro.
\end_layout

\begin_layout Standard
Algunas de las funciones disponibles son:
\end_layout

\begin_layout Itemize

\series bold
alert:
\series default
 (statement) Deja un mensaje en el log del servidor en el nivel de alerta.
\end_layout

\begin_layout Itemize

\series bold
assert_type:
\series default
 (rvalue) Retorna el valor dado si este es una instancia del tipo dado,
 y levanta un error en caso contrario.
 
\end_layout

\begin_layout Itemize

\series bold
contatin:
\series default
 (statement) Contiene una o más clases dentro de la clase actual.
 Si alguna de estas clases están sin declarar, serán declaradas como si
 fueran llamadas con la función 
\emph on
include
\emph default
.
 
\end_layout

\begin_layout Itemize

\series bold
create_resources:
\series default
 (statement) Convierte un hash en un conjunto de recursos y los añade al
 catálogo.
\end_layout

\begin_layout Itemize

\series bold
crit: 
\series default
(statement) Deja un mensaje en el log del servidor en el nivel crítico.
\end_layout

\begin_layout Itemize

\series bold
debug: 
\series default
(statement) Deja un mensaje en el log del servidor en el nivel debug.
\end_layout

\begin_layout Itemize

\series bold
defined: 
\series default
(rvalue) Determina si una clase dada o un tipo de recurso está definido.
 También puede determinar si un recurso específico está definido o si una
 variable ha sido asignada con un valor.
\end_layout

\begin_layout Itemize

\series bold
digest:
\series default
 (rvalue) Retorna el valor de hash de un string dado usando la configuración
 digest_algorithm del archivo de configuración de Puppet.
\end_layout

\begin_layout Itemize

\series bold
each:
\series default
 (rvalue) Aplica un bloque parametrizado a cada elemento en una secuencia
 de entradas seleccionadas del primer argumento y retorna el primero argumento.
\end_layout

\begin_layout Itemize

\series bold
emerg:
\series default
 (statement) Deja un mensaje en el log del servidor en el nivel emergencia.
\end_layout

\begin_layout Itemize

\series bold
epp:
\series default
 (rvalue) Evalúa una plantilla Embedded Puppet y retorna el texto renderizado
 resultante como un string.
\end_layout

\begin_layout Itemize

\series bold
err:
\series default
 (statement) Deja un mensaje en el log del servidor en el nivel error.
\end_layout

\begin_layout Itemize

\series bold
fail:
\series default
 (statement) Fallo con un error del parser.
\end_layout

\begin_layout Itemize

\series bold
file: 
\series default
(rvalue) Carga un archivo desde un módulo y retorna sus contenidos como
 un string.
\end_layout

\begin_layout Itemize

\series bold
filter:
\series default
 (statement) Aplica un bloque parametrizado a cada elemento en una secuencia
 de entradas del primer argumento y retorna un array o un hash con las entradas
 para cada bloque evalúa a 
\emph on
true
\emph default
.
\end_layout

\begin_layout Itemize

\series bold
fqdn_rand:
\series default
 (rvalue) genera un número entero aleatorio mayor o igual a cero y menor
 a MAX, combinando 
\emph on
$fqdn
\emph default
 y el valor de SEED para aleatoriedad repetible.
 Ésto quiere decir que cada nodo obtendrá un número aleatorio diferente
 de esta función, pero, el resultado de un nodo dado, será el mismo cada
 vez a menos que su hostname cambie (uso: fqdn_rand(MAX, [SEED])).
\end_layout

\begin_layout Itemize

\series bold
generate: 
\series default
(rvalue) Llama a un comando externo en el Puppet master y retorna los resultados
 del comando.
 
\end_layout

\begin_layout Itemize

\series bold
hiera:
\series default
 (rvalue) Realiza una búsqueda de prioridad estándar y retorna el valor
 más específico para una clave dada.
\end_layout

\begin_layout Itemize

\series bold
hiera_array:
\series default
 (rvalue) Retorna todas las coincidencias a través de la jerarquía como
 un array plano de valores únicos.
\end_layout

\begin_layout Itemize

\series bold
hiera_hash: 
\series default
(rvalue) Retorna un hash mezclado de coincidencias a través de la jerarquía.
 
\end_layout

\begin_layout Itemize

\series bold
hiera_include: 
\series default
(rvalue) Asigna clases a un nodo usando un array de búsqueda (array merge
 lookup ) que retorna el valor para una clave de usuario-específico de la
 fuente de datos de Hiera.
\end_layout

\begin_layout Itemize

\series bold
include:
\series default
 (statement) declara una o más clases, causando que los recursos en ellas
 sead evaluados y añadidos al catálogo.
\end_layout

\begin_layout Itemize

\series bold
info: 
\series default
(statement) Deja un mensaje en el log del servidor en el nivel info.
\end_layout

\begin_layout Itemize

\series bold
inline_epp: 
\series default
(rvalue) Evalúa una plantilla Embedded Puppet y retorna el texto renderizado
 resultante como un string.
\end_layout

\begin_layout Itemize

\series bold
inline_template:
\series default
 (rvalue) Evalúa un string plantilla y retorna su valor.
\end_layout

\begin_layout Itemize

\series bold
lookup:
\series default
 (rvalue) Busca datos definidos usando Data Binding y Data Providers utilizando
 diferentes estrategias.
\end_layout

\begin_layout Itemize

\series bold
match: 
\series default
(statement) Retorna el resultado de coincidir un string o un array[string]
 con regexp, string (transformado a regexp, tipo pattern o tipo regexp).
\end_layout

\begin_layout Itemize

\series bold
md5: 
\series default
(rvalue) Retorna un valor de hash MD5 de un string dado.
\end_layout

\begin_layout Itemize

\series bold
notice: 
\series default
(statement) Deja un mensaje en el log del servidor en el nivel noticia.
\end_layout

\begin_layout Itemize

\series bold
reduce: 
\series default
(rvalue) Aplica un bloque parametrizado a cada elemento en una secuencia
 de entradas del primer argumento (
\emph on
el enumerable
\emph default
) y retorna el último resultado de la invocación del bloque parametrizado.
\end_layout

\begin_layout Itemize

\series bold
regsubst: 
\series default
(rvalue) Realiza un reemplazo regexp en un string o array de strings.
\end_layout

\begin_layout Itemize

\series bold
requiere: 
\series default
(statement) Evalúa una o más clases, añadiendo la clase requerida como dependenc
ia.
\end_layout

\begin_layout Itemize

\series bold
scanf: 
\series default
(rvalue) Escanea un string y retorna un array de uno o más valores convertidos
 dirigidos por un formato dado string.args.
\end_layout

\begin_layout Itemize

\series bold
sha1: 
\series default
(rvalue) Retorna un valor hash SHA1 de un string dado.
\end_layout

\begin_layout Itemize

\series bold
shellquote: 
\series default
(rvalue) Cita y concatena argumentos para usar en Bourne Shell.
\end_layout

\begin_layout Itemize

\series bold
split:
\series default
 (rvalue) Divide una variable string en un array usando el divisor regexp
 especificado.
\end_layout

\begin_layout Itemize

\series bold
sprintf: 
\series default
(rvalue) Realiza un formateo de texto con estilo printf.
\end_layout

\begin_layout Itemize

\series bold
tag: 
\series default
(statement) Añade las etiquetas especificadas a la clase o definición que
 la contiene.
 Luego todos los objetos también adquirirán esa etiqueta.
\end_layout

\begin_layout Itemize

\series bold
tagged:
\series default
 (rvalue) Una función booleana que dice si el contenedor actual está etiquetado
 con las etiquetas especificadas.
 Las etiquetas son operadas con AND, así que todas deben ser incluidas para
 que la función retorne true.
\end_layout

\begin_layout Itemize

\series bold
versioncmp:
\series default
 (rvalue) Compara dos números de versión.
\end_layout

\begin_layout Itemize

\series bold
warning: 
\series default
(statement) Deja un mensaje en el log del servidor en el nivel advertencia.
\end_layout

\begin_layout Itemize

\series bold
with: 
\series default
(rvalue) Llama a un bloque de código lambda con los argumentos dados.
 Como los parámetros de lambda son locales para el alcance de ella, esto
 puede ser utilizado para crear secciones privadas de lógica en una clase
 para que las variables no sean visibles fuera de la clase.
\end_layout

\begin_layout Subsubsection
Metaparámetros
\end_layout

\begin_layout Standard
Los metaparámetros son atributos que trabajan con cualquier tipo de recurso,
 incluido los tipos personalizados y los tipos definidos.
\end_layout

\begin_layout Standard
En general, ellos afectan el comportamiento de Puppet en preferencia a el
 deseo del estado del recurso.
 
\end_layout

\begin_layout Standard
Los metaparámetros hacen cosas como agregar metadata a un recurso (alias,
 tag), poner límites cuando el recurso debe ser sincronizado (require, schedule,
 etc.), evita que Puppet realice cambios (noop), y cambia la verborrea del
 log (loglevel).
\end_layout

\begin_layout Paragraph
Metaparámetros disponibles:
\end_layout

\begin_layout Itemize

\series bold
Alias: 
\series default
Crea un alias para el recurso.
 Puppet usa esto internamente cuando se provee un título simbólico y un
 valor de 
\emph on
namevar 
\emph default
explícito.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
file { 'sshdconfig': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

path => $operatingsystem ? { 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

solaris => '/usr/local/etc/ssh/sshd_config', 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

default => '/etc/ssh/sshd_config', 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

}, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

source => '...' 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
service { 'sshd': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

subscribe => File['sshdconfig'], 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Cuando se usa esta característica, el parseador pone 
\family typewriter
\emph on
sshdconfig
\family default
\emph default
 como el título, y la librería pone que es un alias para el archivo, entonces
 funciona la dependencia de búsqueda en 
\family typewriter
\emph on
Service['sshd']
\emph default
.
 
\family default
Se puede usar este metaparámetro, pero note que el alias generalmente solo
 trabaja para crear relaciones; cualquier cosa que se refiera a un recurso
 existente debe usar el título exacto del recurso.
 Por ejemplo, el siguiente código no funciona:
\end_layout

\begin_layout Standard

\family typewriter
file { '/etc/ssh/sshd_config': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

owner => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

group => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

alias => 'sshdconfig', 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
File['sshdconfig'] { 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

mode => '0644', 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
Puppet no tiene forma de saber que ésto debe afectar el mismo archivo.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
before: 
\series default
Cuando este atributo está presente, este recurso se aplicará 
\emph on
luego 
\emph default
del recurso o los recursos de los cuales depende.
\end_layout

\begin_layout Itemize

\series bold
loglevel: 
\series default
Coloca el nivel de información que será registrada.
 Los niveles de log tienen el mayor impacto cuando los eventos a registrar
 son enviados al syslog (así es por defecto).
\end_layout

\begin_deeper
\begin_layout Standard
El orden de los niveles, en prioridad decreciente, es:
\end_layout

\begin_layout Itemize
crit
\end_layout

\begin_layout Itemize
emerg 
\end_layout

\begin_layout Itemize
alert 
\end_layout

\begin_layout Itemize
err 
\end_layout

\begin_layout Itemize
warning 
\end_layout

\begin_layout Itemize
notice 
\end_layout

\begin_layout Itemize
info / verbose 
\end_layout

\begin_layout Itemize
debug
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
noop: 
\series default
Es para aplicar este recurso en modo noop.
\end_layout

\begin_deeper
\begin_layout Standard
Cuando aplica un recurso en modo noop, Puppet verificará si está sincronizado,
 como cuando corre normalmente.
 Sin embargo, si un atributo de un recurso no está en el estado deseado
 (como lo declara el catálogo), Puppet no realizará ninguna acción, y en
 su lugar, reportará los cambios que habría hecho.
 Esos cambios simulados aparecen en el reporte enviado al Puppet Master,
 o serán mostrados en consola si 
\family typewriter
puppet agent
\family default
 o 
\family typewriter
puppet applay 
\family default
corren en primer plano.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
notify: 
\series default
Cuando este atributo está presente, este recurso será aplicado antes que
 el recurso notificado.
\end_layout

\begin_deeper
\begin_layout Itemize
Si Puppet hace cambios en este recurso, causará que todos los recursos notificad
os se refresquen.
 Este comportamiento varía según el tipo de recurso, po ejemplo, los servicios
 se reiniciarán, objetos montados se desmontarán y montarán nuevamente,
 etc.
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
require: 
\series default
Cuando este atributo está presente, el recurso o los recursos requeridos
 serán aplicados 
\emph on
antes 
\emph default
que este recurso.
\end_layout

\begin_layout Itemize

\series bold
schedule: 
\series default
Un programa para gestionar cuándo Puppet tiene permitido administrar este
 recurso.
 El valor de este metaparámetro debe ser el 
\emph on
nombre
\emph default
 de un recurso 
\emph on
schedule.

\series bold
\emph default
 
\series default
Esto significa que se debe declarar un recurso schedule
\series bold
\emph on
 
\series default
\emph default
y luego referirse a él por su nombre
\series bold
.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
schedule { 'everyday': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

period => daily, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

range => "2-4" 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
exec { "/usr/bin/apt-get update": 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

schedule => 'everyday' 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
stage: 
\series default
En cuál estado de ejecución esta clase debería residir.
 Este metaparámetro sólo puede ser usado con clases, y solo declarándolo
 con la sintaxis de recursos.
 No se puede usar con recursos normales o en clases declaradas con 
\emph on
include
\emph default
.
\end_layout

\begin_deeper
\begin_layout Standard
Por defecto, todas las clases son declaradas en el estado principal.
 Para asignar una clase a un estado diferente, se debe:
\end_layout

\begin_layout Itemize
Declarar un nuevo estado como un recurso 
\emph on
stage
\emph default
.
 
\end_layout

\begin_layout Itemize
Declarar un orden de relación entre el nuevo el nuevo estado y el estado
 
\emph on
main
\emph default
.
\end_layout

\begin_layout Itemize
Usar la sintaxis de recurso para declarar la clase y poner el 
\emph on
stage
\emph default
 deseado.
\end_layout

\begin_layout Standard
Por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
stage { 'pre':
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

before => Stage['main'], 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
class { 'apt-updates': 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

stage => 'pre', 
\end_layout

\begin_layout Standard
}
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
subscribe: 
\series default
Cuando este atributo está presente, el recurso suscripto aplicara los cambios
 
\emph on
antes
\emph default
 que este recurso.
\end_layout

\begin_deeper
\begin_layout Itemize
Si Puppet realiza cambios a cualquier recurso subscripto, esto causará que
 este recurso se refresque.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
tag: 
\series default
Agrega la etiqueta especificada al recurso asociado.
 si bien todos los recursos son automáticamente etiquetados con la mayor
 cantidad de informacion posible, puede ser útil agregar su propia etiquetas
 a los recursos.
\end_layout

\begin_deeper
\begin_layout Standard
Ejemplo:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
file {'/etc/hosts': 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

ensure => file, 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

source => 'puppet:///modules/site/hosts', 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

mode => '0644', 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

tag => ['bootstrap', 'minimumrun', 'mediumrun'], 
\end_layout

\begin_layout Standard
}
\end_layout

\end_deeper
\begin_layout Subsubsection
Lenguaje
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Standard
Las variables guardan valores para que sean accedidos más tarde.
 En Puppet, las variables son en realidad constantes ya que no pueden ser
 reasignadas.
 Los nombres de variables comienzan con el signo $ y son sensibles a mayúsculas.
 La mayoría de los nombres deben comenzar con una letra en minúscula o un
 guión bajo.
 Los nombres pueden incluir:
\end_layout

\begin_layout Itemize
Mayúsculas y minúsculas
\end_layout

\begin_layout Itemize
Números
\end_layout

\begin_layout Itemize
Guión bajo
\end_layout

\begin_layout Standard
Si el primer carácter es un guión bajo, esa variable debería ser accedida
 solo desde su propio alcance.
\end_layout

\begin_layout Subparagraph
Sintaxis
\end_layout

\begin_layout Standard

\family typewriter
$contenido = "algún contenido
\backslash
n"
\end_layout

\begin_layout Standard
Los nombres de variables tienen como prefijo un signo $.
 Los valores son asignados a ellas con el símbolo = y se pueden asignar
 valores de cualquier tipo de dato.
 La variable contendrá el valor que la declaración resuelve, en vez de una
 referencia a la declaración.
 
\end_layout

\begin_layout Standard
Las variables solo pueden ser asignadas utilizando su nombre corto.
 Esto es, un alcance dado no puede asignar a variables en un ámbito exterior.
\end_layout

\begin_layout Paragraph
Asignar múltiples variables
\end_layout

\begin_layout Standard
Se pueden asignar múltiples variables de una vez desde un array o hash.
\end_layout

\begin_layout Subparagraph

\series bold
Arrays
\end_layout

\begin_layout Standard
Cuando se asignan múltiples variables desde un array, debe haber un número
 igual de variables y valores.
 Si no coinciden, la operación fallará.
 Arrays anidados también pueden ser usados.
\end_layout

\begin_layout Standard

\family typewriter
[$a, $b, $c] = [1,2,3] # $a = 1, $b = 2, $c = 3
\end_layout

\begin_layout Standard

\family typewriter
[$a, [$b, $c]] = [1,[2,3]] # $a = 1, $b = 2, $c = 3 
\end_layout

\begin_layout Standard

\family typewriter
[$a, $b] = [1, [2]] # $a = 1, $b = [2] 
\end_layout

\begin_layout Standard

\family typewriter
[$a, [$b]] = [1, [2]] # $a = 1, $b = 2
\end_layout

\begin_layout Subparagraph

\series bold
Hashes
\end_layout

\begin_layout Standard
Cuando se asignan múltiples variables con un hash, las variables son listadas
 en un array en el lado izquierdo de la asignación, y el hash está del lado
 derecho.
 Las claves de hash deben coincidir su nombre correspondiente de variable.
\end_layout

\begin_layout Standard
[$a, $b] = {a => 10, b => 20} # $a = 10, $b = 20 
\end_layout

\begin_layout Paragraph
Resolución
\end_layout

\begin_layout Standard

\family typewriter
file {'/tmp/testing': 
\end_layout

\begin_layout Standard

\family typewriter
ensure => file,
\end_layout

\begin_layout Standard

\family typewriter
content => $content, 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
$address_array = [$address1, $address2, $address3]
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
El nombre de la variable puede ser usado en cualquier lugar donde un valor
 de su tipo de dato fuera aceptado, incluyendo expresiones, funciones y
 atributos de recursos.
 Puppet reemplazará el nombre de la variable por su valor.
 Por defecto, variables sin asignar tienen el valor 
\emph on
undef
\emph default
.
\end_layout

\begin_layout Paragraph
Interpolación
\end_layout

\begin_layout Standard

\family typewriter
$rule = "Allow * from $ipaddress"
\end_layout

\begin_layout Standard

\family typewriter
file { "${homedir}/.vim":
\end_layout

\begin_layout Standard

\family typewriter
ensure => directory, 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
Puppet puede resolver variables en strings entre comillas dobles, esto es
 llamado interpolación.
 Dentro de las comillas dobles, se puede opcionalmente envolver el nombre
 de la variable (la porción luego de $) con llaves (${nombre_variable}).
 Esta sintaxis ayuda a evitar ambigüedades y permite ubicar las variables
 directamente siguiendo a caracteres que no son espacios en blanco.
 Estas llaves opcionales, están permitidas solo dentro de strings.
\end_layout

\begin_layout Paragraph
Comportamiento
\end_layout

\begin_layout Subparagraph

\series bold
Alcance
\end_layout

\begin_layout Standard
El área de código donde una variable dada es visible está dictada por su
 alcance.
 Las variables en un alcance dado solo están disponibles dentro de ese alcance/á
mbito su alcance hijo, y cualquier alcance local puede sobre escribir localmente
 las variables que recibe de sus padres.
\end_layout

\begin_layout Subparagraph

\series bold
Acceso a variables fuera de alcance
\end_layout

\begin_layout Standard
Se puede acceder a variables fuera de alcance utilizando su nombre completo
 (qualified name).
\end_layout

\begin_layout Standard

\family typewriter
$vhostdir = $apache::params::vhostdir
\end_layout

\begin_layout Subsubsection
Orden y relaciones
\end_layout

\begin_layout Standard
Por defecto, Puppet aplica los recursos en el orden en que son declarados
 en el manifiesto.
 Sin embargo, si un grupo de recursos deben siempre ser administrados en
 un orden específicom se debe explicitar declarando tales relaciones con
 metaparámetros de relación, flechas y la función 
\family typewriter
\emph on
require
\family default
\emph default
.
\end_layout

\begin_layout Paragraph
Utilizando metaparámetros
\end_layout

\begin_layout Standard
El valor de todas las relaciones debe ser una referencia a un recurso, apuntando
 a uno o más recursos objetivos.
\end_layout

\begin_layout Standard
before: Aplica un recurso 
\emph on
antes 
\emph default
que el recurso objetivo.
\end_layout

\begin_layout Standard
requiere: Aplica un recurso 
\emph on
después 
\emph default
que el recurso objetivo.
\end_layout

\begin_layout Standard
notify: Aplica un recurso 
\emph on
antes
\emph default
 que el recurso objetivo.
 El recurso objetivo se refresca si el recurso que notifica cambia.
\end_layout

\begin_layout Standard
subscribe: Aplica un recurso 
\emph on
después
\emph default
 que el recurso objetivo.
 El recurso suscripto se refresca si el recurso cambia.
\end_layout

\begin_layout Standard
Estos dos ejemplos crean la misma relación de orden:
\end_layout

\begin_layout Itemize
Ejemplo uno:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
package { 'openssh-server':
\end_layout

\begin_layout Standard

\family typewriter
ensure => present,
\end_layout

\begin_layout Standard

\family typewriter
before => File['/etc/ssh/sshd_config'],
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\end_deeper
\begin_layout Itemize
Ejemplo dos:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
file { '/etc/ssh/sshd_config':
\end_layout

\begin_layout Standard

\family typewriter
ensure => file, 
\end_layout

\begin_layout Standard

\family typewriter
mode => '0600',
\end_layout

\begin_layout Standard

\family typewriter
source => 'puppet:///modules/sshd/sshd_config',
\end_layout

\begin_layout Standard

\family typewriter
require => Package['openssh-server'], 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\end_deeper
\begin_layout Paragraph
Utilizando flechas
\end_layout

\begin_layout Standard
Se pueden cear relaciones entre dos recursos o grupos de recursos usando
 los operadores
\family typewriter
->
\family default
 y 
\family typewriter
~>
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
-> 
\family default
\emph default
: Flecha de ordnamiento.
 Aplica el recurso izquierdo 
\emph on
antes 
\emph default
que el recurso derecho.
\end_layout

\begin_layout Standard

\family typewriter
\emph on
~>
\family default
\emph default
 : Flecha de notificación.
 Aplica el recurso izquierdo primero.
 Si este cambia, el recurso derecho se refrescará.
\end_layout

\begin_layout Itemize
Ejemplo uno:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
Package['ntp'] -> File['/etc/ntp.conf'] ~> Service['ntpd']
\end_layout

\end_deeper
\begin_layout Itemize
Ejemplo dos:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
# Primero tener:
\end_layout

\begin_layout Standard

\family typewriter
package{ 'openssh-server':
\end_layout

\begin_layout Standard

\family typewriter
ensure => present,
\end_layout

\begin_layout Standard

\family typewriter
}-> # Luego tener:
\end_layout

\begin_layout Standard

\family typewriter
file { '/etc/ssh/sshd_config': 
\end_layout

\begin_layout Standard

\family typewriter
ensure => file, 
\end_layout

\begin_layout Standard

\family typewriter
mode => '0600',
\end_layout

\begin_layout Standard

\family typewriter
source => 'puppet:///modules/sshd/sshd_config', 
\end_layout

\begin_layout Standard

\family typewriter
} ~> # Y por último:
\end_layout

\begin_layout Standard

\family typewriter
service { 'sshd': 
\end_layout

\begin_layout Standard

\family typewriter
ensure => running, 
\end_layout

\begin_layout Standard

\family typewriter
enable => true,
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\end_deeper
\begin_layout Subsubsection
Definición de nodos
\end_layout

\begin_layout Standard
Una definición o declaración de nodo es un bloque de código Puppet que sólo
 será incluido en catálogos de nodos que coincidan.
 Esta característica permite asignar configuraciones específicas a nodos
 específicos.
\end_layout

\begin_layout Standard
Las declaraciones de nodos sólo coinciden con los nombres de los nodos.
 Por defecto, el nombre de un nodo es su 
\emph on
certname.
\end_layout

\begin_layout Standard
# node 'www1.example.com' { include common include apache include squid }
 node 'db1.example.com' { include common include mysql }
\end_layout

\begin_layout Paragraph
Ubicación
\end_layout

\begin_layout Standard
Las definiciones de los nodos deben estar en el manifiesto principal.
 Éste puede ser un archivo o un directorio conteniendo muchos archivos.
\end_layout

\begin_layout Standard

\family typewriter
# /etc/puppetlabs/puppet/manifests/site.pp 
\end_layout

\begin_layout Standard

\family typewriter
node 'www1.example.com' {
\end_layout

\begin_layout Standard

\family typewriter
include common
\end_layout

\begin_layout Standard

\family typewriter
include apache
\end_layout

\begin_layout Standard

\family typewriter
include squid 
\end_layout

\begin_layout Standard

\family typewriter
} 
\end_layout

\begin_layout Standard

\family typewriter
node 'db1.example.com' {
\end_layout

\begin_layout Standard

\family typewriter
include common 
\end_layout

\begin_layout Standard

\family typewriter
include mysql 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
En este ejemplo, solo el primero nodo obtendrá las clases 
\emph on
apache
\emph default
 y 
\emph on
squid
\emph default
 mientas que el segundo tendrá 
\emph on
mysql
\emph default
.
 Ambos recibirán la clase 
\emph on
common
\emph default
.
\end_layout

\begin_layout Paragraph
Nombramiento
\end_layout

\begin_layout Standard
Una declaración de nodo debe realizarse según:
\end_layout

\begin_layout Itemize
Un string entre comillas conteniendo sólo letras, números, guiones bajos,
 guiones medios y puntos.
\end_layout

\begin_layout Itemize
Expresiones regulares.
\end_layout

\begin_layout Itemize
La palabra 
\emph on
default, 
\emph default
sin comillas.
\end_layout

\begin_layout Standard
Se pueden utilizar listas de nombres separados por comas para crear grupos
 de nodos son una sola declaración de nodo:
\end_layout

\begin_layout Standard

\family typewriter
node 'www1.example.com', 'www2.example.com', 'www3.example.com' { 
\end_layout

\begin_layout Standard

\family typewriter
include common 
\end_layout

\begin_layout Standard

\family typewriter
include apache, squid 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Paragraph
El nodo default
\end_layout

\begin_layout Standard
Si ninguna declaración de nodo es dad o no puede ser encontrada, el nodo
 
\emph on
default 
\emph default
será utilizado.
\end_layout

\begin_layout Paragraph
Expresines regulares
\end_layout

\begin_layout Standard
Pueden ser utilizadas como nombres de nodo.
 Este es otro método para escribir una sola definición de nodo que coincida
 con múltiples nodos.
\end_layout

\begin_layout Subparagraph
Coindidencias
\end_layout

\begin_layout Standard
Un nodo dado sólo obtendrá los contenidos de una definición de nodo, incluso
 si dos declaraciones de nodo pueden coincidir con el nombre del mismo.
 Puppet realizará las verificaciones para decidir cual definición utilizar:
\end_layout

\begin_layout Enumerate
Si hay una definición de nodo que contenga el nombre exacto del nodo, entonces
 utilizará esta.
\end_layout

\begin_layout Enumerate
Si hay una expresión regular que coincida cone el nombre del nodo, entonces
 utilizará esta.
\end_layout

\begin_layout Enumerate
Si el nombre de nodo es del tipo FQDN (Fully Qualified Domain Name), Puppet
 cortará el grupo final y comenzará nuevamente desde el punto uno.
\end_layout

\begin_layout Enumerate
Puppet utilizará el nodo default.
\end_layout

\end_body
\end_document

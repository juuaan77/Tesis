#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
\usepackage{babel}
\addto\captionsenglish{%
 \renewcommand{\figurename}{Figura }%
 \renewcommand{\contentsname}{Índice}%
 \renewcommand{\listfigurename}{Lista de figuras}%
 \renewcommand{\tablename}{Tabla }%
 \renewcommand{\listtablename}{Lista de tablas}%
 \renewcommand{\partname}{Capítulo }%
}
\end_preamble
\options listitoc, tablecaptionabove, bibtotoc
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\bullet 1 0 9 -1
\bullet 2 0 15 -1
\bullet 3 0 6 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Infraestructura tecnológica virtual con automatización y orquestación.
\end_layout

\begin_layout Author
\begin_inset Graphics
	filename Escudo_UNC_modernoo.png
	width 4in
	height 4in
	keepAspectRatio
	rotateOrigin centerBottom

\end_inset


\end_layout

\begin_layout Author
Juan Arese, Werner Diers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Part
Introducción
\end_layout

\begin_layout Section
Resumen del Proyecto Integrador
\end_layout

\begin_layout Standard
El Sistema desarrollado en este Proyecto Integrador, pretende facilitar
 algunas de las tareas que los administradores de los laboratorios realizan
 en las salas de informática.
 Las funcionalidades desarrolladas permiten a los administradores (o incluso
 a cualquier persona sin conocimiento técnico) crear maquinas virtuales
 con un solo click, dichas maquinas virtuales cuentan con todos los servicios
 y programas necesarios para los alumnos de las diferentes carreras o inclusive
 se pueden crear maquinas virtuales con otros perfiles, como un perfil para
 docentes.
 Además, permite orquestar las políticas a seguir de las diferentes máquinas
 de la red.
\end_layout

\begin_layout Subsection
Descripción
\end_layout

\begin_layout Standard
El sistema de infraestructura virtual con automatización y orquestación,
 tiene como objetivo principal brindar una herramienta a los administradores
 de laboratorios que facilite la preparación y configuración de sus aulas
 de manera simple.
\end_layout

\begin_layout Standard
El sistema está dividido en dos partes.
 Una parte de la herramienta está destinada al despliegue en masa de máquinas
 virtuales.
 Permite al administrador, crear múltiples máquinas virtuales con escasa
 interacción humana, de forma automática.
 Pudiéndose especificar el sistema operativo deseado y componentes de hardware.
 Del mismo modo, en un laboratorio con máquinas físicas, es posible realizar
 el despliegue a través de la red.
\end_layout

\begin_layout Standard
La segunda parte está destinada a la administración de la configuración
 de las máquinas virtuales.
 El sistema permite aplicar cambios de configuración y políticas a un conjunto
 de máquinas como también a máquinas particulares.
 Esto evita que el administrador tenga que preparar cada estación de trabajo
 de a una por vez, disminuyendo la carga de trabajo y el tiempo requerido
 para llevar a cabo la tarea.
\end_layout

\begin_layout Standard
Teniendo en cuenta que las herramientas utilizadas en este sistema deben
 ser de uso libre se utilizará como sistepa operativo base alguna distribución
 GNU/Linux.
\end_layout

\begin_layout Standard
El sistema incluye desarrollo en el lenguaje de programación Python, bash
 y el lenguaje propio de Puppet, la herramienta utilizada para la orquestación.
 El servidor de aprovisionamiento, haciendo uso del protocolo PXE, será
 el encargado de atender las peticiones de los dispositivos para su instalación.
\end_layout

\begin_layout Standard
Este Proyecto Integrador servirá como base para futuros Proyectos.
\end_layout

\begin_layout Subsection
Objetivos 
\end_layout

\begin_layout Standard

\series bold
Principal:
\series default
 
\end_layout

\begin_layout Itemize
Desarrollar un sistema para manejar automatismos administrados de políticas
 de una institución o empresa, para que el administrador pueda configurar
 las máquinas virtuales o físicas que se utilizan en la misma.
 Como caso particular se tomará un laboratorio informático de aprendizaje.
\end_layout

\begin_layout Standard

\series bold
Secundarios: 
\end_layout

\begin_layout Itemize
Estudiar Sistemas Operativos para servidor.
\end_layout

\begin_layout Itemize
Estudiar herramientas de virtualización.
\end_layout

\begin_layout Itemize
Estudiar herramientas de aprovisionamiento.
 
\end_layout

\begin_layout Itemize
Estudiar herramientas de administración de configuración.
\end_layout

\begin_layout Itemize
Analizar protocolos para inicio a través de la red como PXE.
\end_layout

\begin_layout Standard

\series bold
Antecedentes de Proyectos similares 
\end_layout

\begin_layout Itemize
No hay antecedentes en este tema.
\end_layout

\begin_layout Subsection
Intereses personales 
\end_layout

\begin_layout Standard
La principal motivación en este Proyecto Integrador es darle un final a
 la carrera de grado de Ingeniería en Computación intentando abarcar la
 mayor cantidad de temáticas posibles.
 Las asignaturas que abarca principalmente son Redes de Computadoras, Sistemas
 Operativos, Ingeniería de Software, Informática, Comunicaciones de Datos
 y Algoritmos y estructuras de Datos.
 Abordamos temas como sistemas operativos, sistemas de archivos, protocolos,
 metodologías de desarrollo, redes de datos, programación en Python, Shell
 scripting, virtualización, diagramas UML.
\end_layout

\begin_layout Subsection
Intereses Institucionales 
\end_layout

\begin_layout Standard
La Facultad de Ciencias Exactas, Físicas y Naturales actualmente cuenta
 con alrededor de cinco aulas de informática, en las cuales se dictan materias
 de todos los ciclos y especialidades de ingeniería.
 La idea del Proyecto Integrador es desarrollar un sistema de infraestructura
 con automatización y orquestación que permita disminuir la carga de trabajo
 de los administradores de estas aulas y facilitar las tareas de mantenimiento
 de las mismas, cumpliendo con las políticas del área que administra las
 aulas.
\end_layout

\begin_layout Subsection
Metodología 
\end_layout

\begin_layout Standard
Para afrontar el Proyecto Integrador de la carrera se utilizó una metodología
 de desarrollo ágil de software basado en el desarrollo iterativo e incremental.
 El trabajo desarrollado en una unidad de tiempo es llamado una iteración,
 las cuales constan de un corto lapso de tiempo de entre una y tres semanas.
 Cada iteración se compone de un ciclo de vida que integra diversas etapas
 como planificación, definición de los requerimientos, investigación, diseño,
 codificación, pruebas y documentación.
 En cada iteración se agrega una nueva “funcionalidad” al sistema y a medida
 que avanzan los ciclos el sistema aumenta de tamaño, por esto lo llamamos
 incremental.
 Otra característica de la metodología ágil que se utilizó, es una comunicación
 fluida con el “cliente” que en este caso son los Directores del Proyecto
 Integrador, de los que también se obtienen los requerimientos.
 Esto permite una buena retroalimentación, con la cual se devuelven correcciones
 .
 No ser estrictos con la documentación es una característica que se tomó
 del desarrollo ágil, tener todo anotado luego facilita la generación del
 informe.
 
\end_layout

\begin_layout Standard

\series bold
Lugar previsto para la realización: 
\end_layout

\begin_layout Itemize
Laboratorio de Arquitectura de Computadoras, Facultad de Ciencias Exactas,
 Físicas y Naturales.
 
\end_layout

\begin_layout Standard

\series bold
Requerimiento de Instrumental y Equipos: 
\end_layout

\begin_layout Itemize
Computadora personal.
\end_layout

\begin_layout Standard

\series bold
Inversión económica: 
\end_layout

\begin_layout Itemize
Inversión provista por el alumno: ninguna
\end_layout

\begin_layout Itemize
Apoyo económico externo a la Facultad: ninguno.
\end_layout

\begin_layout Subsection
Requerimientos 
\end_layout

\begin_layout Standard
Los requerimientos del sistema se obtuvieron directamente desde el Director
 y el Codirector del Proyecto Integrador.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar distintos sistemas operativos:
\end_layout

\begin_deeper
\begin_layout Standard
CentOS 
\end_layout

\begin_layout Standard
Ubuntu
\end_layout

\begin_layout Standard
Debian
\end_layout

\begin_layout Standard
Windows 
\end_layout

\end_deeper
\begin_layout Enumerate
La herramienta debe poder aprovisionar máquinas servidores .
 
\end_layout

\begin_layout Enumerate
La herramienta debe aprovisionar a través de la red.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar utilizando plantillas.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder aprovisionar utilizando repositorios locales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder actualizar los repositorios locales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder setear politicas a las máquinas virtuales,utilizando
 Puppet.
 
\end_layout

\begin_layout Enumerate
La herramienta debe poder monitorizar el estado de las máquinas virtuales.
 
\end_layout

\begin_layout Enumerate
La herramienta debe ser escalable, integrar nuevas máquinas virtuales fácilmente.
 
\end_layout

\begin_layout Enumerate
La herramienta debe utilizar licencias de código abierto.
 
\end_layout

\begin_layout Enumerate
La herramienta debe estar implementada en la versión más actual al momento
 de realizar el Proyecto Integrador.
\end_layout

\begin_layout Subsection
Cronograma a seguir
\end_layout

\begin_layout Standard
El cronograma está dividido en seis etapas diferentes:
\end_layout

\begin_layout Itemize
Familiarización con el sistema operativo GNU/Linux elegido.
 
\end_layout

\begin_layout Itemize
Investigación de diferentes herramientas de virtualización.
 
\end_layout

\begin_layout Itemize
Investigación de diferentes herramientas de aprovisionamiento.
\end_layout

\begin_layout Itemize
Pruebas de las herramientas seleccionadas.
 
\end_layout

\begin_layout Itemize
Pruebas de la herramienta de administración de configuración.
 
\end_layout

\begin_layout Itemize
Preparación y desarrollo del informe del trabajo final y cierre del mismo.
\end_layout

\begin_layout Subsection
Objetivo a alcanzar en cada etapa:
\end_layout

\begin_layout Itemize

\series bold
Primera etapa:
\series default
 conocer el sistema operativo GNU/Linux.
 La principal motivación, es la de informarse sobre la base donde se implementar
á el sistema desarrollado en este Proyecto Integrador.
 
\end_layout

\begin_layout Itemize

\series bold
Segunda etapa:
\series default
 obtener los conocimientos suficientes para crear y administrar máquinas
 virtuales.
 
\end_layout

\begin_layout Itemize

\series bold
Tercera etapa:
\series default
 conocer cuáles son las herramientas disponibles y utilizadas en ambientes
 de producción para el aprovisionamieto de máquinas, teniendo en cuenta
 que deben ser de código abierto, analizarlas y elegir la más apropiada
 para realizar el Proyecto Integrador.
 
\end_layout

\begin_layout Itemize

\series bold
Cuarta etapa: 
\series default
implementar las herramientas seleccionadas en conjunto.
 
\end_layout

\begin_layout Itemize

\series bold
Quinta etapa:
\series default
 realizar la implementación conjunta de todas las herramientas automatizando
 la instalación y realizar configuracines pertinentes en los sistemas ya
 instalados, por medio de Puppet.
 
\end_layout

\begin_layout Itemize

\series bold
Sexta etapa: 
\series default
desarrollo del informe del trabajo final
\end_layout

\begin_layout Part
Marco teórico
\end_layout

\begin_layout Standard
Previamente al abordaje del desarrollo, requerimos conocimientos teóricos
 que nos posibiliten comprender el entorno donde se ejecutarán las aplicaciones
 que componen el Sistema, las herramientas que darán soporte o permitirán
 cumplir con las funcionalidades previstas y las que se utilizarán para
 desarrollar.
 Algunas de las mismas fueron explícitamente solicitadas en los requerimientos.
 El resto de las herramientas, que están implícitas en los requerimientos,
 precisaron de investigación y pruebas para conocer si permiten cumplir
 estos requerimientos y además, si hay varias opciones, elegir la más convenient
e.
 Podemos dividir esta sección del informe en cuatro áreas diferentes:
\end_layout

\begin_layout Itemize
Sistema operativo 
\end_layout

\begin_layout Itemize
Virtualización 
\end_layout

\begin_layout Itemize
Aprovisionamiento 
\end_layout

\begin_layout Itemize
Orquestación
\end_layout

\begin_layout Standard
La información contenida en esta sección se desprende de las investigaciones
 realizadas en cada una de las etapas del Proyecto Integrador.
\end_layout

\begin_layout Section
Sistema operativo
\end_layout

\begin_layout Subsection
FreeBSD
\end_layout

\begin_layout Standard
FreeBSD es un sistema operativo basado en BSD para arquitecturas Intel (x86
 e Itanium), AMD64, AlphaTM y UltraSPARC.
 
\end_layout

\begin_layout Standard
FreeBSD viene con una excelente colección de herramientas de sistema como
 parte del sistema base.
 A pesar de esto, existen otras que no vienen incluidas y se necesitan instalar
 para utilizarlas.
 FreeBSD ofrece dos tecnologías complementarias para instalar software de
 terceros en el sistema: la Colección de puertos o ports de FreeBSD y los
 paquetes binarios.
 Los paquetes binarios son archivos simples que descargamos desde repositorios.
 Contienen una copia de los programas binarios precompilados de la aplicación
 y se pueden manipular con las herramientas de gestión de paquetes de FreeBSD:
 pkg_add , pkg_delete , pkg_info , etc.
 Por otro lado, existen ciertos pasos que se deben llevar a cabo para compilar
 un programa (descargar, desempaquetar, parchear, compilar e instalar).
 Los ficheros que conforman un port permiten que el sistema se encargue
 de todo esto, mediante un conjunto simple de órdenes.
 La colección de puertos para instalar se encuentra en /usr/ports.
\end_layout

\begin_layout Standard
FreeBSD proporciona compatibilidad binaria con muchos otros sistemas operativos
 tipo UNIX, como Linux.
 Esto es necesario, ya que muchos desarrolladores y compañías sólo desarrollan
 para Linux.
 La compatibilidad binaria permite a los usuarios utilizar en FreeBSD cerca
 del 90% de las aplicaciones desarrolladas para Linux sin que sea necesario
 realizar alguna modificación sobre la aplicación.
\end_layout

\begin_layout Standard
Otras características:
\end_layout

\begin_layout Itemize
Servicios multiusuario que permiten a mucha gente usar el sistema FreeBSD
 simultáneamente.
\end_layout

\begin_layout Itemize
Conexión de redes TCP/IP muy robusta, con soporte para estándares industriales.
 
\end_layout

\begin_layout Itemize
La protección de memoria que garantiza que las aplicaciones (o los usuarios)
 no se estorben los unos a los otros.
\end_layout

\begin_layout Itemize
Compatibilidad binaria con muchos programas nativos de Linux, SCO, SVR4,
 BSDI y NetBSD.
 
\end_layout

\begin_layout Itemize
Soporte para multiprocesamiento simétrico con múltiples CPUs.
\end_layout

\begin_layout Subsection
Debian GNU/kFreeBSD
\end_layout

\begin_layout Standard
Debian GNU/kFreeBSD es un sistema operativo de propósito general.
 Es una distribución oficial de GNU Debian que usa el Kernel de FreeBSD
 en vez del Kernel de Linux.
 Cerca del 90% del Software de Debian está disponible para Debian GNU/kFreeBSD.
\end_layout

\begin_layout Standard
Debian GNU/kFreeBSD soporta ZFS desde el kernel.
 Esto también puede significar un mejor rendimiento y mayor estabilidad
 en discos que utilicen el sistema de archivos ZFS.
 Debian GNU/kFreeBSD podría instalarse en una jaula.
 Esto permitiría aprovechar todas las ventajas de FreeBSD en el servidor,
 brindándole la opción de usar Debian a los usuarios del servidor y eliminando
 la necesidad de que se familiaricen con FreeBSD.
\end_layout

\begin_layout Subsection
PC-BSD
\end_layout

\begin_layout Standard
PC-BSD es un sistema operativo de escritorio basado en FreeBSD.
 La idea principal, es agregar las características conocidas de FreeBSD
 como sistema operativo para servidores, como lo son la estabilidad y la
 seguridad, a un sistema operativo de escritorio amigable.
\end_layout

\begin_layout Standard
Para la instalación, brinda una interfaz gráfica que permite la elección
 de opciones de instalación.
 Presenta dos perfiles de instalación, cada una con una serie de programas
 opcionales para seleccionar.
\end_layout

\begin_layout Standard
Un perfil de instalación es el Desktop o escritorio, orientado a computadoras
 de usuario.
 Básicamente esta opción es la idea de PC-BSD.
 Instala y configura el entorno de escritorio KDE por defecto.
 También se pueden seleccionar otros escritorios como GNOME o XFCE, herramientas
 de virtualización, herramientas de desarrollo, etc.
 El otro perfil de instalación está orientado a servidores.
 No instala paquetes de interfaz gráfica y permite instalar servidores web,
 servidores de base de datos, servidores de archivos, herramientas de virtualiza
ción, etc.
 PC-BSD además agrega lo que promete ser la nueva forma de administración
 de paquetes para FreeBSD: pkgng ( pkg next generation ).
 Esta herramienta no viene instalada por defecto en FreeBSD.
 Su funcionamiento se asemeja al apt-get de Linux.
\end_layout

\begin_layout Standard
Otra característica importante es que PC-BSD utiliza ZFS como sistema de
 archivos, instalándolo casi sin intervención del usuario (si así se desea).
 
\end_layout

\begin_layout Subsection
CentOS 
\end_layout

\begin_layout Standard
CentOS es un distribución Linux empresarial, basada en Red Hat Enterprise
 Linux.
 CentOS concuerca con la política de distribución de Red Hat y apunta a
 ser binariamente compatible en su totalidad.
 Cada versión de esta distro tiene soporte por siete años en cuestiones
 de actualizaciones de mantenimiento y seguridad, lo que se traduce en un
 ambiente confiable, predecible, reproducible, de bajo mantenimiento y seguro.
\end_layout

\begin_layout Standard
La principal ventaja de esta distro es que se obtiene un conjunto estable
 de la mayoría de paquetes que por lo general solo incluyen correcciones
 de errores.
 En su última versión, CentOS 7 sólo está disponible para la arquitectura
 x86_64, y representa un gran cambio frente a versiones anteriores del sistema
 operativo, como la inclusión de systemd, Gnome 3, GRUB 2, y el sistema
 de archivos XFS.
 El entorno de escritorio KDE también forma parte de la oferta de CentOS
 7.
 
\end_layout

\begin_layout Standard
Principales novedades de CentOS 7:
\end_layout

\begin_layout Itemize
Actualización del núcleo del sistema: Kernel 3.10.0.
 
\end_layout

\begin_layout Itemize
Soporte para Linux Containers.
 
\end_layout

\begin_layout Itemize
Inclusión de VMware Tools y controladores de gráficos 3D.
 
\end_layout

\begin_layout Itemize
OpenJDK-7 como JDK por defecto.
 
\end_layout

\begin_layout Itemize
Cambio a systemd.
 
\end_layout

\begin_layout Itemize
Cambio a firewalld y GRUB2 .
\end_layout

\begin_layout Itemize
XFS es el sistema de archivos por defecto y permite escalar la capacidad
 de almacenamiento del sistema hasta 500 terabytes.
 XFS es un sistema de archivos de 64 bits con journaling de alto rendimiento,
 y está especialmente indicado para discos grandes (superiores a 1 TB).
 No obstante y para necesidades menos exigentes se pueden emplear otros
 sistemas de archivos, como Ext4.
 
\end_layout

\begin_layout Itemize
iSCSI y FCoE (Fiber Channel over Ethernet) en el espacio del Kernel.
 
\end_layout

\begin_layout Itemize
Soporte para PPTv2 (Precision Time Protocol).
\end_layout

\begin_layout Itemize
Soporte para tarjetas Ethernet 40G.
 
\end_layout

\begin_layout Itemize
Soporte UEFI.
 
\end_layout

\begin_layout Standard
En cuanto a systemd, es el reemplazo de init como demonio para iniciar servicios
, procesos y recursos del sistema.
 Systemd es la nueva forma predeterminada de iniciar los sistemas Linux,
 y ha sido adoptado por Red Hat, Debian y Ubuntu, entre otros.
 CentOS 7 es compatible con Microsoft Active Directory (y obviamente con
 Red Hat), por lo que puede trabajar con facilidad en entornos heterogéneos.
 CentOS 7 incluye PCP (Performance Co-Pilot), un conjunto de frameworks
 y servicios en tiempo real para supervisar y monitorizar el rendimiento
 del sistema.
\end_layout

\begin_layout Subsection
Solaris
\end_layout

\begin_layout Standard
Solaris es un sistema operativo de tipo Unix desarrollado por Sun Microsystems
 desde 1992 como sucesor de SunOs.
 Es un sistema certificaco oficialmente como version de Unix.
 Aunque solaris fue desarrollado como software privado, la mayor parte de
 su codigo se ha liberado como proyecto de software libre denominado OpenSolaris.
 Solaris es famoso por su escalabilidad, especialmente en sistemas SPARC.
 Sun solaris se ejecuta sobre la arquitectura SPARC en 32 y 64 bits, o sobre
 procesadores x86 (incluidos Intel y AMD).
 Sin embargo, en agosto de 2010, Oracle decidió interrumpir la publicación
 y distribución de OpenSolaris.
\end_layout

\begin_layout Standard
Solaris tiene una reputación de ser muy adecuado para el multiprocesamiento
 simétrico (SMP), soportando un gran número de CPUs.
 Históricamente Solaris ha estado firmemente integrado con la plataforma
 hardware de Sun, SPARC, con la cual fue diseñado y promocionado como un
 paquete combinado.
 Esto proporcionaba frecuentemente unos sistemas más fiables pero con un
 coste más elevado que el del hardware de PC.
 
\end_layout

\begin_layout Standard
A partir de su versión 10, Sun Microsystems ha promocionado Solarios con
 sus propias estaciones de trabajo y servidores de 64 bits basados en procesador
es AMD Opteron e Intel Xeon, como también en sistemas de 32 bits.
 Esta versión añadió soporte para paravirtualización cuando es utilizada
 como “sistema operativo invitado” en ambientes basados en Xen.
 
\end_layout

\begin_layout Standard
En su última versión, 11.3, sus principales características son:
\end_layout

\begin_layout Itemize
Inculye una nueva versión de OpenStack (Juno) con soporte para topologías
 de red adicionales y nuevos servicios.
 
\end_layout

\begin_layout Itemize
SNAT, soporte Ipv6.
\end_layout

\begin_layout Itemize
Pools de almacenamiento.
 
\end_layout

\begin_layout Itemize
Aprovisionamiento de máquinas (bare metal provisioning) como servicio .
\end_layout

\begin_layout Itemize
Incluye soporte para desarrollo basado en la API REST utilizando el Demonio
 de Administración Remota (permite configuración remota de los sistemas
 Oracle usando Python, C y Java).
 
\end_layout

\begin_layout Itemize
Sistema de archivos ZFS.
\end_layout

\begin_layout Itemize
Solaris Containers
\end_layout

\begin_layout Section
Virtualización 
\end_layout

\begin_layout Standard
Virtualización es un término amplio para software ejecutándose, usualmente
 sistemas operativos, de manera concurrente y aislada de otros programas
 en el mismo sistema.
 Muchas de las implementaciones de virtualización utilizan un “hypervisor”,
 una capa de software que controla el harware y provee sistemas operativos
 huéspedes con acceso a los dispositivos de hardware subyacentes.
 El hypervisor permite ejecutar múltiples sistemas operativos en el mismo
 sistema físico ofreciendo hardware virtualizado al sistema opertativo huésped.
 Esta tecnología, provee un conjunto de herramientas para aumentar la flexibilid
ad y reducir los costos, los cuales son tópicos importantes en cualquier
 empresa o institución.
 En escencia, la virtualización imcrementa la flexibilidad desacoplando
 un sistema operativo y los servicios y aplicaciones soportados por él,
 de una plataforma de hardware física específica, permitiendo el establecimiento
 de múltiples entornos virtuales sobre una plataforma de hardware compartida.
 Estos entornos pueden ser creados localmente o aprovisionados extrenamente.
 La virtualización se destaca también apoyando la innovación a través del
 uso de entornos virtuales para practicar y aprender.
 Un estudiante puede comenzar un curso o trabajo un entorno de sistema conocido,
 estándar y aislado del entorno de producción; si se produce algún tipo
 de daño solo afecta al sistema virtual.
 Además se puede establecer entornos únicos de software para el aprendizaje
 sin demandar el uso exclusivo de recursos de hardware.
 Aunque en comparación los costos de inversión para tener un número elevado
 de máquinas físicas son mucho mayores que el costo para invertir en un
 servidor con altos recursos para realizar la virtualización, se podría
 decir que la virtualización posee inconvenientes vinculados con sus exigentes
 requerimientos de hardware, en cuanto a capacidad de procesamiento y de
 memoria RAM y de almacenamiento.
 Otra desventaja es que del sistema de virtualización depende del sistema
 operativo anfitrión.
 Es decir, el anfitrión es el punto débil del sistema ya que se comparte
 por todos los sistemas virtualizados, si se rompe éste, se rompen todas
 las máquinas virtuales.
\end_layout

\begin_layout Subsection
Tipos de virtualización
\end_layout

\begin_layout Subsubsection
Virtualización completa 
\end_layout

\begin_layout Standard
Consite en la virtualización de paquetes y herramientas para correr de forma
 totalmente virtualizada, sin modificaciones, sistemas operativos huéspedes.
 Este modo cuenta con la ventaja de consolidar sistemas viejos en hardware
 nuevo, más eficiente y reducir el espacio físico y costos de operación
 relativos al consumo energético y refrigeración de estos sistemas menos
 eficientes.
 La virtualización completa ofrece, sin embargo, menor rendimiento de entrada/sa
lida que instalaciones nativas (también llamadas “bare-metal” o “metal-pelado”)
 de sistemas operativos.
 Por ejemplo el software KVM, Xen, VMware Workstation o VirtualBox hacen
 uso de esta técnica.
 Cabe destacar que en el caso de KVM se requiere soporte de hardware para
 ejecutar la virtualización, ya sea con procesadores Intel o AMD.
 
\end_layout

\begin_layout Subsubsection
Para-virtualización 
\end_layout

\begin_layout Standard
Para-virtualización es un técnica de virtualización la cual implica ejecutar
 verisiones modificadas de los sistemas opetativos.
 El sistema operativo para-virtualizado es modificado para que se de cuenta
 que está siendo virtualizado, ofreciendo un habilidad aumentada para la
 optimización, ya que el huésped está al tanto de su entorno.
 El rendimiento está generalmente muy cerca de la ejecución nativa de sistemas
 operativos no virtualizados.
 Por ejemplo, utilizan esta técnica KVM, XEN y VMware Server ESX.
 
\end_layout

\begin_layout Subsubsection
Para-virtualización de drivers
\end_layout

\begin_layout Standard
La para-virtualización y la virtualización completa pueden ser combinadas
 para permitir a sistemas operativos no modificados recibir un rendimiento
 cercano de entrada/salida al de ejecución nativa, por medio de drivers
 para-virtualizados en sistemas opetativos completamente virtualizados.
\end_layout

\begin_layout Subsubsection
Virtualización a nivel del sistema operativo 
\end_layout

\begin_layout Standard
Esta técnica virtualiza un servidor físico a nivel del sistema operativo,
 permitiendo que múltiples servidores virtuales aislados y seguros se ejecuten
 sobre un solo servidor físico, pero con la particularidad de que tanto
 el sistema anfitrión como el huésped, comparten sistema operativo.
 Por ejemplo, Jaulas con Warden en FreeBSD, OpenVZ o Linux-Vserver usan
 esta técnica.
\end_layout

\begin_layout Subsubsection
Virtualización de aplicaciones
\end_layout

\begin_layout Standard
La virtualización de aplicaciones consiste en correr una aplicación sobre
 una máquina virtual usando los recursos reales.
 Por ejemplo la máquina virtual JAVA.
\end_layout

\begin_layout Subsubsection
Emulación 
\end_layout

\begin_layout Standard
Un emulador es hardware o software que permite a un sistema de computación
 comportarse como otro sistema.
 Generalmente, un emulador permite a un sistema correr software o utilizar
 dispositivos perisféricos dieñads para el otro sistema.
 Por ejemplo Qemu es un emulador muy usual en ingeniería.
 
\end_layout

\begin_layout Subsection
Herramientas de virtualización 
\end_layout

\begin_layout Standard
Algunas de las herramientas más utilizadas para virtualizar son las siguientes,
 sin embargo como uno de los requisitos es utilizar herramientas de código
 abierto, no se indagó acerca de VMWare: 
\end_layout

\begin_layout Itemize
VirtualBox 
\end_layout

\begin_layout Itemize
KVM/Qemu 
\end_layout

\begin_layout Itemize
Xen
\end_layout

\begin_layout Itemize
OpenVZ
\end_layout

\begin_layout Itemize
VMWare Workstation 
\end_layout

\begin_layout Subsubsection
VirtualBox
\end_layout

\begin_layout Standard
VirtualBox, desarrollado por Oracle, es un virtualizador completo de propósito
 general para hardware x86, orientado al uso para servidor, escritorio y
 embebido.
 Como software de código abierto, se puede utilizar bajo la licencia GNU
 General Public License 2 (GPL2) .
 
\end_layout

\begin_layout Standard
AL día de la fecha, VirtualBox corre en Windows, Linux, Macintosh y Solaris
 y soporta una amplia variedad de sistemas operativos, entre ellos RHEL(7,6,5,4)
, Windows (NT 4.0, 2000, XP, Server 2003, Vista, Windows 7, Windows 8, Windows
 10), DOS/Windows 3.x, Linux (2.4, 2.6, 3.x and 4.x), Solaris y OpenSolaris,
 OS/2, y OpenBSD.
 
\end_layout

\begin_layout Subsubsection
KVM/Qemu 
\end_layout

\begin_layout Standard
KVM (Kernel-based Virtual Machine), desarrollado por Red Hat Enterprise
 Linux, es una infraestructura de virtualización completa para el kernel
 de Linux que lo transforma en un hypervisor.
 Fue incorporado a la línea principal del kernel Linux en la versión 2.6.20.
 KVM requiere un procesador con hardware que permita extensión para virtualizaci
ón (Intel VT o AMD-V).
 También está disponible para instalarlo desde los “ports” de FreeBSD en
 la forma de módulos de kernel.
 
\end_layout

\begin_layout Standard
La para-virtualización tiene soporte para ciertos dispositivos en Linux,
 OpenBSD, FreeBSD y Windows (entre otros) utilizando la API VirtIO.
 Se tiene placa Ethernet, un controlador de entrada/salida de disco paravirtual,
 gráficos VGA.
 
\end_layout

\begin_layout Standard
Qemu puede utilizarse como emulador y como virtualizador.
 Cuando se utiliza como virtualizador, Qemu toma un rendimiento cercano
 al nativo.
 Para ello, debe ejecutarse bajo el hypervisor Xen o KVM.
 En conjunto KVM/Qemu, KVM es quien hace las veces de árbitro del acceso
 al CPU y memoria, y Qemu emula los recursos de hardware.
 
\end_layout

\begin_layout Standard
Una lista de los sistemas operativos soportados por esta herramienta se
 puede econtrar aquí : http://www.linux-kvm.org/page/Guest_Support_Status
\end_layout

\begin_layout Subsubsection
Xen 
\end_layout

\begin_layout Standard
Xen, desarrollado por University of Cambridge Computer Laboratory y mantenido
 por IBM, HP, Intel, AMD, RedHat, es una herramienta de virtualización que
 se ejecuta por debajo del sistema operativo y actúa como hypervisor.
\end_layout

\begin_layout Standard
Esta herramienta permite trabajar con virtualización completa y con paravirtuali
zación.
 Como KVM y VirtualBox, también posee una larga lista de sistemas operativos
 soportados.
\end_layout

\begin_layout Subsubsection
OpenVZ 
\end_layout

\begin_layout Standard
OpenVZ es una herramienta de virtualización para Linux basada en contenedores.
 OpenVZ crea múltiples contenedores aislados en un servidor físico y asegurando
 que las aplicaciones no entren en conflicto.
 Utiliza un kernel de Linux modificado y por consiguiente sólo puede correr
 Linux.
 Todos los contenedores comparten la misma arquitectura y versión del kernel.
 Cada contenedor se comporta como un servidor autónomo.
 Ya que OpenVZ emplea un modelo de kernel único, es tan escalable como kernel
 Linux 2.6, lo que significa que soporta hasta 64 CPUs y hasta 64 GiB de
 RAM.
 Un entorno virtual único se puede escalar hasta el equipo físico entero.
 También cuenta con migración en vivo que posibilita mover un contenedor
 de in servidor físico a otro sin apagar el contenedor.
 Un propietario (root) de un servidor físico OpenVZ (conocido como Nodo
 de Hardware) puede ver todos los procesos y archivos de los contenedores.
 Esto hace la administración masiva de escenarios posible: se puede ejecutar
 un simple script de intérprete de comandos que actualice todos (o sólo
 algunos seleccionados) los contenedores a la vez.
\end_layout

\begin_layout Section
Aprovisionamiento 
\end_layout

\begin_layout Standard
En general, aprovisionamiento, significa proveer o hacer que algo esté disponibl
e.
 El término es utilizado en un gran variedad de contextos en el área de
 Tecnologías de Información.
 En este Proyecto Integrador, el término hace referencia a lo siguiente:
 Aprovisionamiento es el conjunto de acciones para preparar una máquina
 virtual, con el sistema apropiado, datos y software, y dejarla lista para
 su operación.
 
\end_layout

\begin_layout Itemize
Tareas típicas que se tienen que llevar a cabo para que esto suceda son:
 
\end_layout

\begin_layout Itemize
Seleccionar el conjunto de hardware virtualizado (memoria RAM, disco, cantidad
 de procesadores asignados, placa de red, etc) para crear una máquina virtual
 bare-metal.
\end_layout

\begin_layout Itemize
Cargar el sistema operativo adecuado.
\end_layout

\begin_layout Itemize
Configurar el sistema (dirección IP, gateway, DNS, hostname, MAC, etc).
\end_layout

\begin_layout Itemize
Actualizar el sistema y aplicar parches.
\end_layout

\begin_layout Itemize
Cargar el conjunto de aplicaciones necesarias.
\end_layout

\begin_layout Itemize
Configurar el sistema para adaptarlo a las políticas definidas de la institución.
\end_layout

\begin_layout Standard
En resumen, el aprovisionamiento de máquinas virtuales se realiza basado
 en los recursos disponibles y en los requisitos específicos de cada máquina
 virtual, según sea la funcionalidad que se le vaya a dar.
\end_layout

\begin_layout Subsection
Herramientas de aprovisionamiento 
\end_layout

\begin_layout Standard
Algunas de las herramientas de código abierto más utilizadas para aprovisionar
 son las siguientes: 
\end_layout

\begin_layout Itemize
Cobbler
\end_layout

\begin_layout Itemize
FAI
\end_layout

\begin_layout Itemize
Vagrant 
\end_layout

\begin_layout Itemize
Foreman
\end_layout

\begin_layout Subsubsection
Cobbler 
\end_layout

\begin_layout Standard
Cobbler es un servidor Linux de aprovisionamiento que centraliza y simplifica
 el control de los servicios incluyendo DHCP, TFTP y DNS con el propósito
 de realizar installaciones de sistemas operativos basadas en la red.
 Puede ser configurado para PXE, reinstalaciones y huéspedes virtualizados
 utilizando Xen, KVM o VMWare como también dispositivos físicos.
 Está dirigido especialmente a Red Hat Linux y sus derivados, pero es posible
 configurarlo para que inicie con PXE otras distribuciones de Linux como
 Debian, Ubuntu o Knoppix.
 Es una herramienta que se ecuentra en creciente desarrollo y cada vez añade
 más soporte a distintas distros e incluso a FreeBSD y a futuro Windows.
 Actualmente cuenta con poco soporte para el sistema operativo de Microsoft.
 
\end_layout

\begin_layout Standard
Cuenta con un sistema integrado para administración de configuración pero
 también cuenta con soporte para la integrar la herramienta de administración
 de configuración Puppet.
 Cobbler se basa en el mecanismo de Kickstart y ofrece perfiles de instalación
 que pueden ser aplicados a una o muchas máquinas.
 La información de contenida en un plantilla kickstart puede ser modificada
 dinámicamente pasando variables (llamadas ksmeta) o utilizando snippets,
 donde se puede mantener el código comúm simplificando la lectura y minimizando
 el tamaño del archivo kickstart.
\end_layout

\begin_layout Subsubsection
Fully Automatic Installation (FAI)
\end_layout

\begin_layout Standard
FAI es un sistema no interactivo para instalar, personalizar y administrar
 sistemas Linux y configuraiones de software en computadoras como también
 en máquinas virtuales y entornos chroot, desde pequeñas redes hasta una
 infraestructura grande escalable y clusters.
 Es una herramienta para la instalación totalmente automáica de Debian y
 otras distros de Linux como Suse, Red Hat, Solaris, vía red, DVDs personalizado
s de instalación o en entornos chroot.
 
\end_layout

\begin_layout Standard
Algunas de las características más importantes:
\end_layout

\begin_layout Itemize
Instalar y actualizar Debian, Ubuntu, SUSE, Red Hat, etc.
\end_layout

\begin_layout Itemize
Despliegue centralizado y administración de configuración.
\end_layout

\begin_layout Itemize
Recuperació de desastre integrado.
\end_layout

\begin_layout Itemize
Fácil configuración de software RAID y LVM.
\end_layout

\begin_layout Itemize
Instalar máquinas virtuales usando KVM, Xen y VirtualBox.
\end_layout

\begin_layout Itemize
Control remoto vía SSH durante la instalación.
\end_layout

\begin_layout Subsubsection
Vagrant
\end_layout

\begin_layout Standard
Vagrant provee entornos fáciles de reproducir, configurar construidos sobre
 tecnología industrial estándar.
 Vagrant es un software que crea y configura entornos de desarrollo virtuales
 aprovisionando sobre VirtualBox, VMware, KVM y contenedores Linux.
 Es una software que se encuentra una capa encima de estas herramientas.
 Luego herramientas de administración de configuración como Ansible, Chef,
 Salt, y Puppet pueden ser utilizadas para instalar y configurar automáticamente
 el software en la máquina.
\end_layout

\begin_layout Subsubsection
Foreman 
\end_layout

\begin_layout Standard
Foreman es una herramienta para el aprovisionamiento, configuración y monitoriza
ción de servidores físicos y virtuales.
 Puede aprovisionar máquinas bare-metal, virtualizadas y en la nube a través
 de installaciones desatendidas por medio de DHCP, DNS, TFTP y PXE .
 Tiene una gran integración con software de administración de configuración
 como Puppet, Chef, Salt y otros por medio de plugins.
\end_layout

\begin_layout Standard
Algunas de sus características son:
\end_layout

\begin_layout Itemize
Descubrir, aprovisioinar y actualizar toda la infraestructura bare-metal.
\end_layout

\begin_layout Itemize
Crear y gestionar instancias entre nubes privadas y públicas.
 
\end_layout

\begin_layout Itemize
Agrupar hosts y dirigirlos en conjunto, sin importar la ubicación.
 
\end_layout

\begin_layout Itemize
Reveer cambios históricos para auditoría y resolución de problemas.
\end_layout

\begin_layout Section
Orquestación
\end_layout

\begin_layout Standard
La orquestación describe el alineamiento automatizado, la coordinación y
 la administración de complejos sistemas de computadoras, middleware y servicios.
 En este sentido, la orquestaciónse trata de alinear los requisitos de negocio
 con las aplicaciones, datos e infraestructura.
 Define las políticas y niveles de servicio a través de flujos de trabajo
 automatizados, aprovisionamiento y gestión de cambio.
 Esto crea una infraestructura alineada con la aplicación que puede ser
 escalada hacia arriba o abajo basándose en las necesidades de cada aplicación.
\end_layout

\begin_layout Standard
La orquestación también provee la gestión centralizada de los recursos.
 Por ejemplo, reduce el tiempo y esfuerzo para desplegar múltiples instancias
 de una sola aplicación.
 Cuando es necesario que se creen más instacias de diferentes aplicaciones,
 herramientas automatizadas pueden realizar tareas que, previamente, podían
 ser llevadas a cabo sólo por múltiples administradores.
\end_layout

\begin_layout Standard
Un escenario que se puede encontrar, por ejemplo, un administrador necesita
 desplegar una aplicación web, pero para hacerlo, primero debe crear lel
 servidor de base de datos.
 Luego debe incluir en la base de datos todas las direcciones IP que pueden
 conectarse al servidor, y también agregar este nuevo servidor a la herramienta
 que lo monitorea, o abrir un puerto particular antes de proceder.
 Cada tarea expuesta puede ser automatizada, pero el conjunto de estas automatiz
aciones, junto con la coordinación secuencial de las mismas, realizada sin
 tener en cuenta el tipo de sistema operativo en el que corren, describen
 un proceso, en el cual actúa la orquestación.
\end_layout

\begin_layout Standard
No hay que confundir los términos automatización y orquestación.
 Éstos se podrían comparar con tarea y proceso.
 
\end_layout

\begin_layout Standard
La optimización de un proceso, por ejemplo, no se puede conseguir cimplemente
 por la automatización.
 A la automatización le concierne una tarea: ejecutar un servidor web, configura
r un servidor web, detener un servicio.
 A la orquestación, sin embargo, le concierne la ejecución de un flujo de
 trabajo (si se quiere automatizado) de un proceso.
 Un porceso de aprovisionamiento lleva a cabo múltiples tareas e involucrar
 múltiples sistemas.
 El objetivo de la orquestación no es sólo ejecutar automáticamente un servidor,
 lo cual aumenta la velocidad en el proceso de despliegue y lleva las aplicacion
es a producción más rápido.
 También permite una oportunidad para optimizar aquellos procesos para mejorar
 aún más la velocidad de despliegue.
\end_layout

\begin_layout Standard
Una de las maneras más simples de optimizar un proceso es eliminar los pasos
 repetitivos.
\end_layout

\begin_layout Standard
Entonces, automatización trata acerca de codificar tareas y orquestación
 acerca de codificar procesos.
 Esta última toma ventaja de la automatización para reutilizar bloques básicos.
\end_layout

\begin_layout Subsection
Herramientas de orquestación
\end_layout

\begin_layout Standard
Algunas de las herramientas de código abierto más utilizadas para orquestar
 son las siguientes: 
\end_layout

\begin_layout Itemize
Puppet 
\end_layout

\begin_layout Itemize
Chef 
\end_layout

\begin_layout Itemize
Ansible
\end_layout

\begin_layout Subsubsection
Puppet 
\end_layout

\begin_layout Standard
Es un sistema de orquestación que permite definir el estado de la infraestructur
a, forzando automáticamente que se llegue al estado correcto definido.
\end_layout

\begin_layout Standard
Puppet es una herramienta diseñada para administrar la configuración de
 sistemas similares a Unix y a Microsoft Windows de forma declarativa, es
 decir, se establece el estado requerido en vez como llegar al mismo..
 El usuario describe los recursos del sistema y sus estados utilizando el
 lenguaje declarativo que proporciona Puppet.
 Esta información es almacenada en archivos denominados “manifiestos”.
 Puppet descubre la información del sistema a través de una utilidad llamada
 Facter, y compila los manifiestos en un catálogo específico del sistema
 que contiene los recursos y la dependencia de dichos recursos, estos catálogos
 son ejecutados en los sistemas de destino.
 La capa de abstracción de recursos permite a los administradores describir
 la configuración en términos de alto nivel, tales como usuarios, servicios
 y paquetes sin necesidad de especificar los comandos específicos del sistema
 operativo (como rpm, yum, apt).
\end_layout

\begin_layout Standard
Una vez instalado el servidor masetro Puppet, todos los nodos en la infraestruct
ura deben tener instalado un agente Puppet.
\end_layout

\begin_layout Standard
Los sistemas soportados son Linux (Red Hat Enterprise y derivados, Debian,
 Ubuntu, Fedora), Unix (BSD, Mac OS X, Oracle Solaris, AIX) y Windows.
\end_layout

\begin_layout Subsubsection
Chef 
\end_layout

\begin_layout Standard
Es una herramienta de automatización de infraestructura de sistemas o administra
ción de configuraciones.
 Se enfoca en seguir un conjunto de pasos (llamados recetas) con el propósito
 de presentar un producto final ya listo para trabajar y/o probar.
\end_layout

\begin_layout Standard
Existen 2 tipos de versiones: 
\end_layout

\begin_layout Standard

\series bold
Chef Server
\series default
 está enfocado a ser el servidor central que permite suministrar a los diferente
s nodos clientes con las diversas configuraciones necesarias, las cuales
 se mantienen alojadas en el servidor.
 El cliente sondea periódicamente al Chef Server para corroborar las últimas
 políticas y estado de la red, en caso que haya algún parámetro desactualizado,
 el cliente lo actualiza.
 Además ofrece balanceo de carga, escalabilidad, búsquedas rápidas ente
 otros.
\end_layout

\begin_layout Standard

\series bold
Chef Solo
\series default
 es la versión de código abierto y reside localmente en el nodo, esto quiere
 decir que toda la información y recetas necesarias para configurar el nodo
 deben estar presentes en su disco duro.
 Esta herramienta utiliza Ruby-DLS para escribir las “recetas” (configuraciones
 de sistemas que describen como son manejadas las aplicaciones).
 Estas recetas, que pueden ser agrupadas para facilitar la administración,
 describen de forma secuencial una serie de recursos que deben estar en
 un estado particular.
\end_layout

\begin_layout Standard
Chef Server es soportado sobre RHEL/CentOS/Oracle Linux, y Ubuntu.
 Mientras que el soporte para los clients es AIX, RHEL/CentOS, FreeBSD,
 Mac OS X, Solaris (OS), Microsoft Windows, Ubuntu, ArchLinux, Debian, Fedora,
 y otros.
 
\end_layout

\begin_layout Subsubsection
Ansible 
\end_layout

\begin_layout Standard
Es una plataforma para configurar y administrar computadoras.
 Combina instalación multi-nodo, ejecuciones de tareas ad hoc y administración
 de configuraciones.
 
\end_layout

\begin_layout Standard
Ansible distingue dos tipos: controladores y nodos.
 Primero, existe una única máquina de control donde la orquestación comienza.
 Los nodos son manejados desde esa máquina por OpenSSH.
 La máquina de control conoce a los nodos a través de un inventario.
 Esta herramienta usa una arquitectura sin agentes, es decir, los nodos
 no necesitan instalar ni ejecutar en segundo plano ningún proceso que se
 comunique con la máquina de control.
 Sin embargo, los nodos deben contar con Python >= 2.4 y las máquinas de
 control con Python 2.6.
\end_layout

\begin_layout Standard
Dispone de módulos que trabajan sobre JSON y la salida estándar puede ser
 escrita en cualquier lenguaje.
 Nativamente utiliza YAML para describir configuraciones de los sistemas.
\end_layout

\begin_layout Standard
Los sistemas operativos soportados en las máquinas de control son la mayoría
 de las distribuciones Linux y Unix (Red Hat, Debian, CentOS, OSX, y BSD)
 entre otros excepto Windows.
\end_layout

\begin_layout Standard
Ansible puede instalarse en ambientes virtualizados, nubes públicas y privadas,
 incluyendo VMWare, OpenStack, AWS, Eucalyptus, KVM y CloudStack.
\end_layout

\begin_layout Part
Desarrollo
\end_layout

\begin_layout Section
Elección de la plataforma
\end_layout

\begin_layout Standard
Una vez realizada la interiorización de las diferentes herramientas utilizadas
 en el mercado, se decidió unificar la plataforma para el desarrollo del
 Proyecto Integrador.
 
\end_layout

\begin_layout Standard
Al principio se había comenzado a trabajar con FreeBSD, de manera remota
 con un servidor que dispone el Laboratorio de Arquitectura de Computadoras.
 Sin embargo, no se encontraron herramientas de aprovisionamiento y orquestación
 con la suficiente documentación o soporte para este sistema operativo.
 Por lo tanto, como sistema operativo base fue elegido CentOS 7, su última
 versión al día de la fecha.
 Esto es debido a que junto con su versión empresarial, es un sistema operativo
 muy robusto y confiable orientado a servidores y tal vez sea el más utilizado
 en el mercado.
 Además, se tuvo en cuenta la nueva estandarización del iniciador de sistemas,
 systemd, para esta versión del sistema operativo y para gran parte de las
 futuras entregas en diferentes distribuciones Linux, orientadas a servidor
 y también de escritorio.
\end_layout

\begin_layout Standard
Habiendo elegido CentOS 7, se optó por virtualizar haciendo uso de KVM,
 la cual fue desarrollada nativamente para esta distribución de Linux y
 que cuenta con una extensa documentación.
 A su vez, en el Laboratorio de Computación, existe un servidor que utiliza
 esta herramienta para servir a las terminales de ciertas aulas de informática.
 Consultando con los Directores del Proyecto, a profesionales en el tema
 se llegó a la conclusión que KVM es una herramienta estable y apta para
 un entorno de producción.
\end_layout

\begin_layout Standard
Para el aprovisionamiento de máquinas virtuales también por motivos de desarroll
o nativo, recomendación de profesionales que la han utilizado y en base
 a lecturas en foros que tratan este tema, se eligió a Cobbler, ya que es
 la más estable y fiable para entornos de producción.
 También cuenta con soporte integrado para orquestación con Puppet, herramienta
 que fue elegida por ser parte de los requerimientos del Proyecto.
\end_layout

\begin_layout Section
KVM
\end_layout

\begin_layout Subsection
Requerimientos de KVM
\end_layout

\begin_layout Standard
El hipervisor KVM requiere que el microprocesador cuente con VT-x para procesado
res de Intel o con AMD -V para los propios de AMD.
 Para poder confirmar que un un procesador cuenta con esto, en los sistemas
 basados en Linux, se debe ejecutar el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
grep -E 'svm|vmx' /proc/cpuinfo 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La salida de este comando es una porción del archivo /proc/cpuinfo en el
 cual se detallan las diferentes flags que contiene el procesador, entre
 ellas, la svm (AMD) o vmx (Intel).
 En caso de no poseer esas flags, el procesador no soporta hiper-virtualización
 y la salida será vacía.
\end_layout

\begin_layout Standard
La siguiente, es la salida obtenida con un AMD Athlon(tm) II P360 Dual-Core
 Processor de 1,7GHz:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat
 pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp
 lm 3dnowext 3dnow constant_tsc rep_good nopl nonstop_tsc extd_apicid pni
 monitor cx16 popcnt lahf_lm cmp_legacy 
\color red
svm
\color inherit
 extapic cr8_legacy abm sse4a 3dnowprefetch osvw ibs skinit wdt nodeid_msr
 hw_pstate npt lbrv svm_lock nrip_save 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Se debe asegurar que el módulo de KVM este cargado, para esto ejecutamos
 :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
lsmod | grep kvm 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La salida obtenida, nuevamente en la misma máquina que en el caso anterior
 es:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
kvm_amd 60554 0 kvm 448375 1 kvm_amd 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En caso de no estar cargados los módulos, se deben cargar manualmente.
\end_layout

\begin_layout Subsection
Restricciones de KVM
\end_layout

\begin_layout Itemize
El número máximo de CPUs por huésped es elevado (240 para RHE 7.1) por lo
 que no aplica en este trabajo.
 
\end_layout

\begin_layout Itemize
La virtualización anidada no está soportada.
 
\end_layout

\begin_layout Itemize
Sobre utilización de memoria es soportada por KVM utilizando el disco de
 swap.
 
\end_layout

\begin_layout Itemize
Sobre utilización de CPUs es soportada por KVM, se recomienda no utilizar
 más de diez CPUs virtuales por cada CPU físico.
\end_layout

\begin_layout Itemize
Virtualización de dispositivos SCSI no está soportada.
 Virtualización de dispositivos IDE en KVM es limitada a cuatro por huésped.
 
\end_layout

\begin_layout Itemize
Soporta 32 slots para dispositivos PCI (paravirtualizados) y 8 de estos
 por cada slot (datos RHE7) 
\end_layout

\begin_layout Itemize
La asignación de dispositivos referenciados a dispositivos físicos son de
 uso exclusivo a la VM .
\end_layout

\begin_layout Itemize
La migración y salvado, o restauración de la VM no está soportada mientras
 el dispositivo esté en uso.
 
\end_layout

\begin_layout Itemize
KVM no soporta kernels de real time.
 
\end_layout

\begin_layout Subsection
Instalación de paquetes de virtualización en CentOS 7 existente 
\end_layout

\begin_layout Standard
Se deben ejecutar los siguientes comandos:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
yum update 
\end_layout

\begin_layout Standard

\family typewriter
yum install qemu-kvm qemu-img 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Y se recomienda la instalación de los siguientes paquetes, con el siguiente
 comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
yum install kvm libvirt python-virtinst qemu-kvm virt-manager libvirt qemu-syste
m-x86 qemu-img libvirt-python libvirt-client virt-install virt-viewer python-vir
tinst
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection
Instalación utilizando kickstart con virt-install
\end_layout

\begin_layout Standard
Para conocer como utilizar virt-install revisar el man del mismo con:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
man virt-install
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Se puede automatizar la instalación de un sistema operativo utilizando un
 kickstart, es decir, un archivo que le indica al sistema operativo como
 debe instalarse, éste, además, permite ejecutar configuraciones pre y pos
 instalación.
 Se indica el archivo kickstart deseado en la creación de la maquina virtual,
 añadiendo la siguiente sección al comando virt-install:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
--extra-args="ks=http://192.168.122.1/ks.cfg 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Como se ve, el archivo se llama (en este caso) 
\family typewriter
ks.cfg 
\family default
y est alojado en un host con la direccioón IP 192.18.122.1
\end_layout

\begin_layout Subsection
Booteo por red con libvirt
\end_layout

\begin_layout Standard
Se necesita un servidor para PXE con DHCP y TFTP, dnsmasq y un servidor
 configurado por cobbler.
\end_layout

\begin_layout Subsubsection
Configuración de la red 
\end_layout

\begin_layout Standard
CentOS 7 soporta las siguientes configuraciones de red para la virtualización:
\end_layout

\begin_layout Itemize
Redes virtuales usando NAT (Network Address Translation)
\end_layout

\begin_layout Itemize
Dispositivos físicos distribuidos usando la asignación de dispositivos PCI
\end_layout

\begin_layout Itemize
Redes puenteadas (bridge) 
\end_layout

\begin_layout Standard
Se debe habilitar NAT, bridge o asignar directamente un dispositivo PCI
 para permitir a host externos acceder a los servicios de red en las máquinas
 virtuales huéspedes.
 
\end_layout

\begin_layout Subsubsection
NAT con libvirt 
\end_layout

\begin_layout Standard
Uno de los métodos más comunes para compartir las conexiones de red es usar
 NAT forwading (también conocido como redes virtuales).
 
\end_layout

\begin_layout Subsubsection
Configuración del host 
\end_layout

\begin_layout Standard
Cada instalación estándar de libvirt provee una conectividad basada en NAT
 a las máquinas virtuales como red virtual por defecto.
 Verificar que está disponible con el comando '
\family typewriter
virsh net-list --all
\family default
'.
 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# virsh net-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Nombre 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Estado 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Inicio automático 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Persistente 
\end_layout

\begin_layout Standard

\family typewriter
--------------------------------------------------------------------------------
-----------
\end_layout

\begin_layout Standard

\family typewriter
default
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 activo
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 si
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 si 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Si no se encuentra, lo siguiente puede ser usado en el archivo de configuración
 XML (
\family typewriter
/etc/libvirtd/qemu/myguest.xml
\family default
) para el huésped:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
ll /etc/libvirt/qemu
\end_layout

\begin_layout Standard

\family typewriter
total 24
\end_layout

\begin_layout Standard

\family typewriter
drwxr-xr-x 3 root root 4096 sep 7 11:42 ./
\end_layout

\begin_layout Standard

\family typewriter
drwxr-xr-x 6 root root 4096 sep 1 11:57 ../
\end_layout

\begin_layout Standard

\family typewriter
-rw------- 1 root root 3435 sep 3 10:58 centosLImpio.xml 
\end_layout

\begin_layout Standard

\family typewriter
-rw------- 1 root root 3458 sep 7 11:42 master.xml 
\end_layout

\begin_layout Standard

\family typewriter
drwxr-xr-x 3 root root 4096 sep 1 11:57 networks/ 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
La red por defecto está definida desde 
\family typewriter
/etc/libvirt/qemu/networks/default.xml
\end_layout

\begin_layout Standard
Para marcar la red por defecto para iniciar automáticamente:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# virsh net-autostart default
\end_layout

\begin_layout Standard

\family typewriter
Network default marked as autostarted
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para iniciar la red por defecto:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# virsh net-start default
\end_layout

\begin_layout Standard

\family typewriter
Network default started
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Una vez que la red por defecto de libvirt está corriendo, se verá un dispositivo
 bridge aislado.
 Este dispositivo no tiene ninguna interfaz física añadida.
 El nuevo dispositivo utiliza NAT e IP forwarding para conectarse a la red
 física.
 No añadir nuevas interfaces.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# brctl show 
\end_layout

\begin_layout Standard

\family typewriter
bridge name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

bridge id
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 STP enabled 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

interfaces 
\end_layout

\begin_layout Standard

\family typewriter
virbr0 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

8000.000000000000 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
libvirt añade reglas de iptables las cuales permiten el tráfico desde y
 hacia las máquinas virtuales huéspedes unidas al dispositivo virbr0 en
 las cadenas (chains) INOUT, FORWARD, OUTPUT y POSTROUTING.
 libvirt luego intenta habilitar el parámetro ip_forward.
 Algunas otras aplicaciones tal vez deshabiliten ip_forward por lo tanto
 lo mejor es dejar esta configuración fija añadiendo lo siguiente a 
\family typewriter
/etc/sysctl.conf
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
net.ipv4.ip_forward = 1 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection
Configuración de las máquinas virtuales huéspedes
\end_layout

\begin_layout Standard
Una vez que la configuración del host está completa, una máquina virtual
 huésped puede ser conectada a la red virtual basada en su nombre.
 Para conectar a un huésped a la red virtual por defecto, lo siguiente puede
 ser utilizado en el archivo de configuración XML para el huésped (
\family typewriter
/etc/libvirtd/qemu/myguest.xml
\family default
):
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
<interface type='network'> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<source network='default'/> 
\end_layout

\begin_layout Standard

\family typewriter
</interface> 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
NOTA: Definir la dirección MAC es opcional.
 Si no se define una, una dirección MAC es automáticamente generada y usada
 como la dirección MAC del dispositivo bridge utilizado por la red.
 Definirla manualmente es útil para mantener la consistencia o la facilidad
 de referencia a través del ambiente, o para evitar la posibilidad de conflicto
 (muy escasa).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
<interface type='network'>
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<source network='default'/> 
\end_layout

\begin_layout Standard

\family typewriter
<mac address='00:16:3e:1a:b3:4a'/>
\end_layout

\begin_layout Standard

\family typewriter
</interface>
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection
Bridged networking
\end_layout

\begin_layout Standard
Bridged networking (también conocido como virtual network switching) es
 usado para poner las interfaces de red de la máquinas virtuales en la misma
 red que la interfaz física.
\end_layout

\begin_layout Subsubsection
Bridged networking con Virtual Machine Manager
\end_layout

\begin_layout Standard
Procedimiento para crear un bridge con virt-manager: 
\end_layout

\begin_layout Enumerate
Desde el menú principal de virt-manager, ir a Editar > Detalles de la Conexión
 > Interfaces de Red (Edit > Connection Details > Network Interfaces) .
\end_layout

\begin_layout Enumerate
Pulsar el ícono + en la parte inferior.
\end_layout

\begin_layout Enumerate
En el Tipo de Interfaz (Interface type) del menú que se despliega, seleccionar
 Bridge y luego continuar.
 
\end_layout

\begin_layout Enumerate
En el campo Nombre (Name) ingresar un nombre como por ejemplo virbr0 o br0.
 
\end_layout

\begin_layout Enumerate
Seleccionar un Modo de inicio (Start mode) del menú desplegable.
 Seleccionar onboot (activa la interfaz bridge en el próximo reinicio de
 la máquina virtual).
\end_layout

\begin_layout Enumerate
Seleccionar la casilla Activar ahora (Activate now) para activarlo inmediatament
e.
 
\end_layout

\begin_layout Enumerate
Para configurar Configuraciones IP (IP settings) o Configuraciones Bridge
 (Bridge settings) realizar los cambios necesarios y pulsar OK al finalizar.
 
\end_layout

\begin_layout Enumerate
Seleccionar la interfaz física para conectar a las máquinas virtuales.
 
\end_layout

\begin_layout Enumerate
Pulsar Finalizar (Finish).
 
\end_layout

\begin_layout Enumerate
Seleccionar el bridge a utilizar y pulsar Aplicar (Apply).
\end_layout

\begin_layout Standard
Para detener la interfaz, pulsar Detener Interfaz (Stop Interface).
 Luego para eliminarla pulsar Delete Interface (Borrar Interfaz).
 
\end_layout

\begin_layout Subsubsection
Utilizar la interfaz por defecto virbr0
\end_layout

\begin_layout Standard
Para utrilizar la interfaz bridge por defecto, en el caso de arranque a
 través de la red por medio de PXE, en el paso 5/5 de la creación de una
 nueva máquina virtual con virt-manager, seleccionar bajo Opciones Avanzadas
 
\begin_inset Quotes eld
\end_inset

Especificar el nombre del dispositivo compartido
\begin_inset Quotes erd
\end_inset

 y en 
\begin_inset Quotes eld
\end_inset

Nombre del bridge
\begin_inset Quotes erd
\end_inset

 ingresar 
\family typewriter
virbr0
\family default
.
 
\end_layout

\begin_layout Subsection
Pools de almacenamiento
\end_layout

\begin_layout Standard
Un pool de almacenamiento es un conjunto de almacenamiento guardado por
 un administrador.
 Los pools de almacenamiento son divididos en volúmenes de almacenamiento
 por los administradores, y los volúmenes son asignados a las VM's como
 dispositivos de bloques.
\end_layout

\begin_layout Standard
Por ejemplo, el administrador de almacenamiento responsable por un servidor
 NFS crea un disco compartido que almacena toda la información de las VM's.
 El administrador definiría un pool de almacenamiento en el host de virtualizaci
ón usando el detalle de disco compartido.
 En este ejemplo, el administrador quiere que 
\family typewriter
nfs.example.com:/path/to/share
\family default
 sea montado en
\family typewriter
 /vm_data
\family default
.
 Cuando el pool es iniciado, libvirt monta el compartido en el directorio
 especifico, tal como lo haría el administrador del sistema logueándose
 y ejecutando mount.
 Si el pool está configurado con autostart, libvirt asegura que el disco
 compartido NFS es montado en el directorio especificado cuando libvirt
 es iniciado.
 Una vez que el pool esté iniciado, el directorio en el disco compartido
 NFS es reportado como un volúmen de almacenamiento y el path de los SV
 (storage volumes) pueden ser consultados por las APIs de libvirt.
 El path del SV puede entonces ser copiado en la sección que describe la
 fuente de almacenamiento en el archivo XML de las VM's para dispositivos
 de bloques.
 En el caso de NFS, una aplicación que usa las APIs de libvirt puede crear
 y eliminar SV en el SP(storage pool).
 No todos los tipos de SP soportan creación y destrucción de volúmenes.
 
\end_layout

\begin_layout Standard
Los SP y SV no son requeridos por la mayoría de las operaciones de las VM's.
 Note que uno de las características de libvirt is el protocolo remoto,
 entonces es posible administrar todos los aspectos de los ciclos de vida
 de las VM's así como las configuraciones de los recursos requeridos por
 las VM's.
 Esas operaciones deben representar a un host remoto con las API de libvirt.
 En otras palabras, un administrador usando aplicaciones de libvirt puede
 asegurar un usuario para desempeñar todas las tareas para configurar la
 maquina física para las VM's.
 Aunque el SP es un contenedor virtual, está limitado por dos factores:
 
\end_layout

\begin_layout Itemize
El tamaño máximo permitido por qemu-kvm y 
\end_layout

\begin_layout Itemize
el tamaño del disco de la máquina física.
\end_layout

\begin_layout Standard
Los siguientes son los tamaños máximos permitidos:
\end_layout

\begin_layout Itemize
virtio-blk -> 8 Exabytes 
\end_layout

\begin_layout Itemize
Ext4 -> 16 Terabytes 
\end_layout

\begin_layout Itemize
XFS -> 8 Exabytes
\end_layout

\begin_layout Standard
Libvirt usa un directorio basado en un SP, el 
\family typewriter
/var/lib/libvirt/images
\family default
, como el SP por defecto.
 Este, puede ser cambiado por otro.
\end_layout

\begin_layout Itemize

\series bold
Local storage pools:
\series default
 Los LSP están directamente unidos a la máquina física servidor.
 Los LSP incluyen : Directorios locales, discos directamente conectados,
 particiones físicas y LVM.
 Esos SV almacenan las imágenes de las VM's o son unidas a la VM's como
 almacenamiento adicional.
 Los LSP no son apropiados para muchos entornos de producción dado que no
 soportan migración en vivo
\end_layout

\begin_layout Itemize

\series bold
Networked storage pools:
\series default
 Loss NSP incluyen almacenamiento de dispositivos compartidos sobre una
 red usando protocolos estándar.
 NSP es requerido cuando las VM's migran entre dos máquinas físicas con
 virt-manager, pero es opcional cuando migran con virsh.
 Los protocolos soportados por los NSP incluyen: 
\end_layout

\begin_layout Itemize
Fibre Channel-based LUNs 
\end_layout

\begin_layout Itemize
iSCSI 
\end_layout

\begin_layout Itemize
NFS 
\end_layout

\begin_layout Itemize
GFS2 
\end_layout

\begin_layout Itemize
SCSI RDMA protocols (SCSI RCP)
\end_layout

\begin_layout Standard
Crear un SP basado en un disco usando virsh.
\end_layout

\begin_layout Enumerate
Crear una etiqueta GTP (GUID partition table) en el disco: 
\end_layout

\begin_layout Standard

\family typewriter
# 
\end_layout

\begin_layout Standard

\family typewriter
parted /dev/sdb 
\end_layout

\begin_layout Standard

\family typewriter
GNU Parted 2.1 
\end_layout

\begin_layout Standard

\family typewriter
Using /dev/sdb Welcome to GNU Parted! Type 'help' to view a list of commands.
 
\end_layout

\begin_layout Standard

\family typewriter
(parted) mklabel 
\end_layout

\begin_layout Standard

\family typewriter
New disk label type? gpt 
\end_layout

\begin_layout Standard

\family typewriter
(parted) quit 
\end_layout

\begin_layout Standard

\family typewriter
Information: You may need to update /etc/fstab.
\end_layout

\begin_layout Standard

\family typewriter
# 
\end_layout

\begin_layout Standard
2.
 Crear archivo de configuración del SP
\end_layout

\begin_layout Standard
Crear un archivo XML temporal conteniendo la información del SP requerida
 por el nuevo dispositivo.
 El archivo debe contener el formato mostrado abajo y contener los siguientes
 campos:
\end_layout

\begin_layout Standard

\series bold
<name>guest_images_disk</name> 
\series default
El parámetro determina el nombre del SP.
\end_layout

\begin_layout Standard

\series bold
<device path = '/dev/sdb' />
\series default
 Especifica el path donde se almacena el dispositivo.
\end_layout

\begin_layout Standard

\series bold
<target> <path>/dev</path></target> 
\series default
Determina la localización en el host físico donde es unido el volúmen creado
 con el SP.
\end_layout

\begin_layout Standard

\series bold
<formattype= 'gpt'/> 
\series default
Especifica el tipo de tabla de la partición.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
A modo de ejemplo se tiene:
\end_layout

\begin_layout Standard

\family typewriter
<pool type='disk'> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<name>guest_images_disk</name>
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<source> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<device path='/dev/sdb'/> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<format type='gpt'/> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

</source> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<target> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

<path>/dev</path> 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

</target>
\end_layout

\begin_layout Standard

\family typewriter
</pool> 
\end_layout

\begin_layout Standard
3.
 Asignar el dispositivo
\end_layout

\begin_layout Standard
Añadir la definición del storage pool usando el comando virsh pool-define
 con la configuración XML creada en el paso anterior.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-define ~/guest_images_disk.xml 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images_disk defined from /root/guest_images_disk.xml 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images_disk 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

inactive 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no 
\end_layout

\begin_layout Standard
4.
 Iniciar el storage pool 
\end_layout

\begin_layout Standard
Iniciar el storage pool con el comando 
\family typewriter
virsh pool-start
\family default
.
 Verificar que el pool es iniciado con el comando 
\family typewriter
virsh pool-list –all
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-start guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images_disk started 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 State
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images_disk
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no 
\end_layout

\begin_layout Standard
5.
 Habilitar inicio automático
\end_layout

\begin_layout Standard
El inicio automático configura el servicio libvirtd para iniciar el storage
 pool cuando el servicio inicia.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-autostart guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images_disk marked as autostarted 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images_disk 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard
6.
 Verificar la configuración del storage pool
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para verificar que el storage pool fue creado correctamente, los tamaños
 reportados correctamente y el estado sea 
\family typewriter
'running'
\family default
, ejecutar 
\family typewriter
virsh pool-info
\family default
.
 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-info guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Name: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
UUID: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

551a67c8-5f2a-012c-3844-df29b167431c 
\end_layout

\begin_layout Standard

\family typewriter
State: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

running 
\end_layout

\begin_layout Standard

\family typewriter
Capacity: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

465.76 GB 
\end_layout

\begin_layout Standard

\family typewriter
Allocation: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

0.00
\end_layout

\begin_layout Standard

\family typewriter
Available: 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

465.76 GB 
\end_layout

\begin_layout Standard

\family typewriter
# ls -la /dev/sdb 
\end_layout

\begin_layout Standard

\family typewriter
brw-rw----.
 1 root disk 8, 16 May 30 14:08 /dev/sdb 
\end_layout

\begin_layout Standard

\family typewriter
# virsh vol-list guest_images_disk 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Path
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Subsubsection
Borrar un storage pool utilizando virsh
\end_layout

\begin_layout Standard
1.
 Para evitar inconvenientes con otras máquinas virtuales huéspedes utilizando
 el mismo pool, lo mejor es pararlo y liberar los recursos usados por el
 mismo:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-destroy guest_images_disk
\end_layout

\begin_layout Standard
2.
 Eliminar las definiciones del storage pool:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-undefine guest_images_disk
\end_layout

\begin_layout Subsubsection
Crear sotrage pools basados en directorios con virsh
\end_layout

\begin_layout Standard
1.
 Crear la definición del storage pool
\end_layout

\begin_layout Standard
Usar el comando virsh pool-define-as para definir un nuevo storage pool.
 Hay dos opciones requeridas para la creación de un storage pool basado
 en directorio:
\end_layout

\begin_layout Itemize
El nombre del storage pool
\end_layout

\begin_layout Itemize
El path a un sistema de directorios de archivos para guardar los archivos
 imágenes del huésped.
 Si el directorio no existe, virsh lo creará.
 
\end_layout

\begin_layout Standard
Este ejemplo utilizat el directorio /guest_images.
 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-define-as guest_images dir - - - - "/guest_images" Pool guest_image
s defined
\end_layout

\begin_layout Standard
2.
 Verificar que el storage pool aparece en la lista 
\end_layout

\begin_layout Standard
Verificar que el storage pool es creado correctamente y el estado lo muestra
 como inactivo.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
--------------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

inactive 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no
\end_layout

\begin_layout Standard
3.
 Crear el directorio local
\end_layout

\begin_layout Standard
Usar el comando virsh pool-build para construir el storage pool basado en
 directorio para el directorio guest_images (por ejemplo) como se muestra:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-build guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images built 
\end_layout

\begin_layout Standard

\family typewriter
# ls -la /guest_images 
\end_layout

\begin_layout Standard

\family typewriter
total 8 
\end_layout

\begin_layout Standard

\family typewriter
drwx------.
 2 root root 4096 May 30 02:44 .
 
\end_layout

\begin_layout Standard

\family typewriter
dr-xr-xr-x.
 26 root root 4096 May 30 02:44 ..
 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

inactive 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

no 
\end_layout

\begin_layout Standard
4.
 Iniciar el storage pool 
\end_layout

\begin_layout Standard
Usar el comando pool-start para habilitar un directorio de storage pool,
 permitiendo que los volúmenes permitidos del pool sean usados como imágenes
 de disco de los huéspedes.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-start guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images started
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart 
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

active
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 no 
\end_layout

\begin_layout Standard
5.
 Habilitar inicio automático
\end_layout

\begin_layout Standard
El inicio automático configura el servicio libvirtd para iniciar el storage
 pool cuando el servicio inicia.
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-autostart guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Pool guest_images marked as autostarted 
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-list --all 
\end_layout

\begin_layout Standard

\family typewriter
Name
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 State 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Autostart
\end_layout

\begin_layout Standard

\family typewriter
----------------------------------------- 
\end_layout

\begin_layout Standard

\family typewriter
default
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 yes 
\end_layout

\begin_layout Standard

\family typewriter
guest_images
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

 active 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

yes 
\end_layout

\begin_layout Standard
6.
 Verificar la configuración del storage pool 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-info guest_images 
\end_layout

\begin_layout Standard

\family typewriter
Name: guest_images 
\end_layout

\begin_layout Standard

\family typewriter
UUID: 779081bf-7a82-107b-2874-a19a9c51d24c 
\end_layout

\begin_layout Standard

\family typewriter
State: running 
\end_layout

\begin_layout Standard

\family typewriter
Persistent: yes 
\end_layout

\begin_layout Standard

\family typewriter
Autostart: yes 
\end_layout

\begin_layout Standard

\family typewriter
Capacity: 49.22 GB 
\end_layout

\begin_layout Standard

\family typewriter
Allocation: 12.80 GB 
\end_layout

\begin_layout Standard

\family typewriter
Available: 36.41 GB 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
# ls -la /guest_images 
\end_layout

\begin_layout Standard

\family typewriter
total 8 
\end_layout

\begin_layout Standard

\family typewriter
drwx------.
 2 root root 4096 May 30 02:44 .
 
\end_layout

\begin_layout Standard

\family typewriter
dr-xr-xr-x.
 26 root root 4096 May 30 02:44 ..
 
\end_layout

\begin_layout Standard

\family typewriter
# 
\end_layout

\begin_layout Standard
Para verificar que el storage pool fue creado correctamente, los tamaños
 reportados correctamente y el estado sea 
\family typewriter
'running'
\family default
.
 Si se quiere que el pool sea accesible incluso si la máquina virtual huésped
 no está corriendo, asegurarse que 
\family typewriter
Persistent
\family default
 sea indicado como 
\family typewriter
yes
\family default
.
 Si se quiere que el pool inicie automáticamente cuando comienze el servicio,
 asegurarse que 
\family typewriter
Autostart
\family default
 esté indicado como 
\family typewriter
yes
\family default
.
\end_layout

\begin_layout Subsubsection
Borrar un storage pool utilizando virsh 
\end_layout

\begin_layout Standard
1.
 Para evitar inconvenientes con otras máquinas virtuales huéspedes utilizando
 el mismo pool, lo mejor es pararlo y liberar los recursos usados por el
 mismo:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-destroy guest_images_disk
\end_layout

\begin_layout Standard
2.
 Opcionalmente, si se quiere eliminat el directorio donde el storage pool
 reside, utilizar el siguiente comando:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-delete guest_images_disk
\end_layout

\begin_layout Standard
3.
 Eliminar la definición del storage pool:
\end_layout

\begin_layout Standard

\family typewriter
# virsh pool-undefine guest_images_disk 
\end_layout

\begin_layout Section
Cobbler
\end_layout

\begin_layout Standard
Para poder alojar las imágenes de los sistemas operativos, el servidor Cobbler
 debe contar con al menos 20 GB de disco.
 Para evitar inconvenientes, se debe deshabilitar SELinux y el firewall,
 de la siguiente forma.
 Editar el archivo /
\family typewriter
etc/sysconfig/selinux
\family default
 y setear:
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard

\family typewriter
SELINUX=disabled
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard
En el caso del firewall ejecutar ,para CentOS 6:
\end_layout

\begin_layout Standard

\family typewriter
service iptables stop 
\end_layout

\begin_layout Standard

\family typewriter
chkconfig iptables off
\end_layout

\begin_layout Standard
Para CentOS 7 (esta distro no utiliza iptables): 
\end_layout

\begin_layout Standard

\family typewriter
systemctl stop firewalld.service
\end_layout

\begin_layout Standard

\family typewriter
systemctl mask firewalld.service 
\end_layout

\begin_layout Standard

\family typewriter
systemctl status firewalld.service
\end_layout

\begin_layout Standard
O bien, si no se desea desactivarlo, permitir el acceso al los siguientes
 puertos de http 80/443, cobbler 69 y 25151:
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard

\family typewriter
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
\end_layout

\begin_layout Standard

\family typewriter
-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT
\end_layout

\begin_layout Standard

\family typewriter
-A INPUT -m state --state NEW -m tcp -p tcp --dport 69 -j ACCEPT 
\end_layout

\begin_layout Standard

\family typewriter
-A INPUT -m state --state NEW -m tcp -p tcp --dport 25151 -j ACCEPT
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard
Cerrar y guardar los cambios, luego ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
service iptables restart
\end_layout

\begin_layout Subsection
Pre requisitos.
 Instalación.
\end_layout

\begin_layout Standard
Primero y principal, Cobbler necesita python, alguna versión superior a
 la 2.6.
 Además, requiere la instalación de los siguientes paquetes:
\end_layout

\begin_layout Itemize
createrepo
\end_layout

\begin_layout Itemize
httpd (apache2 for Debian/Ubuntu)
\end_layout

\begin_layout Itemize
mkisofs mod_wsgi (libapache2-mod-wsgi for Debian/Ubuntu)
\end_layout

\begin_layout Itemize
mod_ssl (libapache2-mod-ssl)
\end_layout

\begin_layout Itemize
python-cheetah 
\end_layout

\begin_layout Itemize
python-netaddr
\end_layout

\begin_layout Itemize
python-simplejson 
\end_layout

\begin_layout Itemize
python-urlgrabber 
\end_layout

\begin_layout Itemize
PyYAML (python-yaml for Debian/Ubuntu) 
\end_layout

\begin_layout Itemize
rsync 
\end_layout

\begin_layout Itemize
syslinux 
\end_layout

\begin_layout Itemize
tftp-server (atftpd for Debian/Ubuntu) 
\end_layout

\begin_layout Itemize
yum-utils 
\end_layout

\begin_layout Standard
Mientras que cobbler web solo requiere Django (python-django para Debian/Ubuntu).
\end_layout

\begin_layout Standard
Entonces, para instalar todos los pre requisitos en CentOS 7, ejecutar:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
yum update
\end_layout

\begin_layout Standard

\family typewriter
yum install *
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Se debe añadir los repositorios necesarios para la instalación de cobbler.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para CentOS 7:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
\end_layout

\begin_layout Standard

\family typewriter
rpm -Uvh epel-release-*
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para CentOS 6:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
wget http://epel.mirror.net.in/epel/6/i386/epel-release-6-8.noarch.rpm
\end_layout

\begin_layout Standard

\family typewriter
rpm -Uvh epel-release-6-8.noarch.rpm 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Instalar cobbler junto con: 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
yum install cobbler cobbler-web dhcp debmirror pykickstart system-config-kicksta
rt dhcp mod_python tftp cman -y
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\size largest
\color magenta
En centos7 no se instalan mod_python, debmirror, ni cman (instalar encambio
 fence-tools) 
\end_layout

\begin_layout Subsection
Configuración.
\end_layout

\begin_layout Standard
Los siguientes cambios deberían ser realizados antes de comenzar a usar
 cobbler.
 Editar 
\family typewriter
/etc/xinetd.d/tftp
\family default
 modificando 
\family typewriter
disable = yes
\family default
 por no.
\end_layout

\begin_layout Standard
Luego editar 
\family typewriter
/etc/xinetd.d/rsync
\family default
 y del mismo modo cambiar 
\family typewriter
disable = yes 
\family default
por no.
\end_layout

\begin_layout Standard

\size largest
\color magenta
En centos 7 el de rsync: /etc/rsyncd.conf pero no está la opción
\end_layout

\begin_layout Standard
Configurar DHCP
\end_layout

\begin_layout Standard
Copiar el archivo de configuración de ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf
\end_layout

\begin_layout Standard
o
\end_layout

\begin_layout Standard

\family typewriter
cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Verificar en cada caso la versión de dhcp.
\end_layout

\begin_layout Standard
Luego editar 
\family typewriter
/etc/dhcp/dhcpd.conf 
\family default
y modificarlo como sea necesario, por ejemplo se tiene:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard

\family typewriter
# A slightly different configuration for an internal subnet.
\end_layout

\begin_layout Standard

\family typewriter
subnet 192.168.1.0 netmask 255.255.255.0 { 
\end_layout

\begin_layout Standard

\family typewriter
range 192.168.1.100 192.168.1.254; 
\end_layout

\begin_layout Standard

\family typewriter
option domain-name-servers puppet; 
\end_layout

\begin_layout Standard

\family typewriter
option domain-name "localdomain"; 
\end_layout

\begin_layout Standard

\family typewriter
option routers 192.168.1.1; 
\end_layout

\begin_layout Standard

\family typewriter
option broadcast-address 192.168.1.255; 
\end_layout

\begin_layout Standard

\family typewriter
default-lease-time 600; 
\end_layout

\begin_layout Standard

\family typewriter
max-lease-time 7200; } 
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Añadir a 
\family typewriter
/etc/hosts 
\family default
la dirección del servidor y su nombre (puppet).
 Luego configurar el parámetro 
\family typewriter
ServerName
\family default
 en 
\family typewriter
/etc/httpd/conf/httpd.conf 
\family default
con el nombre del host, en este caso será
\family typewriter
 puppet.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[...] 
\end_layout

\begin_layout Standard
ServerName puppet
\end_layout

\begin_layout Standard

\family typewriter
[...] 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Ahora iniciar todos los servicios:
\end_layout

\begin_layout Standard

\family typewriter
service httpd start 
\end_layout

\begin_layout Standard

\family typewriter
service dhcpd start 
\end_layout

\begin_layout Standard

\family typewriter
service xinetd start 
\end_layout

\begin_layout Standard

\family typewriter
service cobblerd start
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En CentOS 7 el formato es:
\end_layout

\begin_layout Standard

\family typewriter
systemctl start httpd.service
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Configurarlos para inicio automático:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
chkconfig httpd on 
\end_layout

\begin_layout Standard

\family typewriter
chkconfig dhcpd on 
\end_layout

\begin_layout Standard

\family typewriter
chkconfig xinetd on
\end_layout

\begin_layout Standard

\family typewriter
chkconfig cobblerd on
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En CentOS 7 el formato es:
\end_layout

\begin_layout Standard

\family typewriter
systemctl enable httpd.service
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Cobbler tiene varias plantillas de kickstarts ejemplo en
\family typewriter
 /var/lib/cobbler/kickstarts/
\family default
.
 Por defecto contraseña del servidor es “cobbler” y el comando 
\family typewriter
cobbler check
\family default
 informará de esto si no se cambia.
 Para hacer esto, generar una contraseña encriptada con:
\end_layout

\begin_layout Standard

\family typewriter
openssl passwd -1
\end_layout

\begin_layout Standard
Lo que nos dará algo similar a:
\end_layout

\begin_layout Standard

\family typewriter
Password: Verifying - Password: $1$U.Svb2gw$MNHrAmG.axVHYQaQRySR5/
\end_layout

\begin_layout Standard
Luego editamos el archivo 
\family typewriter
/etc/cobbler/settings 
\family default
cambiar la línea 
\family typewriter
“default_password_crypted”
\family default
 por la nueva contraseña generada.
\end_layout

\begin_layout Standard

\family typewriter
[...] default_password_crypted: "$1$U.Svb2gw$MNHrAmG.axVHYQaQRySR5/" [...]
\end_layout

\begin_layout Standard
Luego modificar “manage_dhcp: 0” para habilitar que cobbler administre DHCP
\end_layout

\begin_layout Standard

\family typewriter
[...] manage_dhcp: 1 [...]
\end_layout

\begin_layout Standard
Configurar ahora la dirección IP de Cobbler en las variables “server” y
 “next_server”, por ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard

\family typewriter
next_server: 192.168.1.200 
\end_layout

\begin_layout Standard

\family typewriter
[...] 
\end_layout

\begin_layout Standard

\family typewriter
server: 192.168.1.200 
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard
EL siguiente paso es modificar el archivo 
\family typewriter
/etc/cobbler/dhcp.template
\family default
 y realizar los cambios necesarios, por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
subnet 192.168.1.0 netmask 255.255.255.0 { 
\end_layout

\begin_layout Standard

\family typewriter
option routers 192.168.1.1; 
\end_layout

\begin_layout Standard

\family typewriter
option domain-name-servers 192.168.1.1; 
\end_layout

\begin_layout Standard

\family typewriter
option subnet-mask 255.255.255.0; 
\end_layout

\begin_layout Standard

\family typewriter
range dynamic-bootp 192.168.1.100 192.168.1.254; 
\end_layout

\begin_layout Standard

\family typewriter
default-lease-time 21600; 
\end_layout

\begin_layout Standard

\family typewriter
max-lease-time 43200; 
\end_layout

\begin_layout Standard

\family typewriter
next-server 192.168.1.200; 
\end_layout

\begin_layout Standard

\family typewriter
class "pxeclients" { match if substring (option vendor-class-identifier,
 0, 9) = "PXEClient"; 
\end_layout

\begin_layout Standard

\family typewriter
if option pxe-system-type = 00:02 {
\end_layout

\begin_layout Standard

\family typewriter
filename "ia64/elilo.efi"; 
\end_layout

\begin_layout Standard

\family typewriter
} else if option pxe-system-type = 00:06 {
\end_layout

\begin_layout Standard

\family typewriter
filename "grub/grub-x86.efi"; } 
\end_layout

\begin_layout Standard

\family typewriter
else if option pxe-system-type = 00:07 {
\end_layout

\begin_layout Standard

\family typewriter
filename "grub/grub-x86_64.efi"; } 
\end_layout

\begin_layout Standard

\family typewriter
else { filename "pxelinux.0"; 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para habilitar la interfaz web de Cobbler y configurar usuario y contraseña,
 modificar las siguientes líneas del archivo 
\family typewriter
/etc/cobbler/modules.conf 
\family default
para que queden de este modo:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[...] 
\end_layout

\begin_layout Standard

\family typewriter
[authentication] module = authn_configfile
\end_layout

\begin_layout Standard

\family typewriter
[...] 
\end_layout

\begin_layout Standard

\family typewriter
[authorization] module = authz_allowall 
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Ahora, para cambiar el usuario y la contraseña para la interfaz web, correr
 el siguiente comando e ingresar la contraseña preferida dos veces:
\end_layout

\begin_layout Standard

\family typewriter
htdigest /etc/cobbler/users.digest "Cobbler" admin
\end_layout

\begin_layout Standard
En este caso el usuario es admin y la contraseña se ingresa luego de ejecutar
 el comando.
 Por defecto se tiene usuario cobbler y contraseña cobbler.
\end_layout

\begin_layout Standard
Editar el archivo 
\family typewriter
/etc/debmirror.conf
\family default
 comentando lo siguiente:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[...] 
\end_layout

\begin_layout Standard

\family typewriter
#@dists="sid"; 
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard

\family typewriter
#@arches="i386"; 
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
El próximo paso es descargar los “network boot loaders” con 
\family typewriter
cobbler get-loaders.
\end_layout

\begin_layout Standard
Por último reiniciar los servicios:
\end_layout

\begin_layout Standard

\family typewriter
service httpd restart 
\end_layout

\begin_layout Standard

\family typewriter
service dhcpd restart 
\end_layout

\begin_layout Standard

\family typewriter
service xinetd restart 
\end_layout

\begin_layout Standard

\family typewriter
service cobblerd restart
\end_layout

\begin_layout Standard
Si todo va bien, al ejecutar 
\family typewriter
cobbler check
\family default
, devolverá algo similar a
\end_layout

\begin_layout Standard

\family typewriter
No configuration problems found.
 All systems go.
 
\end_layout

\begin_layout Standard
Sincronizar cobbler 
\family typewriter
cobbler sync.
\end_layout

\begin_layout Subsection
Importar imágenes ISO al servidor Cobbler
\end_layout

\begin_layout Standard
Para hacer esto se utiliza el comando mount.
 Primero crear un directorio:
\end_layout

\begin_layout Standard

\family typewriter
mkdir /mnt/centos
\end_layout

\begin_layout Standard
En CentOS 6:
\end_layout

\begin_layout Standard

\family typewriter
mount -o loop CentOS-6.6-x86_64-bin-DVD1.iso /mnt/centos 
\end_layout

\begin_layout Standard
En CentOS 7:
\end_layout

\begin_layout Standard

\family typewriter
mount -t iso9660 -o loop,ro /path/to/isos/CentOS-6.6-x86_64-bin-DVD1.iso /mnt/cent
os
\end_layout

\begin_layout Standard
Luego ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
cobbler import --name=CentOS_6 --arch=x86_64 --path=/mnt/centos 
\end_layout

\begin_layout Subsection
Tópicos generales de Cobbler
\end_layout

\begin_layout Subsubsection
Modelado
\end_layout

\begin_layout Standard
Cobbler utiliza objetos para definir la configuración de aprovisionamiento.
 A medida que nos movemos hacia abajo del árbol de objetos, las variables
 se sobre escriben y se añaden a la información definida en los objetos
 superiores.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h] 
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=4in,height=4in,keepaspectratio]{cobbler_modelado}
\end_layout

\begin_layout Plain Layout


\backslash
protect
\backslash
caption{Modelado de Cobbler} 
\backslash
label{cobbler_modelado}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Distros
\end_layout

\begin_layout Standard
Distribución que se desea instalar.
 Importar el contenido de la distro ayuda a disminuir el tiempo de instalación
 ya que no se utilizan fuentes de instalación externas.
 Generalmente es más fácil utilizar el comando 'import' en vez de añadir
 la distribución manualmente.
\end_layout

\begin_layout Subsubsection
Profiles
\end_layout

\begin_layout Standard
Un profile asocia una distribución a opciones especializadas adicionales,
 como puede ser una kickstart.
 Los profiles son el núcleo del aprovisionamiento y debe existir al menos
 uno por cada distribución.
 Un profile puede representar, por ejemplo, una configuración de web server
 o de escritorio.
\end_layout

\begin_layout Subsubsection
Systems 
\end_layout

\begin_layout Standard
Los grabaciones de sistemas mapean una pieza de hardware (o una máquina
 virtual) con el profile asignado a correr en ella.
 Esto puede verse como una forma de asignarle un rol a un sistema específico.
 Cuando se aprovisiona vía koan y PXE, no es necesario crearlos ya que son
 útiles cuando una personalización de un sistema específico es necesaria.
 Por ejemplo, personalizar la MAC, si hay un rol específico para una máquina
 dada, se debería crear una grabación del sistema para ésta.
\end_layout

\begin_layout Subsubsection
Images 
\end_layout

\begin_layout Standard
Cobbler puede bootear imágenes físicamente o virtualmente.
 Los despliegues de máquinas no basadas en imágenes son generalmente más
 fáciles para trabajar y llevan a una infraestructura más sustentable.
 La mayoría de las instalaciones de cobbler están directamente basadas en
 la distribución (kernel + initrd).
 La siguiente página documenta algunas cosas que no están basadas en kernel
 + initrd y muestra como instalarlas con cobbler y koan.
 Por ejemplo, trata la instalación de sistemas operativos Windows usando
 qemu/KVM: 
\end_layout

\begin_layout Standard

\family typewriter
https://fedorahosted.org/cobbler/wiki/AllAboutImages
\end_layout

\begin_layout Standard

\family typewriter
https://fedorahosted.org/cobbler/wiki/KoanWithIsos
\end_layout

\begin_layout Subsubsection
Repositorios 
\end_layout

\begin_layout Standard
Espejar repositorios le permite a Cobbler espejar el árbol de instalación
 (
\family typewriter
cobbler import
\family default
) y también paquetes opcionales.
 Si se espeja todo esto localmente en la red, las instalaciones y actualizacione
s serán más rápidas (usualmente es válido realizar esto para largos setups
 en datacenters, laboratorios, etc).
 Si un profile tiene un repositorio dado, este repositorio puede ser automáticam
ente configurado durante el aprovisionamiento y los sistemas instalados
 podrán usarlo como espejo (
\family typewriter
yum_post_install_mirror
\family default
 debe estar habilitado).
 Si se especifica una lista de paquetes para –rpm-list, se puede espejar
 solo esa parte del repositorio, más sus dependencias.
 Por ejemplo, si se espeja FC6 Extras, para descargar Cobbler y Koan, ponemos
 
\family typewriter
–rpm-list=”cobbler koan”
\family default
 y se saltea la parte de los paquetes de juegos.
 Esta función sólo funciona para repositorios http o ftp.
\end_layout

\begin_layout Standard
Los repositorios pueden ser creados del siguiente modo:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
cobbler repo add --mirror=url --name=string [--rpmlist=list] 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset

 [--creatrepo-flags=string] [--keep-updated=Y/N] [--priority=number] [--arch=str
ing] [--mirror-locally=Y/N] [--breed=yum|rsync|rhn]
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Donde
\end_layout

\begin_layout Standard

\series bold
mirror:
\series default
 Es la dirección del espejo yum.
 Puede ser una URL rsync:// , una ubicación ssh o una ubicación http://
 o ftp:// de un espejo.
 Direcciones del filesystem tabién funcionan.
 Esta dirección debe especificar un repositorio exacto a espejar, solo una
 arquitectura y una distribución.
\end_layout

\begin_layout Standard

\series bold
name: 
\series default
Este nombre es el usado para guardar la ubicación del espejo.
\end_layout

\begin_layout Standard

\series bold
rpm-list:
\series default
 Con esta opción se puede decidir espejar solo una parte de un repositorio
 (la lista de paquetes dados más dependencias).
 Por ejemplo : 
\family typewriter
--rpm-list="paquete_1 paquete_2"
\family default
.
 Esta opción sólo funciona con repositorios http:// y ftp:// para espejos
 de otros tipos esta opción será ignorada.
\end_layout

\begin_layout Standard

\series bold
createrepo-flags:
\series default
 Especifica banderas opcionales para añadir a la herramienta 
\family typewriter
createrepo
\family default
 la cual es llamada cuando se ejecuta 
\family typewriter
cobbler reposync
\family default
 para el repositorio dado.
 Por defecto se tiene 
\family typewriter
’-c cache’
\family default
.
\end_layout

\begin_layout Standard

\series bold
keep-updated: 
\series default
Especifica si el repositorio debería ser o no actualizado durante una ejecución
 normal de 
\family typewriter
cobbler reposync
\family default
.
 El repositorio puede seguir siendo actualizado por el nombre.
\end_layout

\begin_layout Standard

\series bold
mirror-locally: 
\series default
Cuando se configura a N, especifica que este repositorio yum se utiliza
 para ser referenciado directamente por kickstarts y no para ser espejado
 localmente en el servidor cobbler.
 Solo espejos con URLs http:// y ftp:// son soportados cuando se utiliza
 
\family typewriter
--mirror-locally=N
\family default
, no se puede usar URLs del filesystem.
\end_layout

\begin_layout Standard

\series bold
priority: 
\series default
Especifica la prioridad del repositorio (menor número, mayor prioridad)
 que se aplica a máquinas instaladas usando los repositorios que tienen
 el plugin yum priorities instalado.
 Por defecto se tiene 99.
\end_layout

\begin_layout Standard

\series bold
arch: 
\series default
Especifica la arquitectura que el repositorio debeía utilizar.
 Por defect se utiliza la arquitectura del servidor cobbler.
\end_layout

\begin_layout Standard

\series bold
breed: 
\series default
Usualmente cobbler comprenderá este parámetro si no se entrega.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para crear un repositorio local, por ejemplo para instalar Puppet sin una
 conexión a Internet, primero es necesario tener los paquetes necesarios
 y sus dependencias, para ello se ejecuta:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo yum install --downloadonly --downloaddir=<directory> <package>
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Donde se debe reemplazar 
\family typewriter
<directory> 
\family default
por el directorio donde se descargará el paquete con sus dependencias y
 
\family typewriter
<package>
\family default
 por el 
\family typewriter
puppet.
\end_layout

\begin_layout Standard
Una vez obtenidos, crear una carpeta con el nombre del repositorio en 
\family typewriter
/var/www/cobbler/repo_mirror 
\family default
por ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo mkdir /var/www/cobbler/repo_mirror/puppet
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Luego:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
cobbler repo add --name=puppet --keep-updated=N --arch=x86_64 --mirror-locally=Y
 --breed=yum
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Donde 
\family typewriter
--name 
\family default
debe ser el mismo que el de la carpeta creada anteriormente.
 Acto seguido ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
createrepo /var/www/cobbler/repo_mirror/puppet
\end_layout

\begin_layout Standard

\family typewriter
cobbler reposync
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para añadir este nuevo repositorio a un profile existente:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
cobbler profile edit --name=centos --repos=puppet 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Se muestra la información acerca del mismo con:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
cobbler repo report --name=puppet
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection
Repositorio local separado de Cobbler.
\end_layout

\begin_layout Standard
En el caso que se desee crear un repositorio local que no dependa del servidor
 Cobbler, se debe primero instalar los servicios necesarios para el funcionamien
to del servicio de repositorios:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo yum install -y createrepo vsftpd lftp
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Una vez hecho ésto, se tiene que crear el árbol de directorios adecuado
 de acuerdo a la aplicación.
 Éste puede estar divido según deseemos, por ejemplo, por sistema operativo,
 por distribución, por arquitectura, etc.
\end_layout

\begin_layout Standard
Se recomienda que se utilice como base el directorio 
\family typewriter
/var/ftp 
\family default
dado que se utilizará este sistema de transmisión de archivos utilizados.
\end_layout

\begin_layout Standard
Una vez creado el sistema de archivos, se guardan los correspondientes archivos
 rpm en los lugares adecaudos acordes a cómo se haya creado el árbol de
 archivos y se ejecuta el siguiente comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
creterepo -v /var/ftp/nombre_repo.repo
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Debemos configurar el demonio 
\family typewriter
vsftpd
\family default
 editando el archivo 
\family typewriter
/etc/vsftpd/vsftpd.conf
\family default
.
 Hay diversas configuraciones posibles, pero debemos asegurarnos de que
 haya dos puntos importantes:
\end_layout

\begin_layout Enumerate

\family typewriter
anonymous_enable=YES
\family default
: Indica que se puede acceder vía ftp de manera anónima.
\end_layout

\begin_layout Enumerate

\family typewriter
anon_root=/var/ftp
\family default
:Indica la raíz del directorio al cual se puede acceder de manera anónima.
\end_layout

\begin_layout Standard
Además, debemos asegurarnos de añadir la regla adecuada al firewall para
 permitir el acceso al puerto 21 o en su defecto, desactivar el firewall.
\end_layout

\begin_layout Standard
Por último, iniciar el servicio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
systemctl start vsftpd
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En el lado del cliente es necesario informar del nuevo repositorio.
 Para ésto, crear un archivo en 
\family typewriter
/etc/yum.repos.d/nombredelrepo.repo 
\family default
con el siguiente contenido:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[nombredelrepo] 
\end_layout

\begin_layout Standard

\family typewriter
name=nombredelrepo
\end_layout

\begin_layout Standard

\family typewriter
comment ="Repositorio local para proyecto integrador" 
\end_layout

\begin_layout Standard

\family typewriter
baseurl=ftp://IP_servidor/nombre_del_sistema_de_archivos
\end_layout

\begin_layout Standard

\family typewriter
gpgcheck=0 
\end_layout

\begin_layout Standard

\family typewriter
enabled=1
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Para utilizar este repositorio hay que habilitarlo, entonces:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
yum --enablerepo="nombredelrepo.repo"
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Luego es necesario actualizar base de datos de repositorios con el commando:
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
yum makecache
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Al momento de instalar un paquete, yum pedirá la clave pública GPG, si no
 se tiene instalada, se puede importar con el comando:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
rpm --import public.gpg.key
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En caso de no se tenga clave pública alguna, es posible desactivar la verificaci
ón de la misma en 
\family typewriter
/etc/yum.conf
\family default
 poniendo a cero el valor de 
\family typewriter
gpgcheck.
\end_layout

\begin_layout Standard
Es posible utilizar solo el repositorio recién creado y excluir los demás,
 para ello:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
yum --disablerepo=* --enablerepo=nombredelrepo install paquete
\end_layout

\begin_layout Subsubsection
Buildiso
\end_layout

\begin_layout Standard
Frecuentemente un entorno no puede soportar PXE porque otro grupo posee
 el control sobre las configuraciones DHCP y no entregará una entrada de
 
\family typewriter
next-server
\family default
 o sólo se están usando IPs estáticas.
 Esto se soluciona fácilmente:
\end_layout

\begin_layout Standard

\family typewriter
# cobbler buildiso
\end_layout

\begin_layout Standard
Este comando copia todos el kernel/initrd de la distro a una 'imagen de
 CD' booteable y genera un menú para la ISO que es esencialmente equivalente
 al menú PXE provisto para la instalación de máquinas por red vía Cobbler.
 Por defecto el menú del CD booteable va a incluir todos los profiles y
 systems.
\end_layout

\begin_layout Standard
Si se necesita instalar en un laboratorio u otro ambiente que no tenga acceso
 por red al servidor cobbler, se puede copiar completamente el árbol de
 la distribución más el profile y los systems records a una imagen.
\end_layout

\begin_layout Standard

\family typewriter
# cobbler buildiso --standalone –distro="distro1" 
\end_layout

\begin_layout Subsubsection
Import
\end_layout

\begin_layout Standard
El propósito de “
\family typewriter
cobbler import
\family default
” es configurar un servidor de instalación por red para una o más distribuciones.
 Éste espeja contenido basado en un imagen DVD, un archivo ISO, un árbol
 en un filesystem, un espejo externo rsync o una ubicación SSH.
\end_layout

\begin_layout Standard

\family typewriter
$ cobbler import --path=/path/to/distro –name=F12
\end_layout

\begin_layout Standard
Este ejemplo muestra los dos argumentos requeridos para import: --path y
 –name.
\end_layout

\begin_layout Standard
Luego de que import es ejecutado, cobbler tratará de detectar el tipo de
 distribución y automáticamente asignar kickstarts.
 Por defecto, proveerá el sistema borrando el disco duro, configurando eth0
 para DHCP y utilizando la contraseña por defecto “cobbler”.
 Si esto no es deseado, editar los archivos kickstart en 
\family typewriter
/var/lib/cobbler/kickstarts
\family default
 para hacer algo distinto o cambiar la configuración del kickstart después
 que cobbler cree el profile.
 El contenido espejado es guardado automáticamente en 
\family typewriter
/var/www/cobbler/ks_mirror
\family default
.
 
\end_layout

\begin_layout Standard
Ejemplos:
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=rsync://mirrorserver.example.com/path/ --name=fedora
 --arch=x86
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=root@192.168.1.10:/stuff --name=bar
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/mnt/dvd --name=baz --arch=x86_64
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/path/to/stuff –name=glorp
\end_layout

\begin_layout Enumerate

\family typewriter
cobbler import --path=/path/where/filer/is/mounted --name=anyname 
\backslash
 --available-as=nfs://nfs.example.org:/where/mounted/
\end_layout

\begin_layout Standard
Una vez importado, ejecutar “
\family typewriter
cobbler list
\family default
” o “
\family typewriter
cobbler report
\family default
” para ver que se ha añadido.
 Si se quiere forzar la utilización de una plantilla kickstart de cobbler
 para todos los profiles creados por un import, se puede pasar la opción
 
\family typewriter
–kickstart
\family default
 a import para saltar la auto detección del kickstart.
\end_layout

\begin_layout Subsubsection
Kickstarts
\end_layout

\begin_layout Standard
Los kickstarts son archivos que indican como debe ser configurado el Sistema
 Operativo, el archivo contiene palabras claves y valores y en otros casos
 solo contienen la palabra clave que en si misma es una configuracion especifica.
 
\end_layout

\begin_layout Standard
Algunas Keywords son opcionales, mientras que otras son necesarias para
 la instalacion.
\end_layout

\begin_layout Paragraph
Keywords
\end_layout

\begin_layout Itemize

\series bold
autopart (optional)
\series default
 : Creación automática de particiones, 1 GB o más para el root ( / ), una
 partición de intercambio y una partición de arranque apropiada para la
 arquitectura .
 Uno o más de los tamaños de las particiones por defecto puede ser redefinido
 con la zona de directivas.
\end_layout

\begin_layout Itemize

\series bold
ignoredisk (optional)
\series default
 : Hace que el instalador ignore los discos especificados.
\end_layout

\begin_deeper
\begin_layout Standard
La sintaxis es:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

ignoredisk --drives=drive1,drive2,...
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
autostep (optional) :REVISAR
\end_layout

\begin_layout Itemize

\series bold
auth or authconfig (required) :
\series default
Establece las opciones de autenticación para el sistema.
 Es similar al comando authconfig , que se puede ejecutar después de la
 instalación .
 Por defecto, las contraseñas son encriptadas y no están sombreados .
\end_layout

\begin_layout Itemize

\series bold
bootloader (required): 
\series default
Especifica cómo se debe instalar el gestor de arranque.
\end_layout

\begin_layout Itemize

\series bold
clearpart (optional) :
\series default
 Elimina las particiones del sistema , antes de la creación de nuevas particione
s .
 Por defecto, no se eliminan las particiones .
\end_layout

\begin_layout Itemize

\series bold
cmdline (optional) : 
\series default
Realiza la instalación en un modo de línea de comandos completamente no
 interactiva.
 Cualquier solicitud por interacciones detendrá la instalación.
\end_layout

\begin_layout Itemize

\series bold
device (optional) : 
\series default
El comando de dispositivo , indica al programa de instalación para instalar
 módulos adicionales , es en este formato :
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

device <type><moduleName> --opts=<options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
driverdisk (optional) : 
\series default
Disquetes de controladores se pueden usar durante instalaciones kickstart.
\end_layout

\begin_layout Itemize

\series bold
firewall (optional) : 
\series default
Esta opción corresponde a la pantalla de configuración de Firewall en el
 programa de instalación.
\end_layout

\begin_layout Itemize

\series bold
firstboot (optional) :
\series default
 Determinar si el Agente de configuración se inicia la primera vez que se
 arranca el sistema .
 Si se activa, el paquete Firstboot debe estar instalado.
 Si no se especifica, esta opción está desactivada por defecto.
\end_layout

\begin_layout Itemize

\series bold
halt (optional) : 
\series default
Detiene el sistema después de la instalación se ha completado con éxito
 .
 Esto es similar a una instalación manual , en donde anaconda muestra un
 mensaje y espera a que el usuario presione una tecla antes de reiniciar.
 Durante una instalación Kickstart, si no se especifica el método de terminación
, la opción reboot se utiliza como predeterminado.
\end_layout

\begin_layout Itemize

\series bold
graphical (optional) : 
\series default
Realice la instalación kickstart en modo gráfico .
 Este es el valor predeterminado .
\end_layout

\begin_layout Itemize

\series bold
install (optional) : 
\series default
Le dice al sistema para instalar un sistema nuevo en lugar de actualizar
 un sistema existente.
 Este es el modo por defecto.
 
\end_layout

\begin_layout Itemize

\series bold
ignore disk (optional) : 
\series default
Se utiliza para especificar los discos que anaconda no debe tocar durante
 la partición , el formato, y la limpieza .
 Este comando tiene un único argumento necesario , que toma una lista separada
 por comas de nombres de unidad de ignorar.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

ignoredisk --drives=[disk1,disk2,...]
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
interactive (optional) : 
\series default
Utiliza la información proporcionada en el archivo kickstart durante la
 instalación , pero permite la inspección y modificación de los valores
 dados .
 Se le presentará con cada pantalla del programa de instalación con los
 valores del archivo kickstart .
 Puede aceptar los valores haciendo clic en Siguiente o cambiar los valores
 y haga clic en Siguiente para continuar.
\end_layout

\begin_layout Itemize

\series bold
key (optional): 
\series default
Especifique una clave de instalación , que es necesaria para ayudar en la
 selección de paquetes e identificar su sistema con fines de apoyo.
 Este comando es Red Hat Enterprise Linux específico.
\end_layout

\begin_layout Itemize

\series bold
keyboard (required) : 
\series default
Establece el tipo de teclado.
\end_layout

\begin_layout Itemize

\series bold
lang (required) : 
\series default
Establece el idioma que desea utilizar durante la instalación y el idioma
 predeterminado para utilizar en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
langsupport (required) : 
\series default
Es obsoleto y su uso causará un mensaje de error que se debe imprimir a
 la pantalla y la instalación se detendra.
\end_layout

\begin_layout Itemize

\series bold
logvol (optional) : 
\series default
Crea un Logical Voume con la sintaxis:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

logvol <mntpoint> --vgname=<name> --size=<size> --name=<name><options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
logging (optional) : 
\series default
Este comando controla el registro de errores de anaconda durante la instalación.
 No tiene ningún efecto en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
monitor (optional) : 
\series default
Si no se da el comando monitor, anaconda utilizará X para detectar automáticamen
te la configuración del monitor.
\end_layout

\begin_layout Itemize

\series bold
mouse (required) : 
\series default
Palabra clave obsoleta y su uso causara un mensaje de error.
\end_layout

\begin_layout Itemize

\series bold
network (optional) : 
\series default
Configura la información de red para el sistema.Si la instalación no requiere
 redes y la información de la red no se proporciona en el archivo kickstart
 , el programa de instalación asume que la instalación debe hacerse sobre
 eth0 a través de una dirección IP dinámica ( BOOTP / DHCP) , y configura
 el sistema final , instalado para determinar su dirección IP de forma dinámica.
 
\end_layout

\begin_layout Itemize

\series bold
part or partition (required for installs, ignored for upgrades) : 
\series default
Crea una perticion en el sistema.
\end_layout

\begin_layout Itemize

\series bold
poweroff (optional) : 
\series default
Apaga el sistema luego de que la instacion se complete exitosamente.
\end_layout

\begin_layout Itemize

\series bold
raid (optional) : 
\series default
Monta un sistema RAID.
\end_layout

\begin_layout Itemize

\series bold
reboot (optional) : 
\series default
Reinicia el sistema despues de una instalacion exitosa.
\end_layout

\begin_layout Itemize

\series bold
repo (optional) : 
\series default
Configura un repositorio adicional YUM que puede ser utilizado como fuente
 para la instalacion de paquetes.
\end_layout

\begin_layout Itemize

\series bold
rootpw (required) : 
\series default
Establece la contraseña de root.
\end_layout

\begin_layout Itemize

\series bold
selinux (optional) : 
\series default
Establece el estado del SElinux en el sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
services (optional) :
\series default
Modifica el conjunto predeterminado de servicios que se ejecutarán bajo
 el nivel de ejecución predeterminado.
\end_layout

\begin_layout Itemize

\series bold
shutdown (optional) : 
\series default
Apaga el sistema despues de una instalacion exitosa.
\end_layout

\begin_layout Itemize

\series bold
text (optional) : 
\series default
Realice la instalación kickstart en modo texto.
 Las instalaciones Kickstart se ejecutan en modo gráfico por defecto.
\end_layout

\begin_layout Itemize

\series bold
timezone (required) : 
\series default
Selecciona la zona horaria del sistema.
\end_layout

\begin_layout Itemize

\series bold
upgrade (optional) : 
\series default
Indica que se realiza una actualizacion del sistema instalado.
\end_layout

\begin_layout Itemize

\series bold
user (optional) :
\series default
 Crea usuario en el sistema.
\end_layout

\begin_layout Itemize

\series bold
vnc (optional) : 
\series default
Permite que la instalación gráfica pueda ser vista de forma remota a través
 de VNC.
\end_layout

\begin_layout Itemize

\series bold
volgroup (optional) : 
\series default
Crea logical volume group con la sintaxis:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

volgroup <name><partition><options>
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
zerombr (optional) : 
\series default
Si se especifica zerombr , y sí es su único argumento , cualquier tabla
 de partición no válidas que se encuentran en los discos son inicializadas
 .
 Esto destruye todos los contenidos de discos con tablas de partición inválidas.
 
\end_layout

\begin_layout Subsubsection
Firewall
\end_layout

\begin_layout Standard
Dependiendo del uso, será necesario asegurar que iptables está configurado
 para permitir el acceso a los servicios correctos.
 Un ejemplo de configuración es el siguiente:
\end_layout

\begin_layout Standard
# Firewall configuration written by system-config-securitylevel
\end_layout

\begin_layout Standard
# Manual customization of this file is not recommended.
 
\end_layout

\begin_layout Standard
*filter :INPUT ACCEPT [0:0]
\end_layout

\begin_layout Standard
:FORWARD ACCEPT [0:0] 
\end_layout

\begin_layout Standard
:OUTPUT ACCEPT [0:0]
\end_layout

\begin_layout Standard
-A INPUT -p icmp --icmp-type any -j ACCEPT
\end_layout

\begin_layout Standard
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
\end_layout

\begin_layout Standard
# LOCALHOST
\end_layout

\begin_layout Standard
-A INPUT -i lo -j ACCEPT
\end_layout

\begin_layout Standard
# SSH
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT 
\end_layout

\begin_layout Standard
# DNS 
\end_layout

\begin_layout Standard
- TCP/UDP -A INPUT -m state --state NEW -m udp -p udp --dport 53 -j ACCEPT
 -A INPUT -m state --state NEW -m tcp -p tcp --dport 53 -j ACCEPT 
\end_layout

\begin_layout Standard
# DHCP 
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m udp -p udp --dport 68 -j ACCEPT 
\end_layout

\begin_layout Standard
# TFTP
\end_layout

\begin_layout Standard
- TCP/UDP -A INPUT -m state --state NEW -m tcp -p tcp --dport 69 -j ACCEPT
 -A INPUT -m state --state NEW -m udp -p udp --dport 69 -j ACCEPT 
\end_layout

\begin_layout Standard
# NTP
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m udp -p udp --dport 123 -j ACCEPT 
\end_layout

\begin_layout Standard
# HTTP/HTTPS
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A INPUT
 -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT 
\end_layout

\begin_layout Standard
# Syslog for cobbler
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m udp -p udp --dport 25150 -j ACCEPT 
\end_layout

\begin_layout Standard
# Koan XMLRPC ports 
\end_layout

\begin_layout Standard
-A INPUT -m state --state NEW -m tcp -p tcp --dport 25151 -j ACCEPT -A INPUT
 -m state --state NEW -m tcp -p tcp --dport 25152 -j ACCEPT
\end_layout

\begin_layout Standard
#-A INPUT -j LOG 
\end_layout

\begin_layout Standard
-A INPUT -j REJECT --reject-with icmp-host-prohibited
\end_layout

\begin_layout Standard
COMMIT
\end_layout

\begin_layout Subsubsection
SELinux
\end_layout

\begin_layout Standard
Para permitir el acceso del servidor web Apache por SELinux se puede hacer:
\end_layout

\begin_layout Standard

\family typewriter
setsebool -P httpd_can_network_connect true
\end_layout

\begin_layout Standard
o directamente deshabilitarlo.
\end_layout

\begin_layout Subsubsection
Servicios
\end_layout

\begin_layout Standard
Dependiendo si se está corriendo DHCP y DNS en el mismo servidor, será necesario
 habilitar varios servicios: 
\end_layout

\begin_layout Standard
/sbin/service httpd start 
\end_layout

\begin_layout Standard
/sbin/service dhcpd start 
\end_layout

\begin_layout Standard
/sbin/service xinetd start 
\end_layout

\begin_layout Standard
/sbin/service cobblerd start
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
/sbin/chkconfig httpd on 
\end_layout

\begin_layout Standard
/sbin/chkconfig dhcpd on 
\end_layout

\begin_layout Standard
/sbin/chkconfig xinetd on 
\end_layout

\begin_layout Standard
/sbin/chkconfig tftp on 
\end_layout

\begin_layout Standard
/sbin/chkconfig cobblerd on
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
El comando “
\family typewriter
cobbler check
\family default
” debería informar acerca de ésto.
\end_layout

\begin_layout Subsubsection
PXE
\end_layout

\begin_layout Standard
La instalación en máquinas “bare metal” desde la red utilizando PXE es directa.
 Se necesita configurar DHCP: 
\end_layout

\begin_layout Itemize
Si el servidor DHCP está en otro lado y no en el servidor Cobbler, su administra
dor debe setear su “
\family typewriter
next-server
\family default
” para especificar el servidor Cobbler.
 
\end_layout

\begin_layout Itemize
Si se está corriendo DHCP localmente y se quiere que Cobbler lo administre,
 se debe configurar la variable manage_dhcp a 1 en 
\family typewriter
/etc/cobbler/settings
\family default
, editar 
\family typewriter
/etc/cobbler/dhcp.template
\family default
 para cambiar configuración por defecto y ejecutar “
\family typewriter
cobbler sync
\family default
”.
\end_layout

\begin_layout Standard
Una vez que se tenga el PXE configurado, todos los profiles compatibles
 aparecerá por nombre en el menú de booteo PXE.
 Se puede seleccionar uno de la lista o por defecto la máquina booteará
 localmente.
 Si se quiere adjuntar un sistema particular a un profile particular la
 próxima vez que reinicie, se debe ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
cobbler system add --name=example --mac=$mac-address --profile=$profile-name
 
\end_layout

\begin_layout Standard
Luego la máquina booteará directamente con el profile seleccionado sin mostrar
 el menú.
\end_layout

\begin_layout Subsubsection
Reinstalación
\end_layout

\begin_layout Standard
Si se necesita reinstalar un sistema operativo a una máquina que tiene corriendo
 uno distinto, se puede utilizar:
\end_layout

\begin_layout Standard

\family typewriter
yum install koan 
\end_layout

\begin_layout Standard

\family typewriter
koan --server=bootserver.example.com --list=profiles koan --replace-self --server=
bootserver.example.com --profile=F12-i386 /sbin/reboot
\end_layout

\begin_layout Standard
El sistema instalará el nuevo sistema operativo luego del reinicio, sin
 interacción requerida.
\end_layout

\begin_layout Subsubsection
Virtualización
\end_layout

\begin_layout Standard
Si se quiere instalar un huésped virtual (KVM o Xen) se puede hacer:
\end_layout

\begin_layout Standard

\family typewriter
yum install koan
\end_layout

\begin_layout Standard

\family typewriter
koan --server=bootserver.example.com --virt --virt-type=xenpv –profile=F12-i386-xe
n
\end_layout

\begin_layout Standard
Se puede utilizar KVM u otro método de virtualización.
\end_layout

\begin_layout Subsubsection
Integración con Puppet
\end_layout

\begin_layout Standard
Este ejemplo es relativamente avanzado, involucrando “
\family typewriter
mgmt-classes
\family default
” de Cobbler para controlar diferentes tipos de configuración inicial.
 Pero si en cambio se opta por poner la mayor parte de la configuración
 inicial en Puppet en vez de aquí, entonces podría ser más simple.
\end_layout

\begin_layout Paragraph
Manter class mappings en cobbler
\end_layout

\begin_layout Standard
Primero se debe asignar “
\family typewriter
management classes
\family default
” a la distro, profile o system.
\end_layout

\begin_layout Standard

\family typewriter
cobbler distro edit --name=distro1 --mgmt-classes="distro1" 
\end_layout

\begin_layout Standard

\family typewriter
cobbler profile add --name=webserver --distro=distro1 --mgmt-classes="webserver
 likes_llamas" --kickstart=/etc/cobbler/my.ks 
\end_layout

\begin_layout Standard

\family typewriter
cobbler system edit --name=system --profile=webserver --mgmt-classes="orange"
 –dns-name=system.example.org
\end_layout

\begin_layout Standard
Para Puppet el –dns-name (mostrado arriba) debe estar configurado porque
 esto es lo que Puppet estará enviando a cobbler y es como encontrará el
 sistema.
 Puppet no tiene conocimiento sobre el nombre del sistema objeto en cobbler.
 Para hacerlo de forma segura, probablemente se utilice FQDN aquí (lo cual
 es lo que se quiere si se utiliza cobbler para administrar DNS).
 
\end_layout

\begin_layout Paragraph
External Nodes 
\end_layout

\begin_layout Standard
Cobbler provee uno, así configura Puppet para usar 
\family typewriter
/usr/bin/cobbler-ext-nodes
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
[main] 
\end_layout

\begin_layout Standard

\family typewriter
external_nodes = /usr/bin/cobbler-ext-nodes 
\end_layout

\begin_layout Standard
y también añadir lo siguiente al archivo de configuración: 
\end_layout

\begin_layout Standard

\family typewriter
node_terminus = exec
\end_layout

\begin_layout Standard
Ésto es un script simple que toma el información en la siguiente URL, la
 cual es una URL que siempre retorna un documento YAML en la forma que Puppet
 espera que sea retornado.
 Este archivo contiene todos los parámetros y clases que están para ser
 asignadas en el nodo en cuestión.
 Esta URL de Cobbler es: 
\family typewriter
http://cobbler/cblr/svc/op/puppet/hostname/foo
\end_layout

\begin_layout Standard
y esto retornará datos como: 
\end_layout

\begin_layout Standard

\family typewriter
--- classes: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- distro1 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- webserver 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- likes_llamas 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

- orange 
\end_layout

\begin_layout Standard

\family typewriter
parameters: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

tree: 'http://.../x86_64/tree'
\end_layout

\begin_layout Standard
Estos parámetros vienen de todo lo que Cobbler monitorea en “
\family typewriter
--ks-meta
\family default
” (también es un parámetro).
 De este modo se puede fácilmente añadir parámetros como añadir clases y
 mantener todo organizado en un lugar.
 En caso de tener parámetros o clases globales para añadir, esto se puede
 hacer editando los siguientes campos en
\family typewriter
 /etc/cobbler/settings
\family default
: 
\end_layout

\begin_layout Standard

\family typewriter
mgmt_classes: [ ] 
\end_layout

\begin_layout Standard

\family typewriter
mgmt_parameters: 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

from_cobbler: 1
\end_layout

\begin_layout Subsubsection
Replicate
\end_layout

\begin_layout Standard
Este comando descarga la configuración de un servidor Cobbler a otro.
 Sirve para tener implementaciones de High Availability, recuperación de
 desastres o para balanceo de carga.
\end_layout

\begin_layout Standard

\family typewriter
cobbler replicate --master=master.example.org
\end_layout

\begin_layout Standard
Con los argumentos por defecto, solo la metadata de la distribución y del
 perfil es sincronizada.
 A continuación se muestra los argumentos que se le pueden pasar a Cobbler
 para que replique: 
\end_layout

\begin_layout Standard

\family typewriter
# cobbler replicate --help 
\end_layout

\begin_layout Standard

\family typewriter
Usage: cobbler [options]
\end_layout

\begin_layout Standard

\family typewriter
Options: -h, --help show this help message and exit 
\end_layout

\begin_layout Standard

\family typewriter
--master=MASTER Cobbler server to replicate from.
 
\end_layout

\begin_layout Standard

\family typewriter
--distros=PATTERN pattern of distros to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--profiles=PATTERN pattern of profiles to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--systems=PATTERN pattern of systems to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--repos=PATTERN pattern of repos to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--image=PATTERN pattern of images to replicate 
\end_layout

\begin_layout Standard

\family typewriter
--omit-data do not rsync data 
\end_layout

\begin_layout Standard

\family typewriter
--prune remove objects (of all types) not found on the master
\end_layout

\begin_layout Paragraph
Setup
\end_layout

\begin_layout Standard
En cada servidor que será la réplica del master, instalar Cobbler normalmente
 y asegurarse que 
\family typewriter
/etc/cobbler/settings
\family default
 y 
\family typewriter
/etc/cobbler/modules.conf 
\family default
están configurados apropiadamente.
 Utilizar cobbler check para ver si existe algún error.
 El comando no modificará estos archivos.
 
\end_layout

\begin_layout Standard
Los archivos son transferidos por rsync (sobre ssh) o por scp, por lo que
 es necesario tener un agente ssh antes de utilizar el comando de réplica
 o si no, utilizar authorized_keys en el host remoto.
\end_layout

\begin_layout Section
Puppet
\end_layout

\begin_layout Standard
Puppet es en términos prácticos, un conjunto de proyectos como ser, puppet
 agent y server, hiera, puppetDB y Facter.
\end_layout

\begin_layout Standard
Puppet funciona bajo la arquitectura cliente servidor donde un el puppet
 máster indica a sus agentes que configuraciones deben aplicar.
 Ademas, los máster pueden aplicar manifiestos así mismos.
 Notar que hay dos etapas: 
\end_layout

\begin_layout Enumerate
Compilar los catálogos 
\end_layout

\begin_layout Enumerate
Aplicar los catálogos
\end_layout

\begin_layout Standard
Un catálogo es un archivo que describe los deseos de un estado de sistema
 para una PC en especifico.
 Enumera todos los recursos que necesitan ser administrados, así como las
 dependencias entre esos recursos.
\end_layout

\begin_layout Standard
En esta arquitectura, los nodos administrados corren la aplicación Puppet
 agent, usualmente en background y uno o mas servidores corren la aplicación
 Puppet máster administrada por un servidor web (como apache.) Periódicamente,
 los Puppet agent piden al puppet máster el catalogo.
 El máster, compila y corre el catalogo del nodo usando varias fuentes de
 información a las que tiene acceso.
 Una vez que recibe el catalogo, el agente chequea cada recurso descripto
 en el.
 Si encuentra algún recurso que no esta en el estado que se desea, se realizan
 los cambios necesarios para corregirlos.
 Luego de aplicar el catalogo el agente enviá un reporte al Máster.
\end_layout

\begin_layout Subsection
Comunicación y seguridad
\end_layout

\begin_layout Standard
El agente y el máster se comunican vía HTTPS con client-verification El
 máster provee una interfaz HTTP con varios extremos disponibles.
 Cuando se pide o enviá cualquier cosa al máster, el agente hace un pedido
 HTPS o uno de esos extremos.
\end_layout

\begin_layout Standard
Client-vefied HTTPS quiere decir que cada máster o agente tiene un identificador
 por certificado SSL y examinan los certificados de sus contrapartes para
 decidir si permite un intercambio de información.
 Puppet incluye un constructor de certificado de autorización para administra
 los certificados.
 Los agentes puede pedir automáticamente los certificados vía la API HTTP
 del máster.
 El administrador del máster puede usar el comando puppet cert para inspeccionar
 los pedidos y firmar nuevos certificados y los agentes pueden entonces
 descargar los certificados firmados.
 
\end_layout

\begin_layout Subsection
Tareas de pre-instalacion
\end_layout

\begin_layout Standard
Puppet usualmente corre bajo la arquitectura cliente-servidor, pero ademas,
 puede correr en una arquitectura autocontenida.
 La decision determina que paquetes serán instalados y que extra configuraciones
 necesarias se harán.
 Adicionalmente , usted se puede considerar usar la PuppetDB, la cual permite
 funciones extra de puppet y vuelve mas fácil consultar y analizar la informació
n de la infraestructura de puppet.
\end_layout

\begin_layout Standard
Se toma la opción de utilizar la arquitectura cliente-servidor.
 Se debe completar la instalación y configuración de todos los puppet masters
 antes de instalar cualquier agente.
 El máster necesariamente debe correr en un sistema basado en Unix
\end_layout

\begin_layout Subsubsection
Requerimientos de sistema y chequeo de versión de sistema operativo
\end_layout

\begin_layout Itemize
Hardware: El puppet agent no tiene requerimientos particulares de hardware
 y corre prácticamente en cualquier cosa, sin embargo, el servidor es un
 recurso intensivo y debe ser instalado en un servidor robusto y dedicado.
 Como mínimo, el servidor debe tener 2 procesadores y al menos 1GB de RAM,
 para administrar eficientemente 1000 nodos, debe poseer entre 2 y 4 procesadore
s y 4GB de RAM.
 
\end_layout

\begin_layout Itemize
Sistemas operativos soportados: Hay una variedad importante de distribuciones
 Linux que soportan puppet, entre ellas destaca la utilizada para la realización
 del trabajo, CentOS.
 
\end_layout

\begin_layout Itemize
Ruby: Se soportan varias versiones de Ruby, pero se recomienda el uso de
 las versiones 2.1.x 
\end_layout

\begin_layout Itemize
Librerías obligatorias: Facter 2.4.3 o posterior, Hiera 2.0.0 o posterior, json
 gem, cualquier versión moderna, rgen gem 0.6.6 o posterior 
\end_layout

\begin_layout Itemize
Librerías opcionales: msgpack gem es requerido si se utiliza msgpack racionaliza
ción.
\end_layout

\begin_layout Subsubsection
Chequeo de la configuración de red
\end_layout

\begin_layout Standard
En un agent/master deployment se debe preparar la red para el tráfico de
 puppet.
 
\end_layout

\begin_layout Itemize
Firewall: El máster debe permitir conexiones entrantes al puerto 8140 y
 los agentes deben ser capaces de conectarse a ese puerto.
 
\end_layout

\begin_layout Itemize
Resolución de nombres: Cada nodo debe tener un nombre único.
\end_layout

\begin_layout Subsection
Instalar Puppet 
\end_layout

\begin_layout Standard
Primero se debe instalar puppet master.
 Para ello:
\end_layout

\begin_layout Enumerate
Habilitar los paquetes de los repositorios de puppet labs: En los sistemas
 basados en yum el repositorio es soportado por las últimas versiones de
 RHEL y derivados.
\end_layout

\begin_deeper
\begin_layout Enumerate
En el caso de REHL 7 y derivados habilitamos el repositorio con el siguiente
 comando (versión 4.2.2):
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
sudo rpm -ivh https://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm
 
\end_layout

\end_deeper
\begin_layout Enumerate
Para versiones anteriores, como la 3.8 utilizar el siguiente:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
sudo rpm -ivh https://yum.puppetlabs.com/puppetlabs-release-el-7.noarch.rpm
 
\end_layout

\begin_layout Standard
En el caso de RHEL 6 y derivados:
\family typewriter

\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo rpm -ivh https://yum.puppetlabs.com/puppetlabs-release-el-6.noarch.rpm
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Instalar el puppet master con el siguiente comando: 
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
yum install puppetserver
\end_layout

\end_deeper
\begin_layout Enumerate
No iniciar el servicio aún
\end_layout

\begin_layout Subsubsection
Asignación de memoria 
\end_layout

\begin_layout Standard
Por defecto, puppet server está configurado para usar 2GB de RAM pero si
 se quiere experimentar con puppet server en una VM se puede asignar tan
 poco como 512MB de memoria.
 Para cambiar la asignación de memoria se edita el archivo de configuración,
 que se encuentra en 
\family typewriter
/etc/sysconfig/puppetserver
\family default
 y modificar la siguiente línea:
\end_layout

\begin_layout Standard

\family typewriter
# Modify this if you'd like to change the memory allocation, enable JMX,
 etc 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

JAVA_ARGS="-Xms2g -Xmx2g"
\end_layout

\begin_layout Standard
Si se desea por ejemplo, utilizar 512MB se debe reemplazar 2g por 512m:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

JAVA_ARGS="-Xms512m -Xmx512m"
\end_layout

\begin_layout Standard
Luego, para aplicar los cambios, se debe reiniciar el servicio con:
\end_layout

\begin_layout Standard

\family typewriter
service puppetserver restart
\end_layout

\begin_layout Subsubsection
Instalar el paquete puppet-agent
\end_layout

\begin_layout Standard
Una vez habilitado el repositorio como se indicó anteriormente, en los sistemas
 basados en yum como CentOS el puppet-agent se instala con el siguiente
 comando:
\end_layout

\begin_layout Standard

\family typewriter
sudo yum install puppet-agent
\end_layout

\begin_layout Standard
No se inicia el servicio aún.
 Por defecto, el valor del server es puppet, si se nombró de otra forma
 a la máquina servidora del puppet server, se debe editar esto.
\end_layout

\begin_layout Subsubsection
Configuraciones para los agentes
\end_layout

\begin_layout Standard
Básicas:
\end_layout

\begin_layout Itemize
server – El nombre del master server al cual se le pediran los manifiestos.
 Por defecto es Puppet 
\end_layout

\begin_layout Itemize
certname – Nombre con el cual el nodo pide el certificado y se presenta
 al servidor.
 
\end_layout

\begin_layout Itemize
environment – Indica el entorno solicitado cuando se contacta al master.
 De cualquier forma, el master puede configurarse para ignorar esta configuració
n.
 
\end_layout

\begin_layout Standard
Comportamiento de la ejecución: 
\end_layout

\begin_layout Itemize
noop – Si esta habilitado, el agnete no reializara ningun trabajo, en cambio,
 mirara que cambios se haria y lo reporta al master 
\end_layout

\begin_layout Itemize
priority – Permite asignar el valor “nice” para evitar que otras aplicaciones
 de la CPU no mueran de hambre mientras se aplican los catálogos 
\end_layout

\begin_layout Itemize
report – indica si se deben enviar reportes, por defecto es true.
 
\end_layout

\begin_layout Itemize
tags – Limita a los agentes a correr recursos con ciertas etiquetas.
 
\end_layout

\begin_layout Itemize
usecacheonfailure – se utiliza para tomar el ultimo buen catálogo si el
 master no posee uno bueno.
 
\end_layout

\begin_layout Itemize
prerun_command and postrun_command – Comandos que se desean correr de cada
 lado del puppet
\end_layout

\begin_layout Standard
Comportamiento del servicio: 
\end_layout

\begin_layout Itemize
runinterval – indica cada cuanto tiempo el agnete se contacta con el servidor
 para pedirle los manifiestos.
 Por defecto es de 30minutos.
 
\end_layout

\begin_layout Itemize
waitforcert – Indica al agent que persista si no puede obtener su certificado.
 Por defecto esta habilitado.
 
\end_layout

\begin_layout Standard
Útilies cuando se ejecutan los agentes desde Cron: 
\end_layout

\begin_layout Itemize
splay and splaylimit – Se utiliza para sincronizar el agente y el server
 si el puppet agent utiliza un cron en lugar del demonio.
 
\end_layout

\begin_layout Itemize
daemonize – se debe colocar esta opción en falso si se utiliza un cron 
\end_layout

\begin_layout Itemize
onetime – sale luego de terminar el puppet actual.
 Debe ser true si se utiliza un cron.
\end_layout

\begin_layout Standard
Configuraciones para los master:
\end_layout

\begin_layout Standard
Básicas:
\end_layout

\begin_layout Itemize
dns_alt_names – Una lista de los hostname de los servers permitidos para
 usar cuando actuan como masters environment
\end_layout

\begin_layout Itemize
path – Indica la hubicacion del entorno.
 
\end_layout

\begin_layout Itemize
basemodulepath – una lista de las hubicaciones que contienen modulos que
 pueden ser usados en todos los environments 
\end_layout

\begin_layout Itemize
manifest – EL principal punto de entrada para compilar los catálogos.
 Por defecto es site.pp 
\end_layout

\begin_layout Itemize
reports – que controlador de reportes se usa.
\end_layout

\begin_layout Standard
Configuraciones relacionadas a Rack:
\end_layout

\begin_layout Itemize
ssl_client_header and ssl_client_verify_header – Son utilizados cunado corre
 el master puppet como un rack de aplicaciones.
\end_layout

\begin_layout Standard
Configuraciones de CA:
\end_layout

\begin_layout Itemize
ca - si actua como un ca 
\end_layout

\begin_layout Itemize
ca_ttl – indica por cuanto tiempo son validos los certificados 
\end_layout

\begin_layout Itemize
autosign – indica si los certifcados deben ser autofirmados.
\end_layout

\begin_layout Standard
Como ejemplo de configuración se tiene:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En el nodo que corre puppetserver, a la configuración por defecto, añadir:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
[...]
\end_layout

\begin_layout Standard

\family typewriter
certname = puppet
\end_layout

\begin_layout Standard

\family typewriter
server = puppet
\end_layout

\begin_layout Standard

\family typewriter
runinterval = 2m
\end_layout

\begin_layout Standard

\family typewriter
[...]
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection
Ejecutar puppet
\end_layout

\begin_layout Standard
Para el Puppet master, si es el único master en el deployment, o si actuará
 como el servidor de CA para un sitio con múltiples masters, se debe ejecutar
 puppet como sigue:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo puppet master --verbose --no-daemonize
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Esto creará el certificado de CA y el certificado del puppet master, con
 los nombres DNS apropiados incluidos.
 Una vez que se muestre en pantalla 
\family typewriter
Notice: Starting Puppet master version <VERSION>
\family default
, tipear Ctrl-C para matar el proceso.
\end_layout

\begin_layout Standard
Para corroborar la creación y firmado del servicio:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo puppet cert list --all
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En caso que el master no haga las veces de CA, parasolicitar un certificado,
 ejecutar:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
sudo puppet agent --test --ca_server=<SERVER> 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Luego en el master que oficia de CA:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
sudo puppet cert list 
\end_layout

\begin_layout Standard

\family typewriter
sudo puppet cert --allow-dns-alt-names sign <NAME> 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Este último es para firmar el certificado.
 Luego en el nuevo master, ejecutar nuevamente 
\family typewriter
sudo puppet agent --test --ca_server=<SERVER> 
\family default
para recibir el certificado.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Nota:
\series default
 si se recive 
\family typewriter
--bash: puppet: command not found error, 
\family default
entonces se tiene instalada la versión 4.X de Puppet.
 El directorio donde en esta versión se instalan los binarios, es 
\family typewriter
/opt/puppetlabs/bin 
\family default
y no está incluido en el default $PATH.
 Para incluir estos binarios en el default $PATH, añadirlos ejecutando:
 
\end_layout

\begin_layout Standard

\family typewriter
PATH=/opt/puppetlabs/bin:$PATH;export PATH.
\end_layout

\begin_layout Subsection
Tópicos generales de Puppet
\end_layout

\begin_layout Subsubsection
Module
\end_layout

\begin_layout Standard
Un módulo o module, es un conjunto de código de Puppet enpaquetado junto
 con los otros archivos y datos que se necesita administrar sobre algún
 aspecto del sistema.
 Consiste en una estructura predefinida de directorios que ayudan a Puppet
 a encontrar los contenidos del módulo.
 Para ver los módulos instalados se puede ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
puppet module list
\end_layout

\begin_layout Standard
Existe un repositorio público (The Puppet Forge) donde se pueden encontrar
 módulos hechos por la comunidad y también mantenidos por Puppet Labs.
\end_layout

\begin_layout Standard
Los módulos son auto-contenidos y separados.
 Su estructura de archivo le da a Puppet una forma consistente de localizar
 cualquier clase, plantillas, plugins y binarios requeridos para satisfacer
 la funcionalidad del módulo.
\end_layout

\begin_layout Standard
Todos los módulos accesibles por el Puppet Master están localizados en los
 directorios especificados por la variable 
\family typewriter
'modulepath'
\family default
 en el archivo de configuración de Puppet.
 Para encontrar esta variable en cualquier sistema con Puppet, se puede
 ejecutar:
\end_layout

\begin_layout Standard

\family typewriter
puppet agent --configprint modulepath 
\end_layout

\begin_layout Subsubsection
Node group 
\end_layout

\begin_layout Standard
Los grupos de nodos o node groups permiten segmentar todos los nodos de
 la infraestructura en grupos separados configurables basados en la información
 colectada por 'facter tool'.
\end_layout

\begin_layout Subsubsection
Resources
\end_layout

\begin_layout Standard
Cada recurso o resource, describe algún aspecto de un sistema y su estado,
 como por ejemplo, un servicio que debería estar ejectándose o un paquete
 que se quiere esté instalado.
 El bloque de código que describe un recurso se llama declaración de recurso
 (resource declaration).
 Estas declaraciones de recurso están escritas en código Puppet, un DLS
 (Domain Specific Language) construido en Ruby.
 El DLS de Puppet es un leguaje declarativo en vez de imperativo.
 Esto quiere decir que en vez de definir un proceso o un conjunto de comandos,
 el código de Puppet describe (o declara) solo el estado final deseado,
 y depende de proveedores integrados para lidiar con la implementación.
\end_layout

\begin_layout Standard

\family typewriter
puppet resource tool -> puppet resource <type> <name> 
\end_layout

\begin_layout Standard
Puppet incluye una variedad de tipos de recursos integrados, que permiten
 administrar varios aspectos de un sistema.
 Algunos de los tipos de recursos claves que generalmente se encuentran
 en un sistema son los siguientes:
\end_layout

\begin_layout Standard

\family typewriter
user 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un usuario 
\end_layout

\begin_layout Standard

\family typewriter
group 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un grupo de usuario 
\end_layout

\begin_layout Standard

\family typewriter
file 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un archivo específico 
\end_layout

\begin_layout Standard

\family typewriter
package 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un paquete de software 
\end_layout

\begin_layout Standard

\family typewriter
service 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un servicio corriendo
\end_layout

\begin_layout Standard

\family typewriter
cron 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un trabajo pogramado de cron 
\end_layout

\begin_layout Standard

\family typewriter
exec 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un comando externo 
\end_layout

\begin_layout Standard

\family typewriter
host 
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

Un host
\end_layout

\begin_layout Standard
Una declaración de recurso seguirá un patrón como el de abajo:
\end_layout

\begin_layout Standard

\family typewriter
tipo {'título': atributo => 'valor', }
\end_layout

\begin_layout Standard
Se puede utilizar la sintaxis de declaración de recursos conla herramienta
 '
\family typewriter
puppet apply
\family default
' con la bandera 
\family typewriter
-e (--execute)
\family default
 para hacer cambios rápidos en el sistema.
 Por ejemplo, para crear un usuario llamado 'galatea':
\end_layout

\begin_layout Standard

\family typewriter
puppet apply -e "user { 'galatea': ensure => 'present', }" 
\end_layout

\begin_layout Subsubsection
Manifiests 
\end_layout

\begin_layout Standard
Un manifiesto o manifest, es un archivo de texto que contiene código Puppet
 y posee la extensión 
\family typewriter
.pp
\family default
.
 Para comprobar la sintaxis de un manifiesto se puede utilizar:
\end_layout

\begin_layout Standard

\family typewriter
puppet parser validate <manifiesto.pp> 
\end_layout

\begin_layout Standard
El parseador no retornará nada si no hay errores, en caso de que se detecte
 un error se debe corregirlo antes de continuar.
 Si se trata de aplicar un manifiesto que no ha sido declarado, no cambiará
 nada en el sistema.
 Para ésto se debe crear un .pp que contenga un sentencia:
\end_layout

\begin_layout Standard

\family typewriter
include módulo::clase
\end_layout

\begin_layout Standard
Antes de aplicar cambios en el sistema, se puede utilizar la bandera 
\family typewriter
–noop
\family default
 para compilar el catálogo (catálogo) y notificar los cambios que Puppet
 habría realizado si hubiera sido ejecutado sin 
\family typewriter
–noop
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
puppet apply --noop 
\end_layout

\begin_layout Subsubsection
Catálogos
\end_layout

\begin_layout Standard
Los manifiestos de Puppet pueden usar lógica condicional para describir
 muchas configuraciones de nodos como una.
 Antes de configurar un nodo, Puppet compila los manifiestos en un catalogo,
 el cual solo es valido para un único nodo y no contiene lógica ambigua.
\end_layout

\begin_layout Standard
Los catálogos son documentos estáticos los cuales contienen recursos y relacione
s.
 
\end_layout

\begin_layout Standard
En la arquitectura estándar agent/master, los nodos requieren los catálogos
 al Puppet Server, el cual los compila cuando se lo requieren.
 Los agentes mantienen en cache sus mas recientes catálogos, si al pedir
 el catalogo, el master falla al compilarlo, ellos reusaran su catalogo
 cacheado.
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
Una clasees un bloque de código Puppet con nombre.
 Una clase administrará generalmente un conjunto de recursos relacionados
 a una función simple o un componente del sistema.
 Las clases usualmente contienen otras clases, este anidamiento provee una
 forma estructurada de juntar funciones de clases diferentes como componentes
 de soluciones más grandes.
 Para utilizar una clase, se necesita definirla escribiendo una definición
 de clase y guardándola en un archivo manifiesto.
 Cuando Puppet se ejecuta, parseará este manifiesto y guardará la definición
 de clase; luego ésta puede ser declarada para aplicarla en los nodos de
 la infraestructura.
 En Puppet las clases son singleton, lo que quiere decir que una clase puede
 ser declarada solo una vez en un nodo dado.
 Cuando se declara una clase:
\end_layout

\begin_layout Standard

\family typewriter
include módulo::clase
\end_layout

\begin_layout Standard

\family typewriter
módulo
\family default
 le indica a Puppet donde encontrar esa 
\family typewriter
clase
\family default
.
 Sin embargo, para la clase principal de un módulo, además de llevar el
 mismo nombre que el módulo mismo, en vez de seguir el patrón del manifiesto
 para la clase que contiene, Puppet reconoce el nombre especial del archivo
 'init.pp' como el manifiesto que contendrá la clase principal de un módulo.
 
\end_layout

\begin_layout Subsubsection
Referencias de tipo
\end_layout

\begin_layout Standard
Todos los tipos tiene un atributo especial llamado namevar.
 Este es el atributo usado para identificar univocamente un recurso en el
 sistema de destino.
 Si no se especifica un valor para el namevar, este valor es tomado por
 defecto según el titulo del recurso.
\end_layout

\begin_layout Standard
Ejemplo:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
file { '/etc/passwd': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

owner => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

group => root, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

mode => 644 
\end_layout

\begin_layout Standard

\family typewriter
} 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
En este código, 
\family typewriter
/etc/passwd
\family default
 es el titulo del recurso 
\emph on
file
\emph default
, otros códigos de Puppet pueden hacer referencia al recurso como File['/etc/pas
swd'] para declarar relación.
 Porque el path es el 
\emph on
namevar
\emph default
 para el tipo file y si nosotros no le proveemos un valor, toma el por defecto
 que es 
\emph on
/etc/passwd.
\end_layout

\begin_layout Standard
Los 
\series bold
atributos
\series default
, a veces llamados parámetros, de un recurso, determinan el estado deseado
 para el.
 Cualquiera de ellos modifica directamente el sistema (internamente, las
 llamadas “propiedades”) o afectan como el recurso se comporta.
 
\end_layout

\begin_layout Standard

\series bold
Providers
\series default
 implementan el mismo tipo de recursos en diferentes tipos de sistemas,
 ellos suelen hacer esto llamando a comandos externos.
 Aunque Puppet seleccionara automáticamente un provider apropiado por defecto,
 se puede sobrescribir este con el provider attribute.
 Por ejemplo, el recurso 
\emph on
package
\emph default
 de sistemas Red Hat tiene por defecto YUM como 
\emph on
provider
\emph default
, pero se puede especificar p
\family typewriter
rovider => gem
\family default
 para instalar librerías de Ruby con el comando gem.
 
\end_layout

\begin_layout Standard
Frecuentemente los providers especifican binarios que ellos necesitan.
 Los binarios calificados indican que el binario debe existir en ese path
 especifico y los no calificados, indican que puppet los buscara usando
 la ruta del shell.
 
\end_layout

\begin_layout Standard

\series bold
Features
\series default
 son habilidades que algunos providers pueden no soportar.
 Generalmente una característica corresponderá con algunos valores permitidos
 por un recurso de un atributo, por ejemplo, si un paquete soporta la caracterís
tica 
\emph on
purgeable
\emph default
, se puede especificar 
\family typewriter
ensure => purged 
\family default
para borrar los archivos de configuración instalados por el paquete.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Augeas:
\series default
 Aplica un cambio o un arreglo de cambios en el archivo de sistemas usando
 Auges 
\end_layout

\begin_layout Itemize

\series bold
Computer:
\series default
 Manejo de objetos de la computadora usando DirectyoryService en un SO X.
 
\end_layout

\begin_layout Itemize

\series bold
Cron:
\series default
 Instale y maneje trabajos Cron.
 Todo cron creado por Puppet requiere un comando y al menos un atributo
 de un periodo (horas, minutos,meses, etc).
 Mientras el nombre del Cron no es para del trabajo actual, el nombre es
 almacenado en un comentario comenzando con #Puppet Name:.
 Ese comentario es usado para machear entadas crontab creadas por Puppet
 con un recurso Cron.
 
\end_layout

\begin_layout Itemize

\series bold
Exec:
\series default
 Ejecuta comandos externos.
 Cualquier comando en un recurso Exec debe poder correr múltiples veces
 sin causar daños.
 
\end_layout

\begin_layout Itemize

\series bold
File:
\series default
 El manejo de archivos incluye su contenido, dueño, y permisos.
 El tipo archivo puede manejar archivos, directorios y enlaces simbólicos.
 
\end_layout

\begin_layout Itemize

\series bold
Filebucket:
\series default
 Un repositorio para almacenar y recuperar archivos conformados por MD5
 checksum.
 Puede ser local a cada nodo agente o centralizado en un master Puppet.
 Todos los Puppet Master proveen un servicio filebucket que los agentes
 pueden acceder vía HTTP.
 
\end_layout

\begin_layout Itemize

\series bold
Group:
\series default
 Manejo de grupos.
 En muchas plataformas esto solo puede crear grpos.
 Ingresar a los grupos debe ser administrado por los usuarios individuales.
 
\end_layout

\begin_layout Itemize

\series bold
Host:
\series default
 Instalar y manejar entradas de hosts.
 Para muchos sistemas, esas entradas deben estar solo en /etc/hosts, pero
 algunos SO tienen diferentes soluciones.
 
\end_layout

\begin_layout Itemize

\series bold
Interface:
\series default
 Esto representa una interfaz de router o switch.
 Es posible gestiona el modo interfaz y las características switchport.
 
\end_layout

\begin_layout Itemize

\series bold
K5login:
\series default
 Controla el archivo .k5login para un usuario.
 
\end_layout

\begin_layout Itemize

\series bold
Mailalias:
\series default
 Crea un alias email en la base de datos de alias local.
 
\end_layout

\begin_layout Itemize

\series bold
Maillist:
\series default
 Controla la lista de emails.
 Este tipo de recurso puede solo crear y remover listas, no puede reconfigurar
 listas actuales.
 
\end_layout

\begin_layout Itemize

\series bold
Mcx:
\series default
 Manejo de objetos MCX usando DirectoryService en SO X.
 
\end_layout

\begin_layout Itemize

\series bold
Mount:
\series default
 Manejo de filesystem montued, incluyen la colocación de informacion de
 montaje el la tabla de montaje.
 El comportamiento actual depende de el valor de el parámetro “ensure” 
\end_layout

\begin_layout Itemize

\series bold
Notify:
\series default
 Envió de un mensaje arbitrario a el log del agente en tiempo de ejecución.
 
\end_layout

\begin_layout Itemize

\series bold
Package:
\series default
 Manejo de paquetes.
 Hay una dicótoma básica en los paquetes soportados correctamente ahora:
 Algunos tipos de paquetes como yum y apt pueden recuperar sus propios archivos
 de paquetes, mientras que otros no pueden.
 Para esos paquetes, se puede usar el parametro source para poner el archivo
 adecuado.
 
\end_layout

\begin_layout Itemize

\series bold
Resources:
\series default
 Este es un metatipo que puede controlar otro tipo de recursos.
 Cualquier metaparametro especificado aquí sera pasado a los recursos generados,
 por lo que puede purgar recursos no administrados.
 
\end_layout

\begin_layout Itemize

\series bold
Router:
\series default
 Control de routers conectados.
 
\end_layout

\begin_layout Itemize

\series bold
Schedule:
\series default
 Define el programa para Puppet.
 Los recursos pueden ser limitados por un programa usando el metaparametro
 schedule.
 
\end_layout

\begin_layout Itemize

\series bold
SelBoolean: 
\series default
Manejo de SELinux Boolean en sistemas que soportan SELinux.
 
\end_layout

\begin_layout Itemize

\series bold
SelModule: 
\series default
Manejo de carga y descarga de modulos de política de SELinux en el sistema.
 
\end_layout

\begin_layout Itemize

\series bold
Service: 
\series default
Controla servicios en marcha.
 Desafortunadamente service soporta una amplia variedad por plataforma.
 Algunas tienen una variedad muy pequeña de concepto de servicio en ejecución.
 y algunos tienen un concepto muy poderoso.
 
\end_layout

\begin_layout Itemize

\series bold
Ssh_authorized_key: 
\series default
Manejo de llaves autorizadas SSH.
 Actualmente solo dos tipos de llaves son soportadas.
 
\end_layout

\begin_layout Itemize

\series bold
Sshkey: 
\series default
Instala y administra las llaves de host SSH.
 
\end_layout

\begin_layout Itemize

\series bold
Stage: 
\series default
Un tipo de recurso para crear nuevos escenarios.
 
\end_layout

\begin_layout Itemize

\series bold
Tidy: 
\series default
Remueve archivos base indeseados con criterios específicos.
 
\end_layout

\begin_layout Itemize

\series bold
User: 
\series default
Administración de usuarios.
 
\end_layout

\begin_layout Itemize

\series bold
Vlan: 
\series default
Administra VLANs en un router o switch 
\end_layout

\begin_layout Itemize

\series bold
Yumrepo: 
\series default
La descripción del lado del cliente de un repositorio YUM.
 La configuración de un repositorio se encuentra en /etc/yum.conf y el archivo
 indicado por la opción reposdir en el archivo.
 
\end_layout

\begin_layout Itemize

\series bold
Zfs: 
\series default
Administración de ZFS.
 Crea, destruye y pone propiedades en instancias ZFS.
 
\end_layout

\begin_layout Itemize

\series bold
Zpool: 
\series default
Administración de zpools.
 Crea y elimina zpools.
 El proveedor no sincroniza, solo reporta diferencias.
 Soporta vdevs con espejos, raidz, logs y spares
\end_layout

\begin_layout Subsubsection
\begin_inset space ~
\end_inset

Referencia de funciones
\end_layout

\begin_layout Standard
Hay dos tipos de funciones en Puppet, statements (declaraciones) y rvalues.
 Las statements no retornan argumentos, son utilizadas para hacer trabajos
 independientes como importar.
 Rvalues retornan valores y pueden ser usadas solo en un statement requiriendo
 un valor, como una asignación o una declaración case.
\end_layout

\begin_layout Standard
Las funciones se ejecutan en el Puppet master, no se ejecutan en el agente.
 Por lo tanto sólo tienen acceso a los comandos y datos disponibles en el
 host master.
\end_layout

\begin_layout Standard
Algunas de las funciones disponibles son:
\end_layout

\begin_layout Itemize

\series bold
alert:
\series default
 (statement) deja un mensaje en el log del servidor en el nivel de alerta.
\end_layout

\begin_layout Itemize

\series bold
assert_type:
\series default
(rvalue) retorna el valor dado si este es una instancia del tipo dado, y
 levanta un error en caso contrario.
 
\end_layout

\begin_layout Itemize

\series bold
contatin:
\series default
 (statement) contiene una o más clases dentro de la clase actual.
 Si alguna de estas clases están sin declarar, serán declaradas como si
 fueran llamadas con la función 
\emph on
include
\emph default
.
 
\end_layout

\begin_layout Itemize

\series bold
create_resources:
\series default
 (statement) convierte un hash en un conjunto de recursos y los añade al
 catálogo.
\end_layout

\begin_layout Itemize

\series bold
crit: 
\series default
(statement) deja un mensaje en el log del servidor en el nivel crítico.
\end_layout

\begin_layout Itemize

\series bold
debug: 
\series default
(statement) deja un mensaje en el log del servidor en el nivel de debug.
\end_layout

\begin_layout Itemize

\series bold
defined: 
\series default
(rvalue) determina si una clase dada o un tipo de recurso está definido.
 También puede determinar si un recurso específico está definido o si una
 variable ha sido asignada con un valor.
\end_layout

\begin_layout Itemize

\series bold
digest:
\series default
 (rvalue) retorna un valor de hash de un string dado usando la configuración
 digest_algorithm del archivo de configuración de Puppet.
\end_layout

\begin_layout Itemize

\series bold
each:
\series default
 (rvalue) aplica un bloque parametrizado a cada elemento en una secuencia
 de entradas seleccionadas del primer argumento y retorna el primero argumento.
\end_layout

\begin_layout Itemize

\series bold
emerg:
\series default
 (statement) deja un mensaje en el log del servidor en el nivel de emergencia.
\end_layout

\begin_layout Itemize

\series bold
epp:
\series default
 (rvalue) evalúa una plantilla Embedded Puppet y retorna el texto renderizado
 resultante como un string.
\end_layout

\begin_layout Itemize

\series bold
err:
\series default
 (statement) deja un mensaje en el log del servidor en el nivel de error.
\end_layout

\begin_layout Itemize

\series bold
fail:
\series default
 (statement) fallo con un error del parser.
\end_layout

\begin_layout Itemize

\series bold
file: 
\series default
(rvalue) carga un archivo desde un módulo y retorna sus contenidos como
 un string.
\end_layout

\begin_layout Itemize

\series bold
filter:
\series default
 (statement) aplica un bloque parametrizado a cada elemento en una secuencia
 de entradas del primer argumento y retorna un array o un hash con las entradas
 para cada bloque evalúa a true.
\end_layout

\begin_layout Itemize

\series bold
fqdn_rand:
\series default
 (rvalue) genera un número Integer aleatorio mayor o igual a cero y menor
 a MAX, combinando 
\emph on
$fqdn
\emph default
 y el valor de SEED para aleatoriedad repetible.
 Ésto quiere decir que cada nodo obtendrá un número aleatorio diferente
 de esta función pero el resultadod e un nodo dado será el mismo cada vez
 a menos que su hostname cambie (uso: fqdn_rand(MAX, [SEED])).
\end_layout

\begin_layout Itemize

\series bold
generate: 
\series default
(rvalue) llama a un comando externo en el Puppet master y retorna los resultados
 del comando.
 
\end_layout

\begin_layout Itemize

\series bold
hiera:
\series default
 (rvalue) realiza una búsqueda de prioridad estándar y retorna el valor
 más específico para una clave dada.
\end_layout

\begin_layout Itemize

\series bold
hiera_array:
\series default
 (rvalue) retorna todas las coincidencias a través de la jerarquía como
 un array plano de valores únicos.
\end_layout

\begin_layout Itemize

\series bold
hiera_hash: 
\series default
(rvalue) retorna un hash mezclado de coincidencias a través de la jerarquía.
 
\end_layout

\begin_layout Itemize

\series bold
hiera_include: 
\series default
(rvalue) asigna clases a un nodo usando un array de búsqueda (array merge
 lookup ) que retorna el valor para una clave de usuario-específico de la
 fuente de datos de Hiera.
\end_layout

\begin_layout Itemize

\series bold
include:
\series default
 (statement) declara una o más clases, causando que los recursos en ellas
 sead evaluados y añadidos al catálogo.
\end_layout

\begin_layout Itemize

\series bold
info: 
\series default
(statement) deja un mensaje en el log del servidor en el nivel info.
\end_layout

\begin_layout Itemize

\series bold
inline_epp: 
\series default
(rvalue) evalúa una plantilla Embedded Puppet y retorna el texto renderizado
 resultante como un string.
\end_layout

\begin_layout Itemize

\series bold
inline_template:
\series default
 (rvalue) evalúa un string plantilla y retorna su valor.
\end_layout

\begin_layout Itemize

\series bold
lookup:
\series default
 (rvalue) busca datos definidos usando Data Binding y Data Providers utilizando
 diferentes estrategias.
\end_layout

\begin_layout Itemize

\series bold
match: 
\series default
(statement) retorna el resultado de coincidir un string o un array[string]
 con regexp, string (transformado a regexp, tipo pattern o tipo regexp).
\end_layout

\begin_layout Itemize

\series bold
md5: 
\series default
(rvalue) retorna un valor de hash MD5 de un string dado.
\end_layout

\begin_layout Itemize

\series bold
notice: 
\series default
(statement) deja un mensaje en el log del servidor en el nivel noticia.
\end_layout

\begin_layout Itemize

\series bold
realize: 
\series default
(statement) hace un objeto virtual, real.
 Es útil cuando se quiere saber el nombre del objeto virtual y no se quiere
 utilizar una colección entera.
\end_layout

\begin_layout Itemize

\series bold
reduce: 
\series default
(rvalue) aplica un bloque parametrizado a cada elemento en una secuencia
 de entradas del primer argumento (
\emph on
el enumerable
\emph default
) y retorna el último resultado de la invocación del bloque parametrizado.
\end_layout

\begin_layout Itemize

\series bold
regsubst: 
\series default
(rvalue) realiza un reemplazo regexp en un string o array de strings.
\end_layout

\begin_layout Itemize

\series bold
requiere: 
\series default
(statement) evalúa una o más clases, añadiendo la clase requerida como dependenc
ia.
\end_layout

\begin_layout Itemize

\series bold
scanf: 
\series default
(rvalue) escanea un string y retorna un array de uno o más valores convertidos
 dirigidos por un formato dado string.args.
\end_layout

\begin_layout Itemize

\series bold
sha1: 
\series default
(rvalue) retorna un valor hash SHA1 de un string dado.
\end_layout

\begin_layout Itemize

\series bold
shellquote: 
\series default
(rvalue) cita y concatena argumentos para usar en Bourne Shell.
\end_layout

\begin_layout Itemize

\series bold
slice:
\series default
 (rvalue) aplica un bloque parametrizado a cada 
\emph on
slice 
\emph default
de elementos en una secuencia de entradas seleccionadas del primer argumento
 y retorna el primer argumento, o si ningún bloque es dado, retorna un nuevo
 array con una concatenación de los slices.
\end_layout

\begin_layout Itemize

\series bold
split:
\series default
 (rvalue) divide una variable string en un array usando el divisor regexp
 especificado.
\end_layout

\begin_layout Itemize

\series bold
sprintf: 
\series default
(rvalue) realiza un formateo de texto con estilo printf.
\end_layout

\begin_layout Itemize

\series bold
tag: 
\series default
(statement) añade las etiquetas especificadas a la clase o definición que
 la contiene.
 Todos los objetos también adquirirán luego esa etiqueta.
\end_layout

\begin_layout Itemize

\series bold
tagged:
\series default
 (rvalue) una función booleana que dice si el contenedor actual está etiquetado
 con las etiquetas especificadas.
 Las etiquetas son operadas con AND, así que todas deben ser incluidas para
 que la función retorne true.
\end_layout

\begin_layout Itemize

\series bold
template:
\series default
 (rvalue) carga una plantilla ERB de un módulo, la evalúa y retorna el valor
 resultante como un string.
\end_layout

\begin_layout Itemize

\series bold
versioncmp:
\series default
 (rvalue) compara dos números de versión.
\end_layout

\begin_layout Itemize

\series bold
warning: 
\series default
(statement) deja un mensaje en el log del servidor en el nivel advertencia.
\end_layout

\begin_layout Itemize

\series bold
with: 
\series default
(rvalue) llama a un bloque de código lambda con los argumentos dados.
 Como los parámetros de lambda son locales para el alcance de ella, esto
 puede ser utilizado para crear secciones privadas de lógica en una clase
 para que las variables no sean visibles fuera de la clase.
\end_layout

\begin_layout Subsubsection
Referencia de metaparámetros
\end_layout

\begin_layout Standard
Metaparámetros son atributos que trabajan con cualquier tipo de recurso,
 incluido los tipos personalizados y los tipos definidos.
\end_layout

\begin_layout Standard
En general, ellos afectan el comportamiento de Puppet en preferencia a el
 deseo del estado del recurso.
 
\end_layout

\begin_layout Standard
Los metaparametros hacen cosas como agregar metadata a un recurso (alias,tag),
 poner limites cuando el recurso debe ser sincronizado(require,schedule,etc.),
 evita que Puppet realice cambios (noop), y cambia la verborrea del log
 (loglevel).
\end_layout

\begin_layout Paragraph
Metaparametros disponibles
\end_layout

\begin_layout Itemize

\series bold
Alias: 
\series default
Crea un alias para el recurso.
 Puppet usa esto internamente cuando se provee un titulo simbólico y un
 valor de 
\emph on
namevar 
\emph default
explicito.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
file { 'sshdconfig': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

path => $operatingsystem ? { 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

solaris => '/usr/local/etc/ssh/sshd_config', 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

default => '/etc/ssh/sshd_config', 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

}, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

source => '...' 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
service { 'sshd': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

subscribe => File['sshdconfig'], 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Cuando se usa esta característica, el parser pone sshdconfig como el titulo,
 y la librería pone que es como un alias para el archivo entonces la dependencia
 trabaja hacia arriba en 
\family typewriter
Service['sshd'].
 
\family default
Se puede usar este metaparametro uno mismo, pero note que el aliases generalment
e solo trabaja creando relaciones; cualquier cosa mas que referirse a un
 recurso existente debe usar el titulo exacto del recurso.
 Por ejemplo, el siguiente código no funciona.
\end_layout

\begin_layout Standard
file { '/etc/ssh/sshd_config': 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

owner => root, 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

group => root, 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

alias => 'sshdconfig', 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
File['sshdconfig'] { 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

mode => '0644', 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Puppet no tiene forma de saber que esas dos estrofas deben afectar el mismo
 archivo.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
audit:
\series default
Marca un subconjunto de atributos sin administrar de recurso para auditar.
 Acepta un atributo nombre, un array de atributos nombre o todos.

\series bold
 
\end_layout

\begin_deeper
\begin_layout Standard
Auditar un atributo de un recurso tiene dos efectos: Primero, cuando un
 catalogo es aplicado con 
\family typewriter
puppet apply 
\family default
or 
\family typewriter
puppet agent,
\family default
 Puppet chequeara si ese atributo del recurso ha sido modificado, comparando
 el valor actual con el previo a la ejecución; cualquier cambio sera registrado
 junto a cualquier acción realizada por Puppet mientras aplica el catalogo
\end_layout

\begin_layout Standard
Segundo, marcar atributos de un recurso para auditar incluirá ese atributo
 en reportes de inspección generados por Puppet inspect.
\end_layout

\begin_layout Standard
Los atributos administrados para un recurso también pueden ser auditados,
 pero esos cambios serán realizados por puppet registrados como modificaciones
 adicionales.(Ej: Si un usuario manualmente edita un archivo cuyo contenido
 era auditado y administrado, en la próxima ejecución de puppet agent registrara
 ambas noticias: La primer ejecución registra la edición del usuario y luego
 revierte al estado deseado el archivo y segundo, registrara lo editado
 por Puppet.)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
before: 
\series default
Uno o mas recursos que depende de este recurso, expresados como referencia
 de recursos.
 Múltiples recursos pueden ser especificados como un conjunto de referencias.
 Cuando este atributo esta presente: 
\end_layout

\begin_deeper
\begin_layout Itemize
Este recurso se aplicara luego del recurso o los recursos de los cuales
 depende.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
loglevel: 
\series default
Coloca el nivel de informacion que sera registrada.
 Los niveles de registro tienen un gran impacto cuando los registros son
 enviados al syslog(que es el caso por defecto)
\end_layout

\begin_deeper
\begin_layout Standard
El orden por de los niveles, en prioridad decreciente, es:
\end_layout

\begin_layout Itemize
crit
\end_layout

\begin_layout Itemize
emerg 
\end_layout

\begin_layout Itemize
alert 
\end_layout

\begin_layout Itemize
err 
\end_layout

\begin_layout Itemize
warning 
\end_layout

\begin_layout Itemize
notice 
\end_layout

\begin_layout Itemize
info / verbose 
\end_layout

\begin_layout Itemize
debug
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
noop: 
\series default
Es para aplicar este recurso en modo noop.
\end_layout

\begin_deeper
\begin_layout Standard
Cuando aplica un recurso en modo noop, Puppet chequera si esta sincronizado,
 como cuando corre normalmente.
 Sin embargo, si un atributo de un recurso no esta en el estado deseado
 (como lo declara el catalogo), Puppet no realizara ninguna acción, y en
 su lugar, reportara los cambios que habría de hecho.
 Esos cambios simulados aparecen e el reporte enviado al Puppet Master,
 o serán mostrados en consola si 
\family typewriter
puppet agent
\family default
 o 
\family typewriter
puppet applay 
\family default
corren en primer plano.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
notify: 
\series default
Uno o mas recursos que depende de este recurso, expresados como referencia
 de recursos.
 Múltiples recursos pueden ser especificados como un conjunto de referencias.
 Cuando este atributo esta presente: 
\end_layout

\begin_deeper
\begin_layout Itemize
Este recurso sera aplicado antes que el recurso notificado
\end_layout

\begin_layout Itemize
Si Puppet hace cambios en este recurso, causara que todos los recursos notificad
os se refresquen
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
require: 
\series default
Uno o mas recursos que depende de este recurso, expresados como referencia
 de recursos.
 Múltiples recursos pueden ser especificados como un conjunto de referencias.
 Cuando este atributo esta presente: 
\end_layout

\begin_deeper
\begin_layout Itemize
El recurso o los recursos requeridos con anterioridad para aplicar este
 recurso.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
schedule: 
\series default
Un programa para gobernar cuando Puppet tiene permitido administrar este
 recurso.
 El valor de este metaparametro debe ser el nombre de un recurso 
\emph on
schedule.

\series bold
\emph default
 
\series default
Esto significa que se debe declarar un recurso schedule
\series bold
\emph on
 
\series default
\emph default
y luego referirse a el por su nombre
\series bold
.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
schedule { 'everyday': 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

period => daily, 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

range => "2-4" 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
exec { "/usr/bin/apt-get update": 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

schedule => 'everyday' 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
stage: 
\series default
En cual estado de ejecución esta clase debería residir.
\end_layout

\begin_deeper
\begin_layout Standard
Note que este metaparametro solo puede ser usado con clases, y solo declarándolo
s como recursos de sintaxis.
 No se puede usar con recursos normales o en clases declaradas con include.
\end_layout

\begin_layout Standard
Por defecto, todas las clases son declaradas en el estado principal.
 Para asignar una clase a un estado diferente, se debe:
\end_layout

\begin_layout Itemize
Declarar un nuevo estado como un recurso estado.
 
\end_layout

\begin_layout Itemize
Declarar un orden de relación entre el nuevo el nuevo estado y el estado
 principal
\end_layout

\begin_layout Itemize
Usar la sintaxis de recurso para declarar la clase y poner el estado deseado
\end_layout

\begin_layout Standard
Por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
stage { 'pre':
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

before => Stage['main'], 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
class { 'apt-updates': 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

stage => 'pre', 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
subscribe: 
\series default
Uno o mas recursos que depende de este recurso, expresados como referencia
 de recursos.
 Múltiples recursos pueden ser especificados como un conjunto de referencias.
 Cuando este atributo esta presente: 
\end_layout

\begin_deeper
\begin_layout Itemize
El recurso suscripto aplicara los cambios antes que este recurso.
\end_layout

\begin_layout Itemize
Si Puppet realiza cambios a cualquier recurso subscripto, esto causara que
 este recurso se refresque.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
tag: 
\series default
Agrega la etiqueta especificada al recurso asociado.
 si bien todos los recursos son automáticamente etiquetados con la mayor
 cantidad de informacion posible, puede ser útil agregar su propia etiquetas
 a los recursos.
\end_layout

\begin_deeper
\begin_layout Standard
Ejemplo:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
file {'/etc/hosts': 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

ensure => file, 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

source => 'puppet:///modules/site/hosts', 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

mode => '0644', 
\end_layout

\begin_layout Standard
\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset

tag => ['bootstrap', 'minimumrun', 'mediumrun'], 
\end_layout

\begin_layout Standard
}
\end_layout

\end_deeper
\begin_layout Subsubsection
Lenguaje
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Standard
Las variables guardan valores para que sean accedidos más tarde.
 En Puppet, las variables son en realidad constantes ya que no pueden ser
 reasignadas.
 
\end_layout

\begin_layout Standard
Facts y variables incorporadas
\end_layout

\begin_layout Standard
Puppet tiene muchas variables pre-definidas que pueden ser utilizadas en
 los manifiestos.
 Para ver una lista de ellas ver :
\end_layout

\begin_layout Standard

\family typewriter
http://docs.puppetlabs.com/puppet/4.2/reference/lang_facts_and_builtin_vars.html
\end_layout

\begin_layout Paragraph
Sintaxis
\end_layout

\begin_layout Standard

\family typewriter
$contenido = "algún contenido
\backslash
n"
\end_layout

\begin_layout Standard
Los nombres de variables tienen como prefijo un signo $.
 Los valores son asignados a ellas con el símbolo = y se pueden asignar
 valores de cualquier tipo de dato.
 La variable contendrá el valor que la declaración resuelve, en vez de una
 referencia a la declaración.
 
\end_layout

\begin_layout Standard
Las variables solo pueden ser asignadas utilizando su nombre corto.
 Esto es, un alcance dado no puede asignar a variables en un ámbito exterior.
\end_layout

\begin_layout Paragraph
Asignar múltiples variables
\end_layout

\begin_layout Standard
Se pueden asignar múltiples variables de una vez desde un array o hash.
\end_layout

\begin_layout Subparagraph

\series bold
Arrays
\end_layout

\begin_layout Standard
Cuando se asignan múltiples variables desde un array, debe haber un número
 igual de variables y valores.
 Si no coinciden, la operación fallará.
 Arrays anidados también pueden ser usados.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
[$a, $b, $c] = [1,2,3] # $a = 1, $b = 2, $c = 3
\end_layout

\begin_layout Standard

\family typewriter
[$a, [$b, $c]] = [1,[2,3]] # $a = 1, $b = 2, $c = 3 
\end_layout

\begin_layout Standard

\family typewriter
[$a, $b] = [1, [2]] # $a = 1, $b = [2] 
\end_layout

\begin_layout Standard

\family typewriter
[$a, [$b]] = [1, [2]] # $a = 1, $b = 2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Hashes
\end_layout

\begin_layout Standard
Cuando se asignan múltiples variables con un hash, las variables son listadas
 en un array en el lado izquierdo de la asignación, y el hash está del lado
 derecho.
 Las claves de hash deben coincidir su nombre correspondiente de variable.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
[$a, $b] = {a => 10, b => 20} # $a = 10, $b = 20 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Paragraph
Resolución
\end_layout

\begin_layout Standard

\family typewriter
file {'/tmp/testing': 
\end_layout

\begin_layout Standard

\family typewriter
ensure => file,
\end_layout

\begin_layout Standard

\family typewriter
content => $content, 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard

\family typewriter
$address_array = [$address1, $address2, $address3]
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
El nombre de la variable puede ser usado en cualquier lugar donde un valor
 de su tipo de dato fuera aceptado, incluyendo expresiones, funciones y
 atributos de recursos.
 Puppet reemplazará el nombre de la variable por su valor.
 Por defecto, variables sin asignar tienen el valor undef.
\end_layout

\begin_layout Paragraph
Interpolación
\end_layout

\begin_layout Standard

\family typewriter
$rule = "Allow * from $ipaddress"
\end_layout

\begin_layout Standard

\family typewriter
file { "${homedir}/.vim":
\end_layout

\begin_layout Standard

\family typewriter
ensure => directory, 
\end_layout

\begin_layout Standard

\family typewriter
...
 
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Puppet puede resolver variables en strings entre comillas dobles, esto es
 llamado interpolación.
 Dentro de las comillas dobles, se puede opcionalmente envolver el nombre
 de la variable (la porción luego de $) con llaves (${nombre_variable}).
 Esta sintaxis ayuda a evitar ambigüedades y permite ubicar las variables
 directamente siguiendo a caracteres que no son espacios en blanco.
 Estas llaves opcionales, están permitidas solo dentro de strings.
\end_layout

\begin_layout Paragraph
Comportamiento
\end_layout

\begin_layout Standard

\series bold
Alcance
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
El área de código donde una variable dada es visible está dictada por su
 alcance.
 Las variables en un alcance dado solo están disponibles dentro de ese alcance/á
mbito su alcance hijo, y cualquier alcance local puede sobre escribir localmente
 las variables que recibe de sus padres.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Acceso a variables fuera de alcance
\end_layout

\begin_layout Standard
Se puede acceder a variables fuera de alcance utilizando su nombre completo
 (qualified name)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
$vhostdir = $apache::params::vhostdir
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Variables sin asignar y Modo Estricto (Strict Mode)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Por defecto, se pueden acceder a variables a las que nunca se les han asignado
 valores.
 Su valor será 
\family typewriter
undef
\family default
.
 Usualmente esto no es algo deseado, ya que una variable sin asignar es
 usualmente un accidente o error de tipografía.
 
\end_layout

\begin_layout Standard
Si se desea que las variables sin asignar tiren un mensaje de error, para
 notificar ésto, se puede habilitar el modo estricto.
 Configurar 
\family typewriter
strict_variables = true
\family default
 en 
\family typewriter
puppet.conf 
\family default
en el Puppet master y cualquier nodo que ejecuta Puppet aplica.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Dependencia del orden de evaluación 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
A diferencia de las declaraciones de recursos, las asignaciones de variables
 son dependientes del orden de evaluación.
 Esto quiere decir que no se puede resolver una variable antes que haya
 sido asignada.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Nombramiento
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Los nombres de variables comienzan con el signo $ y son sensibles a mayúsculas.
 La mayoría de los nombres deben comenzar con una letra en minúscula o un
 guión bajo.
 Los nombres pueden incluir:
\end_layout

\begin_layout Itemize
Mayúsculas y minúsculas
\end_layout

\begin_layout Itemize
Números
\end_layout

\begin_layout Itemize
Guión bajo
\end_layout

\begin_layout Standard
Si el primer carácter es un guión bajo, esa variable debería ser accedida
 solo desde su propio alcance.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Nombres de variables calificados
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Los nombres calificados de variables tienen un prefijo con el nombre de
 su alcance y el :: separados de 
\family typewriter
namespace
\family default
.
 Por ejemplo, la variable 
\family typewriter
$vhostdir
\family default
 de la clase 
\family typewriter
apache::params
\family default
 sería 
\family typewriter
$apache::params::vhostdir.
\end_layout

\begin_layout Standard
Opcionalmente el nombre del primer namespace puede estár vacío, representando
 el namespace superior.
 Por ejemplo
\family typewriter
 $::is_virtual.
\end_layout

\begin_layout Paragraph
Recursos
\end_layout

\begin_layout Standard
Los recursos son la unidad fundamental para modelar la configuración del
 sistema.
 Cada recurso describe algún aspecto de un sistema, como un servicio o paquete
 especifico.
\end_layout

\begin_layout Standard
Cada recurso es asociado con un tipo de recurso el cual determina su tipo
 de configuración.
 Puppet tiene muchos tipos de recursos como archivos, cron, services, etc,
 Pero, ademas, se pueden agregar nuevos tipos, pudiendo escribir tipos nuevos
 o personalizando los existentes.
\end_layout

\begin_layout Standard
Cada recurso tiene un tipo de recurso, un titulo y un conjunto de atributos.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
<TYPE> { '<TITLE>': 
\end_layout

\begin_layout Standard
<ATTRIBUTE> => <VALUE>, 
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Nótese que se puede utilizar cualquier cantidad de espacios en blancos en
 el lenguaje de Puppet
\end_layout

\begin_layout Itemize

\series bold
Titulo: 
\series default
Es un string que identifica un recurso para el compilador de Puppet.
\end_layout

\begin_deeper
\begin_layout Standard
El titulo no tiene que coincidir con lo que va a administrar en el sistema,
 pero a menudo se desea eso.
 
\end_layout

\begin_layout Standard
Los títulos deben ser únicos por tipos de recursos, se puede tener un paquete
 y un servicios ambos con el mismo titulo, pero no dos servicios con ese
 titulo.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Atributos: 
\series default
Los atributos describen el estado deseado para un recurso; cada atributo
 maneja algún aspecto del recurso.
 
\end_layout

\begin_deeper
\begin_layout Standard
Cada tipo de recurso tiene su propio juego de atributos.
 Muchos tipos de recursos tienen un puñado de atributos claves y una gran
 cantidad de opcionales.
\end_layout

\begin_layout Standard
Todos los atributos declarados deben tener un valor; el tipo de dato del
 valor depende de los que acepte el atributo.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Comportamiento: 
\series default
Una declaración de recurso agrega un recurso al catalogo y le dice a Puppet
 que administre el estado del recurso.
 Cuando Puppet aplica el catalogo compilado, lo que hará es:
\end_layout

\begin_deeper
\begin_layout Itemize
Leer el estado actual del recurso en el sistema objetivo.
\end_layout

\begin_layout Itemize
Comprar el estado actual con el deseado
\end_layout

\begin_layout Itemize
Si es necesario, realizar cambios para llevar el estado actual al deseado
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Recursos no administrados: 
\series default
Si el catalogo no contiene un recurso, implica que Puppet ya no lo administra,
 pero no que lo 
\begin_inset Quotes eld
\end_inset

elimina
\begin_inset Quotes erd
\end_inset

, si se desea eliminarlo, se debe aclararlo en su estado deseado.
 ensure => absent
\end_layout

\begin_layout Itemize

\series bold
Singularidad: 
\series default
Puppet no permite que se declare un mismo recurso dos veces.
 Esto prevee conflictos de valores.
 Si múltiples clases requieren el mismo recurso se puede usar una clase
 o un recurso virtual para añadirlo al catalogo en múltiples lugares sin
 duplicar.
\end_layout

\begin_layout Itemize

\series bold
Relaciones y orden: 
\series default
Por defecto, Puppet aplica los recursos sin seguir el orden en que fueron
 escritos.
 Esto, se puede desactivar con la opción de ordenado.
 Sin embargo, si un recurso debe ser aplicado antes o después de otro, se
 puede indicar una relación entre ellos.
 Incluso se puede indicar que cambios en un recurso causen que otro se refresque.
\end_layout

\begin_layout Itemize

\series bold
Cambios, eventos y reportes: 
\series default
Si Puppet realiza cambios, en un recurso, registra esos cambios como eventos.
 Esos eventos aparecerán en el 
\emph on
log
\emph default
 y en el reporte de ejecución de puppet.
\end_layout

\begin_layout Itemize

\series bold
Independencia de alcance: 
\series default
Los recursos no están sujetos a los alcances.
 Un recurso, en cualquier ámbito, se puede referenciar desde cualquier otro
 ámbito.
\end_layout

\begin_layout Itemize

\series bold
Atributos especiales de los recursos.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Name/Namevar: 
\series default
Muchos tipos de recursos tiene un atributo el cual define un recurso en
 el sistema objetivo.
 Este atributo especial es el 
\emph on
namevar o name.
 
\emph default
Por ejemplo, el 
\emph on
name
\emph default
 de un servicio o paquete es el nombre por el cual las herramientas de paquetes
 o servicios lo reconocen o en el caso de un archivo, su namevar es el path.
 Esto es diferente al titulo, el cual identifica un recurso para el compilador
 de Puppet.
 Sin embargo, ellos a veces tienen el mismo valor.

\series bold
 
\series default
La separación de nombre y titulo permite administrar un recurso que mantiene
 su titulo, pero que tiene diferente nombre en diferentes plataformas.
 Por ejemplo, un servicio 
\emph on
ntp 
\emph default
en sistemas Red Hat tiene por nombre 
\emph on
ntpd 
\emph default
y 
\emph on
ntp 
\emph default
en sistemas debian.
\end_layout

\begin_layout Itemize

\series bold
Ensure: 
\series default
Esto generalmente maneja el aspecto mas importante de un recurso en el sistema
 objetivo.
 Indica si el archivo existe, si el servicio esta corriendo o parado, si
 el paquete esta instalado, etc.
\end_layout

\end_deeper
\end_body
\end_document
